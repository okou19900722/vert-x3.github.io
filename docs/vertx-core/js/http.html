<!DOCTYPE html>
<html lang="en">
<head>
  <title>编写 HTTP 服务端和客户端 - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="https://vertx.tk/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://vertx.tk/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="https://vertx.tk/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="https://vertx.tk/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="https://vertx.tk/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
  <style>
    .page-link-to-github {
      position: relative;
      z-index: 1;
      display: inline-block;
      border: 1px solid #782B90;
      border-radius: 5px;
      color: #782B90;
      font-size: 12px;
      padding: 4px 10px;
      text-decoration: none;
      background-color: #ffffff;
    }
    .page-link-to-github:hover {
      color: #ffffff;
      border-color: #ffffff;
      background-color: #782B90;
    }

    .page-link-to-github .github-icon {
      position: absolute;
      display: inline-block;
      width: 20px;
      height: 20px;
      /*background-position: -50px 0*/
      background: url('https://vertx.tk/assets/github.png') no-repeat 0 0;
    }

    @media (-webkit-min-device-pixel-ratio: 2),(min-resolution:192dpi) {
      .page-link-to-github .github-icon {
        background-image:url('https://vertx.tk/assets/github@2x.png');
        background-size: 150px auto
      }
    }

    .page-link-to-github:hover .github-icon {
      /*background-position: 0 0*/
      background-position: -100px 0
    }
    .text {
      text-decoration: underline
    }
    .page-link-to-github .text {
      padding-left: 27px
    }
    .text {
      padding-right: 8px
    }
    .page-link-to-github {
      float: right;
      top: 4px
    }

  </style>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://vertx.tk/" class="navbar-brand"><img alt="Brand" src="https://vertx.tk/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="https://vertx.io">官网</a></li>
        <li><a href="https://vertx.tk/download/">下载</a></li>
        <li><a href="https://vertx.tk/docs/">文档</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
        <li><a href="https://vertx.tk/community/">社区</a></li>
        <li><a href="https://vertx.tk/materials/">资料</a></li>
        <li><a href="https://vertx.tk/blog/">博客</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>编写 HTTP 服务端和客户端</h1>
          
        </div>
      </div>
    </div>
  </div>



<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_编写_http_服务端和客户端">编写 HTTP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_http_服务端">创建 HTTP 服务端</a></li>
<li><a href="#_配置_http_服务端">配置 HTTP 服务端</a></li>
<li><a href="#_配置_http_2_服务端">配置 HTTP/2 服务端</a></li>
<li><a href="#_记录服务端网络活动">记录服务端网络活动</a></li>
<li><a href="#_开启服务端监听">开启服务端监听</a></li>
<li><a href="#_收到传入请求的通知">收到传入请求的通知</a></li>
<li><a href="#_处理请求">处理请求</a></li>
<li><a href="#_发回响应">发回响应</a></li>
<li><a href="#_http_压缩">HTTP 压缩</a></li>
<li><a href="#_创建_http_客户端">创建 HTTP 客户端</a></li>
<li><a href="#_记录客户端网络活动">记录客户端网络活动</a></li>
<li><a href="#_发出请求">发出请求</a></li>
<li><a href="#_处理_http_响应">处理 HTTP 响应</a></li>
<li><a href="#_客户端启用压缩">客户端启用压缩</a></li>
<li><a href="#_http_1_x_pooling_和_keep_alive">HTTP/1.x Pooling 和 Keep alive</a></li>
<li><a href="#_http_1_1_pipe_lining">HTTP/1.1 pipe-lining</a></li>
<li><a href="#_http_2_多路复用">HTTP/2 多路复用</a></li>
<li><a href="#_http_连接">HTTP 连接</a></li>
<li><a href="#_httpclient_使用说明">HttpClient 使用说明</a></li>
<li><a href="#_服务端共享">服务端共享</a></li>
<li><a href="#_使用_https">使用 HTTPS</a></li>
<li><a href="#_websockets">WebSockets</a></li>
<li><a href="#_使用_http_https_连接代理">使用 HTTP/HTTPS 连接代理</a></li>
<li><a href="#_verticle_中自动清理">Verticle 中自动清理</a></li>
</ul>
</li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_编写_http_服务端和客户端">编写 HTTP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_http_服务端">创建 HTTP 服务端</a></li>
<li><a href="#_配置_http_服务端">配置 HTTP 服务端</a></li>
<li><a href="#_配置_http_2_服务端">配置 HTTP/2 服务端</a></li>
<li><a href="#_记录服务端网络活动">记录服务端网络活动</a></li>
<li><a href="#_开启服务端监听">开启服务端监听</a></li>
<li><a href="#_收到传入请求的通知">收到传入请求的通知</a></li>
<li><a href="#_处理请求">处理请求</a></li>
<li><a href="#_发回响应">发回响应</a></li>
<li><a href="#_http_压缩">HTTP 压缩</a></li>
<li><a href="#_创建_http_客户端">创建 HTTP 客户端</a></li>
<li><a href="#_记录客户端网络活动">记录客户端网络活动</a></li>
<li><a href="#_发出请求">发出请求</a></li>
<li><a href="#_处理_http_响应">处理 HTTP 响应</a></li>
<li><a href="#_客户端启用压缩">客户端启用压缩</a></li>
<li><a href="#_http_1_x_pooling_和_keep_alive">HTTP/1.x Pooling 和 Keep alive</a></li>
<li><a href="#_http_1_1_pipe_lining">HTTP/1.1 pipe-lining</a></li>
<li><a href="#_http_2_多路复用">HTTP/2 多路复用</a></li>
<li><a href="#_http_连接">HTTP 连接</a></li>
<li><a href="#_httpclient_使用说明">HttpClient 使用说明</a></li>
<li><a href="#_服务端共享">服务端共享</a></li>
<li><a href="#_使用_https">使用 HTTPS</a></li>
<li><a href="#_websockets">WebSockets</a></li>
<li><a href="#_使用_http_https_连接代理">使用 HTTP/HTTPS 连接代理</a></li>
<li><a href="#_verticle_中自动清理">Verticle 中自动清理</a></li>
</ul>
</li>
</ul>
        </div>

  <a href="https://github.com/okou19900722/vertx-web-site-translation-chinese/tree/master/vertx-translation-stack/vertx-core-translation"
     class="page-link-to-github"
     target="_blank"
     title="Edit this page on GitHub">
    <i class="github-icon"></i>
    <span class="text">编辑本页</span>
  </a>

        <div class="sect1">
<h2 id="_编写_http_服务端和客户端">编写 HTTP 服务端和客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 允许您轻松编写非阻塞的 HTTP 客户端和服务端。</p>
</div>
<div class="paragraph">
<p>Vert.x 支持 HTTP/1.0、HTTP/1.1 和 HTTP/2 协议。</p>
</div>
<div class="paragraph">
<p>用于 HTTP 的基本 API 对 HTTP/1.x 和 HTTP/2 是相同的，特定的API功能也可用于处理 HTTP/2 协议。</p>
</div>
<div class="sect2">
<h3 id="_创建_http_服务端">创建 HTTP 服务端</h3>
<div class="paragraph">
<p>使用所有默认选项创建 HTTP 服务端的最简单方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var server = vertx.createHttpServer();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_http_服务端">配置 HTTP 服务端</h3>
<div class="paragraph">
<p>若您不想用默认值，可以在创建服务器时传递一个 <code><a href="../dataobjects.html#HttpServerOptions">HttpServerOptions</a></code>
实例给它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "maxWebsocketFrameSize" : 1000000
};

var server = vertx.createHttpServer(options);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_http_2_服务端">配置 HTTP/2 服务端</h3>
<div class="paragraph">
<p>Vert.x支持 TLS <code>h2</code> 和TCP <code>h2c</code> 之上的 HTTP/2 协议。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>h2</code> 表示使用了TLS的应用层协议协商(ALPN)协议来协商的 HTTP/2 协议</p>
</li>
<li>
<p><code>h2c</code> 表示在TCP层上使用明文形式的 HTTP/2 协议，这样的连接是使用 HTTP/1.1升级 请求或者直接建立</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要处理 h2 请求，你必须调用 <code><a href="../dataobjects.html#HttpServerOptions#setUseAlpn">useAlpn</a></code> 方法来启用TLS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "useAlpn" : true,
  "ssl" : true,
  "keyStoreOptions" : {
    "path" : "/path/to/my/keystore"
  }
};

var server = vertx.createHttpServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>ALPN是一个TLS的扩展，它在客户端和服务器开始交换数据之前协商协议。</p>
</div>
<div class="paragraph">
<p>不支持ALPN的客户端仍然可以执行经典的SSL握手。</p>
</div>
<div class="paragraph">
<p>通常情况，ALPN会对 <code>h2</code> 协议达成一致，尽管服务器或客户端决定了仍然使用 HTTP/1.1 协议。</p>
</div>
<div class="paragraph">
<p>要处理 <code>h2c</code> 请求，TLS必须被禁用，服务器将升级到 HTTP/2 以满足任何希望升级到 HTTP/2 的 HTTP/1.1 请求。它还将接受以 <code>PRI*HTTP/2.0\r\nSM\r\n</code> 开始的 <code>h2c</code> 直接连接。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
大多数浏览器不支持 <code>h2c</code> ，所以在建站时，您应该使用 <code>h2</code> 而不是 <code>h2c</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当服务器接受 HTTP/2 连接时， 它会向客户端发送其 <code><a href="../dataobjects.html#HttpServerOptions#getInitialSettings">初始设置</a></code> 。定义客户端如何使用连接，服务器的默认初始设置为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../dataobjects.html#Http2Settings#getMaxConcurrentStreams">getMaxConcurrentStreams</a></code> ：按照 HTTP/2 RFC建议推荐值为 <code>100</code></p>
</li>
<li>
<p>其他默认的 HTTP/2 的设置</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>Worker Verticle 和 HTTP/2 不兼容。</strong>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_记录服务端网络活动">记录服务端网络活动</h3>
<div class="paragraph">
<p>为了进行调试，可记录网络活动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "logActivity" : true
};

var server = vertx.createHttpServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>详细说明请参阅 <a href="#logging_network_activity">记录网络活动</a> 章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_开启服务端监听">开启服务端监听</h3>
<div class="paragraph">
<p>要告诉服务器监听传入的请求，您可以使用其中一个 <code><a href="../../jsdoc/module-vertx-js_http_server-HttpServer.html#listen">listen</a></code>
方法。</p>
</div>
<div class="paragraph">
<p>在配置项中告诉服务器监听指定的主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var server = vertx.createHttpServer();
server.listen();</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在调用 <code>listen</code> 方法时指定主机和端口号，这样就忽略了配置项（中的主机和端口）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var server = vertx.createHttpServer();
server.listen(8080, "myhost.com");</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认主机名是 <code>0.0.0.0</code> ，它表示：监听所有可用地址；默认端口号是 <code>80</code> 。</p>
</div>
<div class="paragraph">
<p>实际的绑定也是异步的，因此服务器也许并没有在调用 <code>listen</code> 方法返回时监听，而是在一段时间过后才监听。</p>
</div>
<div class="paragraph">
<p>若您希望在服务器实际监听时收到通知，您可以向 <code>listen</code> 提供一个处理器。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var server = vertx.createHttpServer();
server.listen(8080, "myhost.com", function (res, res_err) {
  if (res_err == null) {
    console.log("Server is now listening!");
  } else {
    console.log("Failed to bind!");
  }
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_收到传入请求的通知">收到传入请求的通知</h3>
<div class="paragraph">
<p>若您需要在收到请求时收到通知，则需要设置一个 <code><a href="../../jsdoc/module-vertx-js_http_server-HttpServer.html#requestHandler">requestHandler</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var server = vertx.createHttpServer();
server.requestHandler(function (request) {
  // Handle the request in here
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理请求">处理请求</h3>
<div class="paragraph">
<p>当请求到达时，Vert.x 会像对应的处理函数传入一个 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html">HttpServerRequest</a></code> 实例并调用请求处理函数，此对象表示服务端 HTTP 请求。</p>
</div>
<div class="paragraph">
<p>当请求的头信息被完全读取时会调用该请求处理器。</p>
</div>
<div class="paragraph">
<p>如果请求包含请求体，那么该请求体将在请求处理器被调用后的某个时间到达服务器。</p>
</div>
<div class="paragraph">
<p>服务请求对象允许您检索 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#uri">uri</a></code> ,
<code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#path">path</a></code> , <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#params">params</a></code> 和
<code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#headers">headers</a></code> 等其他信息。</p>
</div>
<div class="paragraph">
<p>每一个服务请求对象和一个服务响应对象绑定，您可以用
<code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#response">response</a></code> 方法获取一个 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html">HttpServerResponse</a></code>
对象的引用。</p>
</div>
<div class="paragraph">
<p>这是服务器处理请求并回复 “hello world” 的简单示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">vertx.createHttpServer().requestHandler(function (request) {
  request.response().end("Hello world");
}).listen(8080);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_请求版本">请求版本</h4>
<div class="paragraph">
<p>在请求中指定的 HTTP 版本可通过 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#version">version</a></code> 方法获取。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求方法">请求方法</h4>
<div class="paragraph">
<p>使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#method">method</a></code> 方法读取请求中的 HTTP Method（即GET、POST、PUT、DELETE、HEAD、OPTIONS等）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求uri">请求URI</h4>
<div class="paragraph">
<p>使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#uri">uri</a></code> 方法读取请求中的URI路径。</p>
</div>
<div class="paragraph">
<p>请注意，这是在HTTP 请求中传递的实际URI，它总是一个相对的URI。</p>
</div>
<div class="paragraph">
<p>这个URI是在 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">Section 5.1.2 of the HTTP specification - Request-URI</a> 中定义的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求路径">请求路径</h4>
<div class="paragraph">
<p>使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#path">path</a></code> 方法读取URI中的路径部分。</p>
</div>
<div class="paragraph">
<p>例如，请求的URI为：</p>
</div>
<div class="paragraph">
<p>a/b/c/page.html?param1=abc&amp;param2=xyz</p>
</div>
<div class="paragraph">
<p>路径部分应该是：</p>
</div>
<div class="paragraph">
<p>/a/b/c/page.html</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求查询">请求查询</h4>
<div class="paragraph">
<p>使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#query">query</a></code> 读取URI中的查询部分。</p>
</div>
<div class="paragraph">
<p>例如，请求的URI为：</p>
</div>
<div class="paragraph">
<p>a/b/c/page.html?param1=abc&amp;param2=xyz</p>
</div>
<div class="paragraph">
<p>查询部分应该是：</p>
</div>
<div class="paragraph">
<p>param1=abc&amp;param2=xyz</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求头部">请求头部</h4>
<div class="paragraph">
<p>使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#headers">headers</a></code> 方法获取HTTP 请求中的请求头部信息。</p>
</div>
<div class="paragraph">
<p>这个方法返回一个 <code><a href="../../jsdoc/module-vertx-js_multi_map-MultiMap.html">MultiMap</a></code>  实例。它像一个普通的Map或Hash，并且它还允许同一个键支持多个值 —— 因为HTTP允许同一个键支持多个请求头的值。</p>
</div>
<div class="paragraph">
<p>它的键值不区分大小写，这意味着您可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var headers = request.headers();

// Get the User-Agent:
console.log("User agent is " + headers.get("user-agent"));

// You can also do this and get the same result:
console.log("User agent is " + headers.get("User-Agent"));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_请求主机">请求主机</h4>
<div class="paragraph">
<p>使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#host">host</a></code> 方法返回 HTTP 请求中的主机名。</p>
</div>
<div class="paragraph">
<p>对于 HTTP/1.x 请求返回请求头中的 <code>host</code> 值，对于 HTTP/1 请求则返回伪头中的 <code>:authority</code> 的值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求参数">请求参数</h4>
<div class="paragraph">
<p>您可以使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#params">params</a></code> 方法返回HTTP请求中的参数信息。</p>
</div>
<div class="paragraph">
<p>像 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#headers">headers</a></code> 方法一样它也会返回一个 <code><a href="../../jsdoc/module-vertx-js_multi_map-MultiMap.html">MultiMap</a></code> 实例，因为可以有多个具有相同名称的参数。</p>
</div>
<div class="paragraph">
<p>请求参数在请求URI的 path 部分之后，例如URI是：</p>
</div>
<div class="paragraph">
<p>/page.html?param1=abc&amp;param2=xyz</p>
</div>
<div class="paragraph">
<p>那么参数将包含以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>param1: 'abc'
param2: 'xyz</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这些请求参数是从请求的 URI 中解析读取的，若您已经将表单属性存放在请求体中发送出去，并且该请求为 <code>multi-part/form-data</code> 类型请求，那么它们将不会显示在此处的参数中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_远程地址">远程地址</h4>
<div class="paragraph">
<p>可以使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#remoteAddress">remoteAddress</a></code> 方法读取请求发送者的地址。</p>
</div>
</div>
<div class="sect3">
<h4 id="_绝对uri">绝对URI</h4>
<div class="paragraph">
<p>HTTP 请求中传递的URI通常是相对的，若您想要读取请求中和相对URI对应的绝对URI，可调用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#absoluteURI">absoluteURI</a></code> 方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_结束处理器">结束处理器</h4>
<div class="paragraph">
<p>当整个请求（包括任何正文）已经被完全读取时，请求中的 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#endHandler">endHandler</a></code> 方法会被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求体中读取数据">请求体中读取数据</h4>
<div class="paragraph">
<p>HTTP请求通常包含我们需要读取的主体。如前所述，当请求头部达到时，请求处理器会被调用，因此请求对象在此时没有请求体。</p>
</div>
<div class="paragraph">
<p>这是因为请求体可能非常大（如文件上传），并且我们不会在内容发送给您之前将其全部缓冲存储在内存中，这可能会导致服务器耗尽可用内存。</p>
</div>
<div class="paragraph">
<p>要接收请求体，您可在请求中调用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#handler">handler</a></code> 方法设置一个处理器，每次请求体的一小块数据收到时，该处理器都会被调用。以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.handler(function (buffer) {
  console.log("I have received a chunk of the body of length " + buffer.length());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递给处理器的对象是一个 <code><a href="../../jsdoc/module-vertx-js_buffer-Buffer.html">Buffer</a></code> ，当数据从网络到达时，处理器可以多次被调用，这取决于请求体的大小。</p>
</div>
<div class="paragraph">
<p>在某些情况下（例：若请求体很小），您将需要将这个请求体聚合到内存中，以便您可以按照下边的方式进行聚合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");

// Create an empty buffer
var totalBuffer = Buffer.buffer();

request.handler(function (buffer) {
  console.log("I have received a chunk of the body of length " + buffer.length());
  totalBuffer.appendBuffer(buffer);
});

request.endHandler(function (v) {
  console.log("Full body received, length = " + totalBuffer.length());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个常见的情况，Vert.x为您提供了一个 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#bodyHandler">bodyHandler</a></code> 方法来执行此操作。当所有请求体被收到时， <code>bodyHandler</code> 绑定的处理器会被调用一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.bodyHandler(function (totalBuffer) {
  console.log("Full body received, length = " + totalBuffer.length());
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pumping_请求">Pumping 请求</h4>
<div class="paragraph">
<p>请求对象实现了 <code><a href="../../jsdoc/module-vertx-js_read_stream-ReadStream.html">ReadStream</a></code> 接口，因此您可以将请求体读取到任何
<code><a href="../../jsdoc/module-vertx-js_write_stream-WriteStream.html">WriteStream</a></code>  实例中。</p>
</div>
<div class="paragraph">
<p>详细请参阅 <a href="#streams">流和管道</a> 章节。</p>
</div>
</div>
<div class="sect3">
<h4 id="_处理_html_表单">处理 HTML 表单</h4>
<div class="paragraph">
<p>您可使用 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 这两种 <strong>content-type</strong> 来提交 HTML 表单。</p>
</div>
<div class="paragraph">
<p>对于使用 URL 编码过的表单，表单属性会被编码在URL中，如同普通查询参数一样。</p>
</div>
<div class="paragraph">
<p>对于 multipart 类型的表单，它会被编码在请求体中，而且在整个请求体被完全读取之前它是不可用的。Multipart 表单还可以包含文件上传。</p>
</div>
<div class="paragraph">
<p>Multipart 表单还可以包含文件上传。</p>
</div>
<div class="paragraph">
<p>若您想要读取 multipart 表单的属性，您应该告诉 Vert.x 您会在读取任何正文 <strong>之前</strong> 调用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#setExpectMultipart">setExpectMultipart</a></code>
方法，然后在整个请求体都被读取后，您可以使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#formAttributes">formAttributes</a></code>
方法来读取实际的表单属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">server.requestHandler(function (request) {
  request.setExpectMultipart(true);
  request.endHandler(function (v) {
    // The body has now been fully read, so retrieve the form attributes
    var formAttributes = request.formAttributes();
  });
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_处理文件上传">处理文件上传</h4>
<div class="paragraph">
<p>Vert.x 可以处理以 multipart 编码形式上传的的文件。</p>
</div>
<div class="paragraph">
<p>要接收文件，您可以告诉 Vert.x 使用 multipart 表单，并对请求设置
<code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#uploadHandler">uploadHandler</a></code> 。</p>
</div>
<div class="paragraph">
<p>当服务器每次接收到上传请求时，该处理器将被调用一次。</p>
</div>
<div class="paragraph">
<p>传递给处理器的对象是一个 <code><a href="../../jsdoc/module-vertx-js_http_server_file_upload-HttpServerFileUpload.html">HttpServerFileUpload</a></code> 实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">server.requestHandler(function (request) {
  request.setExpectMultipart(true);
  request.uploadHandler(function (upload) {
    console.log("Got a file upload " + upload.name());
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上传的文件可能很大，我们不会在单个缓冲区中包含整个上传的数据，因为这样会导致内存耗尽。相反，上传数据是以块的形式被接收的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.uploadHandler(function (upload) {
  upload.handler(function (chunk) {
    console.log("Received a chunk of the upload of length " + chunk.length());
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上传对象实现了 <code><a href="../../jsdoc/module-vertx-js_read_stream-ReadStream.html">ReadStream</a></code> 接口，因此您可以将请求体读取到任何
<code><a href="../../jsdoc/module-vertx-js_write_stream-WriteStream.html">WriteStream</a></code> 实例中。详细说明请参阅 <a href="#streams">流和管道（泵）</a> 章节。</p>
</div>
<div class="paragraph">
<p>若您只是想将文件上传到服务器的某个磁盘，可以使用 <code><a href="../../jsdoc/module-vertx-js_http_server_file_upload-HttpServerFileUpload.html#streamToFileSystem">streamToFileSystem</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.uploadHandler(function (upload) {
  upload.streamToFileSystem("myuploads_directory/" + upload.filename());
});</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
确保您检查了生产系统的文件名，以避免恶意客户将文件上传到文件系统中的任意位置。有关详细信息，参阅 <a href="#Security notes">安全说明</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_处理压缩体">处理压缩体</h4>
<div class="paragraph">
<p>Vert.x 可以处理在客户端通过 <strong>deflate</strong> 或 <strong>gzip</strong> 算法压缩过的请求体信息。</p>
</div>
<div class="paragraph">
<p>若要启用解压缩功能则您要在创建服务器时调用 <code><a href="../dataobjects.html#HttpServerOptions#setDecompressionSupported">decompressionSupported</a></code> 方法设置配置项。</p>
</div>
<div class="paragraph">
<p>默认情况下解压缩是被禁用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接收自定义_http_2_帧">接收自定义 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的包含各种帧的一种帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>若要接收自定义帧(frame)，您可以在请求中使用 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#customFrameHandler">customFrameHandler</a></code> ，每次当自定义的帧数据到达时，这个处理器会被调用。这而是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.customFrameHandler(function (frame) {

  console.log("Received a frame type=" + frame.type() + " payload" + frame.payload().toString());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2 帧不受流量控制限制 —— 当接收到自定义帧时，不论请求是否暂停，自定义帧处理器都将立即被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_非标准的_http_方法">非标准的 HTTP 方法</h4>
<div class="paragraph">
<p><code><a href="todo">OTHER</a></code> HTTP 方法可用于非标准方法，在这种情况下，
<code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#rawMethod">rawMethod</a></code> 方法返回客户端发送的实际 HTTP 方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_发回响应">发回响应</h3>
<div class="paragraph">
<p>服务器响应对象是一个 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html">HttpServerResponse</a></code> 实例，它可以从 <code>request</code> 对应的
<code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#response">response</a></code> 方法中读取。</p>
</div>
<div class="paragraph">
<p>您可以使用响应对象回写一个响应到 HTTP客户端。</p>
</div>
<div class="sect3">
<h4 id="_设置状态码和消息">设置状态码和消息</h4>
<div class="paragraph">
<p>默认的 HTTP 状态响应码为 <code>200</code> ，表示 <code>OK</code> 。</p>
</div>
<div class="paragraph">
<p>可使用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#setStatusCode">setStatusCode</a></code> 方法设置不同状态代码。</p>
</div>
<div class="paragraph">
<p>您还可用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#setStatusMessage">setStatusMessage</a></code> 方法指定自定义状态消息。</p>
</div>
<div class="paragraph">
<p>若您不指定状态信息，将会使用默认的状态码响应。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
对于 HTTP/2 中的状态不会在响应中描述 —— 因为协议不会将消息发送回客户端。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_向_http_响应写入数据">向 HTTP 响应写入数据</h4>
<div class="paragraph">
<p>想要将数据写入 HTTP Response，您可使用任意一个 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#write">write</a></code> 方法。</p>
</div>
<div class="paragraph">
<p>它们可以在响应结束之前被多次调用，它们可以通过以下几种方式调用：</p>
</div>
<div class="paragraph">
<p>对用单个缓冲区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.write(buffer);</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入字符串，这种请求字符串将使用 UTF-8 进行编码，并将结果写入到报文中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.write("hello world!");</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入带编码方式的字符串，这种情况字符串将使用指定的编码方式编码，并将结果写入到报文中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.write("hello world!", "UTF-16");</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应写入是异步的，并且在写操作进入队列之后会立即返回。</p>
</div>
<div class="paragraph">
<p>若您只需要将单个字符串或 <code>Buffer</code> 写入到HTTP 响应，则可使用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#end">end</a></code> 方法将其直接写入响应中并发回到客户端。</p>
</div>
<div class="paragraph">
<p>第一次写入操作会触发响应头的写入，因此，若您不使用HTTP 分块，那么必须在写入响应之前设置 <code>Content-Length</code> 头，否则会太迟。若您使用 HTTP 分块则不需要担心这点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_完成_http_响应">完成 HTTP 响应</h4>
<div class="paragraph">
<p>一旦您完成了 HTTP 响应，可调用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#end">end</a></code> 将其发回客户端。</p>
</div>
<div class="paragraph">
<p>这可以通过几种方式完成：</p>
</div>
<div class="paragraph">
<p>没有参数，直接结束响应，发回客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.write("hello world!");
response.end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以和调用 <code>write</code> 方法一样传 <code>String</code> 或 <code>Buffer</code> 给 <code>end</code> 方法。这种情况，它和先调用带 <code>String</code> 或 <code>Buffer</code> 参数的 <code>write</code> 方法，之后调用无参 <code>end</code> 方法一样。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.end("hello world!");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_关闭底层连接">关闭底层连接</h4>
<div class="paragraph">
<p>您可以调用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#close">close</a></code> 方法关闭底层的TCP 连接。</p>
</div>
<div class="paragraph">
<p>当响应结束时，Vert.x 将自动关闭非 keep-alive 的连接。</p>
</div>
<div class="paragraph">
<p>默认情况下，Vert.x 不会自动关闭 keep-alive 的连接，若您想要在一段空闲时间之后让 Vert.x 自动关闭 keep-alive 的连接，则使用 <code><a href="../dataobjects.html#HttpServerOptions#setIdleTimeout">idleTimeout</a></code> 方法进行配置。</p>
</div>
<div class="paragraph">
<p>HTTP/2 连接在关闭响应之前会发送 <code>GOAWAY</code> 帧。</p>
</div>
</div>
<div class="sect3">
<h4 id="_设置响应头">设置响应头</h4>
<div class="paragraph">
<p>HTTP 响应头可直接添加到 HTTP 响应中，通常直接操作
<code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#headers">headers</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
var headers = response.headers();
headers.set("content-type", "text/html");
headers.set("other-header", "wibble");</code></pre>
</div>
</div>
<div class="paragraph">
<p>或您可使用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#putHeader">putHeader</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.putHeader("content-type", "text/html").putHeader("other-header", "wibble");</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应头必须在写入响应正文消息之前进行设置。</p>
</div>
</div>
<div class="sect3">
<h4 id="_分块_http_响应和附加尾部">分块 HTTP 响应和附加尾部</h4>
<div class="paragraph">
<p>Vert.x 支持 <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">分块传输编码(HTTP Chunked Transfer Encoding)</a>.</p>
</div>
<div class="paragraph">
<p>这允许HTTP 响应体以块的形式写入，通常在响应体预先不知道尺寸、需要将很大响应正文以流式传输到客户端时使用。</p>
</div>
<div class="paragraph">
<p>您可以通过如下方式开启分块模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.setChunked(true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认是不分块的，当处于分块模式，每次调用任意一个 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#write">write</a></code>
方法将导致新的 HTTP 块被写出。</p>
</div>
<div class="paragraph">
<p>在分块模式下，您还可以将响应的HTTP 响应附加尾部(trailers)写入响应，这种方式实际上是在写入响应的最后一块。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
分块响应在 HTTP/2 流中无效。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>若要向响应添加尾部，则直接添加到 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#trailers">trailers</a></code> 里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.setChunked(true);
var trailers = response.trailers();
trailers.set("X-wibble", "woobble").set("X-quux", "flooble");</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者调用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#putTrailer">putTrailer</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();
response.setChunked(true);
response.putTrailer("X-wibble", "woobble").putTrailer("X-quux", "flooble");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_直接从磁盘或_classpath_读文件">直接从磁盘或 Classpath 读文件</h4>
<div class="paragraph">
<p>若您正在编写一个Web 服务端，一种从磁盘中读取并提供文件的方法是将文件作为 <code><a href="../../jsdoc/module-vertx-js_async_file-AsyncFile.html">AsyncFile</a></code>
对象打开并其传送到HTTP 响应中。</p>
</div>
<div class="paragraph">
<p>或您可以使用 <code><a href="../../jsdoc/module-vertx-js_file_system-FileSystem.html#readFile">readFile</a></code> 方法一次性加载它，并直接将其写入响应。</p>
</div>
<div class="paragraph">
<p>或者，Vert.x 提供了一种方法，允许您在一个操作中将文件从磁盘或文件系统中读取并提供给HTTP 响应。若底层操作系统支持，这会导致操作系统不通过用户空间复制而直接将文件内容中字节数据从文件传输到Socket。</p>
</div>
<div class="paragraph">
<p>这是使用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#sendFile">sendFile</a></code> 方法完成的，对于大文件处理通常更有效，而这个方法对于小文件可能很慢。</p>
</div>
<div class="paragraph">
<p>这儿是一个非常简单的 Web 服务器，它使用 <code>sendFile</code> 方法从文件系统中读取并提供文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">vertx.createHttpServer().requestHandler(function (request) {
  var file = "";
  if (request.path() == "/") {
    file = "index.html";
  } else if (!request.path().contains("..")) {
    file = request.path();
  }
  request.response().sendFile("web/" + file);
}).listen(8080);</code></pre>
</div>
</div>
<div class="paragraph">
<p>发送文件是异步的，可能在调用返回一段时间后才能完成。如果要在文件写入时收到通知，可以在 <code>sendFile</code> 方法中设置一个处理器。 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#sendFile">sendFile</a></code></p>
</div>
<div class="paragraph">
<p>请阅读 <a href="#classpath">从 Classpath 访问文件</a> 章节了解类路径的限制或禁用它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
若在 HTTPS 协议中使用 <code>sendFile</code> 方法，它将会通过用户空间进行复制，因为若内核将数据直接从磁盘复制到 Socket，则不会给我们任何加密的机会。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
若您要直接使用 Vert.x 编写 Web 服务器，请注意，您想提供文件和类路径之外访问的位置 —— 用户是无法直接利用路径访问的。更安全的做法是使用Vert.x Web替代。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当需要提供文件的一部分，从给定的字节开始，您可以像下边这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">vertx.createHttpServer().requestHandler(function (request) {
  var offset = 0;
  try {
    offset = Java.type("java.lang.Long").parseLong(request.getParam("start"));
  } catch(err) {
    // error handling...
  }


  var end = Java.type("java.lang.Long").MAX_VALUE;
  try {
    end = Java.type("java.lang.Long").parseLong(request.getParam("end"));
  } catch(err) {
    // error handling...
  }


  request.response().sendFile("web/mybigfile.txt", offset, end);
}).listen(8080);</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您想要从偏移量开始发送文件直到尾部，则不需要提供长度信息，这种情况下，您可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">vertx.createHttpServer().requestHandler(function (request) {
  var offset = 0;
  try {
    offset = Java.type("java.lang.Long").parseLong(request.getParam("start"));
  } catch(err) {
    // error handling...
  }


  request.response().sendFile("web/mybigfile.txt", offset);
}).listen(8080);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pumping_响应">Pumping 响应</h4>
<div class="paragraph">
<p>服务端响应 <code>HttpServerResponse</code> 也是一个 <code><a href="../../jsdoc/module-vertx-js_write_stream-WriteStream.html">WriteStream</a></code> 实例，因此您可以从任何
<code><a href="../../jsdoc/module-vertx-js_read_stream-ReadStream.html">ReadStream</a></code> 向其泵送数据，如 <code><a href="../../jsdoc/module-vertx-js_async_file-AsyncFile.html">AsyncFile</a></code> , <code><a href="../../jsdoc/module-vertx-js_net_socket-NetSocket.html">NetSocket</a></code> ,
<code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html">WebSocket</a></code> 或 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html">HttpServerRequest</a></code> 。</p>
</div>
<div class="paragraph">
<p>这儿有一个例子，它回应了任何 PUT 方法的响应中的请求体，它为请求体使用了 Pump，所以即使 HTTP 请求体很大并填满了内存，任何时候它依旧会工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Pump = require("vertx-js/pump");
vertx.createHttpServer().requestHandler(function (request) {
  var response = request.response();
  if (request.method() === 'PUT') {
    response.setChunked(true);
    Pump.pump(request, response).start();
    request.endHandler(function (v) {
      response.end();
    });
  } else {
    response.setStatusCode(400).end();
  }
}).listen(8080);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_写入_http_2_帧">写入 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的包含各种帧的一种帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>要发送这样的帧，您可以在响应中使用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#writeCustomFrame">writeCustomFrame</a></code> 方法，以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");

var frameType = 40;
var frameStatus = 10;
var payload = Buffer.buffer("some data");

// Sending a frame to the client
response.writeCustomFrame(frameType, frameStatus, payload);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些帧被立即发送，并且不受流程控制的影响——当这样的帧被发送到那里时，可以在其他的 {@literal DATA} 帧之前完成。</p>
</div>
</div>
<div class="sect3">
<h4 id="_流重置">流重置</h4>
<div class="paragraph">
<p>HTTP/1.x 不允许请求或响应流执行清除重置，如当客户端上传的资源已经存在于服务器上，服务器就需要接受整个响应。</p>
</div>
<div class="paragraph">
<p>HTTP/2 在请求/响应期间随时支持流重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// Reset the stream
request.response().reset();</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认的 <code>NO_ERROR(0)</code> 错误代码会发送，您也可以发送另外一个错误代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// Cancel the stream
request.response().reset(8);</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2 规范中定义了可用的 <a href="http://httpwg.org/specs/rfc7540.html#ErrorCodes">错误码</a> 列表：</p>
</div>
<div class="paragraph">
<p>若使用了 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#exceptionHandler">request handler</a></code> 和
<code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#exceptionHandler">response handler</a></code> 两个处理器过后，在流重置完成时您将会收到通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.response().exceptionHandler(function (err) {
  if (err.getClass().getSimpleName() == 'StreamResetException') {
    var reset = err;
    console.log("Stream reset " + reset.getCode());
  }
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_服务器推送">服务器推送</h4>
<div class="paragraph">
<p>服务器推送(Server Push)是 HTTP/2 支持的一个新功能，可以为单个客户端请求并行发送多个响应。</p>
</div>
<div class="paragraph">
<p>当服务器处理请求时，它可以向客户端推送请求/响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var response = request.response();

// Push main.js to the client
response.push('GET', "/main.js", function (ar, ar_err) {

  if (ar_err == null) {

    // The server is ready to push the response
    var pushedResponse = ar;

    // Send main.js response
    pushedResponse.putHeader("content-type", "application/json").end("alert(\"Push response hello\")");
  } else {
    console.log("Could not push client resource " + ar_err);
  }
});

// Send the requested resource
response.sendFile("&lt;html&gt;&lt;head&gt;&lt;script src=\"/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;");</code></pre>
</div>
</div>
<div class="paragraph">
<p>当服务器准备推送响应时，推送响应处理器会被调用，并会发送响应。</p>
</div>
<div class="paragraph">
<p>推送响应处理器客户能会接收到失败，如：客户端可能取消推送，因为它已经在缓存中包含了 <code>main.js</code> ，并不在需要它。</p>
</div>
<div class="paragraph">
<p>您必须在响应结束之前调用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#push">push</a></code> 方法，但是在推送响应过后依然可以写响应。</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions">Handling exceptions</h4>
<div class="paragraph">
<p>You can set an <code><a href="../../jsdoc/module-vertx-js_http_server-HttpServer.html#exceptionHandler">exceptionHandler</a></code> to receive any
exceptions that happens before the connection is passed to the <code><a href="../../jsdoc/module-vertx-js_http_server-HttpServer.html#requestHandler">requestHandler</a></code>
or to the <code><a href="../../jsdoc/module-vertx-js_http_server-HttpServer.html#websocketHandler">websocketHandler</a></code> , e.g during the TLS handshake.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http_压缩">HTTP 压缩</h3>
<div class="paragraph">
<p>Vert.x 支持 HTTP 压缩。</p>
</div>
<div class="paragraph">
<p>这意味着在响应发送回客户端之前，您可以将响应体自动压缩。</p>
</div>
<div class="paragraph">
<p>若客户端不支持HTTP 压缩，则它可以发回没有压缩过的请求。</p>
</div>
<div class="paragraph">
<p>这允许它同时处理支持HTTP 压缩的客户端和不支持的客户端。</p>
</div>
<div class="paragraph">
<p>要启用压缩，可以使用 <code><a href="../dataobjects.html#HttpServerOptions#setCompressionSupported">compressionSupported</a></code> 方法进行配置。默认情况下，未启用压缩。</p>
</div>
<div class="paragraph">
<p>默认情况下，未启用压缩。</p>
</div>
<div class="paragraph">
<p>当启用HTTP 压缩时，服务器将检查客户端请求头中是否包含了 <code>Accept-Encoding</code> 并支持常用的 deflate 和 gzip 压缩算法。Vert.x 两者都支持。</p>
</div>
<div class="paragraph">
<p>若找到这样的请求头，服务器将使用所支持的压缩算法之一自动压缩响应正文并发送回客户端。</p>
</div>
<div class="paragraph">
<p>Whenever the response needs to be sent without compression you can set the header <code>content-encoding</code> to <code>identity</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// Disable compression and send an image
request.response().putHeader(Java.type("io.vertx.core.http.HttpHeaders").CONTENT_ENCODING, Java.type("io.vertx.core.http.HttpHeaders").IDENTITY).sendFile("/path/to/image.jpg");</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：压缩可以减少网络流量，但是CPU密集度会更高。</p>
</div>
<div class="paragraph">
<p>为了解决后边一个问题，Vert.x也允许您调整原始的 gzip/deflate 压缩算法的 “压缩级别” 参数</p>
</div>
<div class="paragraph">
<p>压缩级别允许根据所得数据的压缩比和压缩/解压的计算成本来配置 gzip/deflate 算法。</p>
</div>
<div class="paragraph">
<p>压缩级别是从 1 到 9 的整数值，其中 1 表示更低的压缩比但是最快的算法，9 表示可用的最大压缩比但比较慢的算法。</p>
</div>
<div class="paragraph">
<p>使用高于 1-2 的压缩级别通常允许仅仅保存一些字节大小 —— 它的增益不是线性的，并取决于要压缩的特定数据 —— 但它可以满足服务器所要求的CPU周期的不可控的成本（注意现在Vert.x不支持任何缓存形式的响应数据，如静态文件，因此压缩是在每个请求体生成时进行的）,它可生成压缩过的响应数据、并对接收的响应解码（膨胀）—— 和客户端使用的方式一致，这种操作随着压缩级别的增长会变得更加倾向于CPU密集型。</p>
</div>
<div class="paragraph">
<p>默认情况下 —— 如果通过 <code><a href="../dataobjects.html#HttpServerOptions#setCompressionSupported">compressionSupported</a></code> 方法启用压缩，Vert.x 将使用 <strong>6</strong> 作为压缩级别，但是该参数可通过 <code><a href="../dataobjects.html#HttpServerOptions#setCompressionLevel">compressionLevel</a></code> 方法来更改。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建_http_客户端">创建 HTTP 客户端</h3>
<div class="paragraph">
<p>您可通过以下方式创建一个具有默认配置的 <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html">HttpClient</a></code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var client = vertx.createHttpClient();</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您想要配置客户端选项，可按以下方式创建：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "keepAlive" : false
};
var client = vertx.createHttpClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x 支持基于 TLS <code>h2</code> 和 TCP <code>h2c</code> 的 HTTP/2 协议。</p>
</div>
<div class="paragraph">
<p>默认情况下，HTTP 客户端会发送 HTTP/1.1 请求。若要执行 HTTP/2 请求，则必须调用 <code><a href="../dataobjects.html#HttpClientOptions#setProtocolVersion">protocolVersion</a></code>
方法将版本设置成 <code><a href="todo">HTTP_2</a></code> 。</p>
</div>
<div class="paragraph">
<p>对于 <code>h2</code> 请求，必须使用应用层协议协商(ALPN)启用TLS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "protocolVersion" : "HTTP_2",
  "ssl" : true,
  "useAlpn" : true,
  "trustAll" : true
};

var client = vertx.createHttpClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 <code>h2c</code> 请求，TLS必须禁用，客户端将执行 HTTP/1.1 请求并尝试升级到 HTTP/2：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "protocolVersion" : "HTTP_2"
};

var client = vertx.createHttpClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>h2c</code> 连接也可以直接建立，如连接可以使用前文提到的方式创建，当
<code><a href="../dataobjects.html#HttpClientOptions#setHttp2ClearTextUpgrade">http2ClearTextUpgrade</a></code> 选项设置为 <code>false</code> 时：建立连接后，客户端将发送 HTTP/2 连接前缀，并期望从服务端接收相同的连接偏好。</p>
</div>
<div class="paragraph">
<p>HTTP 服务端可能不支持 HTTP/2，当响应到达时，可以使用 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#version">version</a></code> 方法检查响应实际HTTP版本。</p>
</div>
<div class="paragraph">
<p>当客户端连接到 HTTP/2 服务端时，它将向服务端发送其 <code><a href="../dataobjects.html#HttpClientOptions#getInitialSettings">初始设置</a></code>.
。设置定义服务器如何使用连接、客户端的默认初始设置是由 HTTP/2 RFC定义的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_记录客户端网络活动">记录客户端网络活动</h3>
<div class="paragraph">
<p>为了进行调试，可以记录网络活动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "logActivity" : true
};
var client = vertx.createHttpClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>详情请参阅 <a href="#logging_network_activity">记录网络活动</a> 章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_发出请求">发出请求</h3>
<div class="paragraph">
<p>HTTP 客户端是很灵活的，您可以通过各种方式发出请求。</p>
</div>
<div class="paragraph">
<p>通常您希望使用 HTTP 客户端向同一个主机/端口发送很多请求。为避免每次发送请求时重复设主机/端口，您可以为客户端配置默认主机/端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// Set the default host
var options = {
  "defaultHost" : "wibble.com"
};
// Can also set default port if you want...
var client = vertx.createHttpClient(options);
client.getNow("/some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您发现自己使用相同的客户端向不同主机的主机/端口发送大量请求，则可以在发出请求时简单指定主机/端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var client = vertx.createHttpClient();

// Specify both port and host name
client.getNow(8080, "myserver.mycompany.com", "/some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});

// This time use the default port 80 but specify the host name
client.getNow("foo.othercompany.com", "/other-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>用客户端发出请求的所有不同方式都支持这两种指定主机/端口的方法。</p>
</div>
<div class="sect3">
<h4 id="_无请求体的简单请求">无请求体的简单请求</h4>
<div class="paragraph">
<p>通常，您想发出没有请求体的HTTP 请求，这种情况通常如HTTP GET、OPTIONS 和 HEAD 请求。</p>
</div>
<div class="paragraph">
<p>使用 Vert.x HTTP Client 执行这种请求最简单的方式是使用加了 <code>Now</code> 后缀的请求方法，如
<code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html#getNow">getNow</a></code> 。</p>
</div>
<div class="paragraph">
<p>这些方法会创建HTTP 请求，并在单个方法调用中发送它，而且允许您提供一个处理器，当HTTP 响应发送回来时调用该处理器来处理响应结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var client = vertx.createHttpClient();

// Send a GET request
client.getNow("/some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});

// Send a GET request
client.headNow("/other-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_发送通用请求">发送通用请求</h4>
<div class="paragraph">
<p>有时您在运行时不知道发送请求的 HTTP 方法，对于这种情况，我们提供通用请求方法 <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html#request">request</a></code> ，允许您在运行时指定 HTTP 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var client = vertx.createHttpClient();

client.request('GET', "some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
}).end();

client.request('POST', "foo-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
}).end("some-data");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_写请求体">写请求体</h4>
<div class="paragraph">
<p>有时您想要发送一个包含了请求体的请求，或者也许您想要在发送请求之前写入头部到请求中。</p>
</div>
<div class="paragraph">
<p>为此，您可以调用其中一个指定的请求方法，如 <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html#post">post</a></code> 或一个其他通用请求方法，如 <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html#request">request</a></code> 。</p>
</div>
<div class="paragraph">
<p>这些方法都不会立即发送请求，而是返回一个 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html">HttpClientRequest</a></code>
实例，它可以用来写数据到请求体和请求头。</p>
</div>
<div class="paragraph">
<p>这儿有一些写入请求体的 POST 请求例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var client = vertx.createHttpClient();

var request = client.post("some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});

// Now do stuff with the request
request.putHeader("content-length", "1000");
request.putHeader("content-type", "text/plain");
request.write(body);

// Make sure the request is ended when you're done with it
request.end();

// Or fluently:

client.post("some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
}).putHeader("content-length", "1000").putHeader("content-type", "text/plain").write(body).end();

// Or event more simply:

client.post("some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
}).putHeader("content-type", "text/plain").end(body);</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以用UTF-8编码方式编码字符串和以指定方式编码编码字符串、或写 <code>Buffer</code> 的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");

// Write string encoded in UTF-8
request.write("some data");

// Write string encoded in specific encoding
request.write("some other data", "UTF-16");

// Write a buffer
var buffer = Buffer.buffer();
buffer.appendInt(123).appendLong(245);
request.write(buffer);</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您仅需要写单个字符串或 <code>Buffer</code> 到HTTP请求中，您可以直接调用 <code>end</code> 函数完成写入和请求的发送操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");

// Write string and end the request (send it) in a single call
request.end("some simple data");

// Write buffer and end the request (send it) in a single call
var buffer = Buffer.buffer().appendDouble(12.34).appendLong(432);
request.end(buffer);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您写入请求时，第一次调用 <code>write</code> 方法将先将请求头写入到请求报文中。</p>
</div>
<div class="paragraph">
<p>实际写入操作是异步的，它可能在调用返回一段时间后才发生。</p>
</div>
<div class="paragraph">
<p>带请求体的非分块 HTTP 请求需要提供 <code>Content-Length</code> 头。</p>
</div>
<div class="paragraph">
<p>因此，若您不使用 HTTP 分块，则必须在写入请求之前设置 <code>Content-Length</code> 头，否则会出错。</p>
</div>
<div class="paragraph">
<p>若您在调用其中一个 <code>end</code> 方法处理 String 或 Buffer，在写入请求体之前，Vert.x 将自动计算并设置 <code>Content-Length</code> 。</p>
</div>
<div class="paragraph">
<p>若您在使用HTTP 分块模式，则不需要 <code>Content-Length</code> 头，因此您不必先计算大小。</p>
</div>
</div>
<div class="sect3">
<h4 id="_写请求头">写请求头</h4>
<div class="paragraph">
<p>您可以直接使用 MultiMap 结构的 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#headers">headers</a></code> 来设置请求头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// Write some headers using the headers() multimap

var headers = request.headers();
headers.set("content-type", "application/json").set("other-header", "foo");</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个headers是一个 <code><a href="../../jsdoc/module-vertx-js_multi_map-MultiMap.html">MultiMap</a></code> 的实例，它提供了添加、设置、删除条目的操作。HTTP Header允许一个特定的键包含多个值。</p>
</div>
<div class="paragraph">
<p>您也可以使用 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#putHeader">putHeader</a></code> 方法编写头文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// Write some headers using the putHeader method

request.putHeader("content-type", "application/json").putHeader("other-header", "foo");</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您想写入请求头，则您必须在写入任何请求体之前这样做来设置请求头。</p>
</div>
</div>
<div class="sect3">
<h4 id="_非标准的http_方法">非标准的HTTP 方法</h4>
<div class="paragraph">
<p>The <code><a href="todo">OTHER</a></code> HTTP method is used for non standard methods, when this method
is used, <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#setRawMethod">setRawMethod</a></code> must be used to
set the raw method to send to the server.</p>
</div>
</div>
<div class="sect3">
<h4 id="_发送_http_请求">发送 HTTP 请求</h4>
<div class="paragraph">
<p>一旦完成了 HTTP 请求的准备工作，您必须调用其中一个 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#end">end</a></code> 方法来发送该请求（结束请求）。</p>
</div>
<div class="paragraph">
<p>结束一个请求时，若请求头尚未被写入，会导致它们被写入，并且请求被标记成完成的。</p>
</div>
<div class="paragraph">
<p>请求可以通过多种方式结束。无参简单结束请求的方式如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>或可以在调用 <code>end</code> 方法时提供 String 或 Buffer，这个和先调用带 String/Buffer 参数的 <code>write</code> 方法之后再调用无参 <code>end</code> 方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");
// End the request with a string
request.end("some-data");

// End it with a buffer
var buffer = Buffer.buffer().appendFloat(12.3).appendInt(321);
request.end(buffer);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_分块_http_请求">分块 HTTP 请求</h4>
<div class="paragraph">
<p>Vert.x 支持 <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">HTTP Chunked Transfer Encoding</a> 请求。</p>
</div>
<div class="paragraph">
<p>这允许使用块方式写入HTTP 请求体，这个在请求体比较大需要流式发送到服务器，或预先不知道大小时很常用。</p>
</div>
<div class="paragraph">
<p>您可使用 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#setChunked">setChunked</a></code> 将HTTP 请求设置成分块模式。</p>
</div>
<div class="paragraph">
<p>在分块模式下，每次调用 <code>write</code> 方法将导致新的块被写入到报文，这种模式中，无需先设置请求头中的 <code>Content-Length</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.setChunked(true);

// Write some chunks
for (var i = 0;i &lt; 10;i++) {
  request.write("this-is-chunk-" + i);
}

request.end();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_请求超时">请求超时</h4>
<div class="paragraph">
<p>您可使用 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#setTimeout">setTimeout</a></code> 设置一个特定 HTTP 请求的超时时间。</p>
</div>
<div class="paragraph">
<p>若请求在超时期限内未返回任何数据，则异常将会被传给异常处理器（若提供），并且请求将会被关闭。</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions_2">Handling exceptions</h4>
<div class="paragraph">
<p>您可以通过在 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html">HttpClientRequest</a></code> 实例中设置异常处理器来处理请求时发生的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var request = client.post("some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});
request.exceptionHandler(function (e) {
  console.log("Received exception: " + e.getMessage());
  e.printStackTrace();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种处理器不处理需要在 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html">HttpClientResponse</a></code> 中处理的非 2xx 响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var request = client.post("some-uri", function (response) {
  if (response.statusCode() === 200) {
    console.log("Everything fine");
    return
  }
  if (response.statusCode() === 500) {
    console.log("Unexpected behavior on the server side");
    return
  }
});
request.end();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
一系列的 <code>XXXNow</code> 方法均不接收异常处理器做为参数。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_客户端请求中指定处理器">客户端请求中指定处理器</h4>
<div class="paragraph">
<p>不像在调用中提供响应处理器来创建客户端请求对象，相反您可以当请求创建时不提供处理器、稍后在请求对象中调用
<code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#handler">handler</a></code> 来设置。如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var request = client.post("some-uri");
request.handler(function (response) {
  console.log("Received response with status code " + response.statusCode());
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用流式请求">使用流式请求</h4>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html">HttpClientRequest</a></code> 实例实现了 <code><a href="../../jsdoc/module-vertx-js_write_stream-WriteStream.html">WriteStream</a></code> 接口，这意味着您可以从任何 <code><a href="../../jsdoc/module-vertx-js_read_stream-ReadStream.html">ReadStream</a></code> 实例将数据泵入请求中。</p>
</div>
<div class="paragraph">
<p>例如，您可以将磁盘上的文件直接泵送到HTTP 请求体中，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Pump = require("vertx-js/pump");

request.setChunked(true);
var pump = Pump.pump(file, request);
file.endHandler(function (v) {
  request.end();
});
pump.start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_写_http_2_帧">写 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的具有各种帧的一个帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>要发送这样的帧，您可以使用 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#write">write</a></code> 方法写入请求，以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");

var frameType = 40;
var frameStatus = 10;
var payload = Buffer.buffer("some data");

// Sending a frame to the server
request.writeCustomFrame(frameType, frameStatus, payload);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_流重置_2">流重置</h4>
<div class="paragraph">
<p>HTTP/1.x 不允许请求或响应流进行重置，如当客户端上传了服务器上存在的资源时，服务器依然要接收整个响应。</p>
</div>
<div class="paragraph">
<p>HTTP/2 在请求/响应期间随时支持流重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.reset();</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况，发送 <code>NO_ERROR(0)</code> 错误代码，可发送另一个代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.reset(8);</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2规范定义了可使用的 <a href="http://httpwg.org/specs/rfc7540.html#ErrorCodes">错误码</a> 列表。</p>
</div>
<div class="paragraph">
<p>若使用了 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#exceptionHandler">request handler</a></code> 和
<code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#exceptionHandler">response handler</a></code> 两个处理器过后，在流重置完成时您将会收到通知。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.exceptionHandler(function (err) {
  if (err.getClass().getSimpleName() == 'StreamResetException') {
    var reset = err;
    console.log("Stream reset " + reset.getCode());
  }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理_http_响应">处理 HTTP 响应</h3>
<div class="paragraph">
<p>您可以在请求方法中指定处理器或通过 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html">HttpClientResponse</a></code> 对象直接设置处理器来接收到 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html">HttpClientRequest</a></code> 的实例。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#statusCode">statusCode</a></code>
和 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#statusMessage">statusMessage</a></code> 方法从响应中查询响应的状态码和状态消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">client.getNow("some-uri", function (response) {
  // the status code - e.g. 200 or 404
  console.log("Status code is " + response.statusCode());

  // the status message e.g. "OK" or "Not Found".
  console.log("Status message is " + response.statusMessage());
});</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_使用流式响应">使用流式响应</h4>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html">HttpClientResponse</a></code> 实例也是一个 <code><a href="../../jsdoc/module-vertx-js_read_stream-ReadStream.html">ReadStream</a></code> 实例，这意味着您可以泵送数据到任何 <code><a href="../../jsdoc/module-vertx-js_write_stream-WriteStream.html">WriteStream</a></code> 实例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_响应头和尾">响应头和尾</h4>
<div class="paragraph">
<p>HTTP 响应可包含头信息。您可以使用 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#headers">headers</a></code> 方法来读取响应头。</p>
</div>
<div class="paragraph">
<p>该方法返回的对象是 一个 <code><a href="../../jsdoc/module-vertx-js_multi_map-MultiMap.html">MultiMap</a></code> 实例，因为 HTTP 响应头中单个键可以关联多个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var contentType = response.headers().get("content-type");
var contentLength = response.headers().get("content-lengh");</code></pre>
</div>
</div>
<div class="paragraph">
<p>分块 HTTP 响应还可以包含响应尾(trailer) —— 这实际上是在发送响应体的最后一个（数据）块。</p>
</div>
<div class="paragraph">
<p>您可使用 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#trailers">trailers</a></code> 方法读取响应尾，尾数据也是一个 <code><a href="../../jsdoc/module-vertx-js_multi_map-MultiMap.html">MultiMap</a></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_读取请求体">读取请求体</h4>
<div class="paragraph">
<p>当从报文中读取到响应头时，响应处理器就会被调用。</p>
</div>
<div class="paragraph">
<p>如果收到的HTTP 响应包含响应体（正文），它可能会在响应头被读取后的某个时间以分片的方式到达。在调用响应处理器之前，我们不要等待所有的响应体到达，因为它可能非常大而要等待很长时间、又或者会花费大量内存。</p>
</div>
<div class="paragraph">
<p>当响应体的某部分（数据）到达时，<code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#handler">handler</a></code>
方法绑定的回调函数将会被调用，其中传入的 <code><a href="../../jsdoc/module-vertx-js_buffer-Buffer.html">Buffer</a></code> 中包含了响应体的这一分片（部分）内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">client.getNow("some-uri", function (response) {

  response.handler(function (buffer) {
    console.log("Received a part of the response body: " + buffer);
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您知道响应体不是很大，并想在处理之前在内存中聚合所有响应体数据，那么您可以自己聚合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");

client.getNow("some-uri", function (response) {

  // Create an empty buffer
  var totalBuffer = Buffer.buffer();

  response.handler(function (buffer) {
    console.log("Received a part of the response body: " + buffer.length());

    totalBuffer.appendBuffer(buffer);
  });

  response.endHandler(function (v) {
    // Now all the body has been read
    console.log("Total response body length is " + totalBuffer.length());
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者当响应已被完全读取时，您可以使用 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#bodyHandler">bodyHandler</a></code> 方法以便读取整个响应体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">client.getNow("some-uri", function (response) {

  response.bodyHandler(function (totalBuffer) {
    // Now all the body has been read
    console.log("Total response body length is " + totalBuffer.length());
  });
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_响应完成处理器">响应完成处理器</h4>
<div class="paragraph">
<p>当整个响应体被完全读取或者无响应体的响应头被完全读取时，响应的 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#endHandler">endHandler</a></code> 就会被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_从响应中读取cookie">从响应中读取Cookie</h4>
<div class="paragraph">
<p>您可以通过 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html#cookies">cookies</a></code> 方法从响应中获取 Cookie 列表。</p>
</div>
<div class="paragraph">
<p>或者您可以在响应中自己解析 <code>Set-Cookie</code> 头。</p>
</div>
</div>
<div class="sect3">
<h4 id="_30x_重定向处理器">30x 重定向处理器</h4>
<div class="paragraph">
<p>客户端可配置成遵循HTTP 重定向：当客户端接收到 <code>301</code> 、 <code>302</code> 、 <code>303</code> 或 <code>307</code> 状态代码时，它遵循由 <code>Location</code> 响应头提供的重定向，并且响应处理器将传递重定向响应以替代原始响应。</p>
</div>
<div class="paragraph">
<p>这有个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">client.get("some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
}).setFollowRedirects(true).end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>重定向策略如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当接收到 <code>301</code> 、 <code>302</code> 或 <code>303</code> 状态代码时，使用 GET 方法执行重定向</p>
</li>
<li>
<p>当接收到 <code>307</code> 状态代码时，使用相同的 HTTP 方法和缓存的请求体执行重定向</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
随后的重定向会缓存请求体。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况最大的重定向数为 <code>16</code> ，您可使用 <code><a href="../dataobjects.html#HttpClientOptions#setMaxRedirects">maxRedirects</a></code> 方法设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var client = vertx.createHttpClient({
  "maxRedirects" : 32
});

client.get("some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
}).setFollowRedirects(true).end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有放之四海而皆准的策略，缺省的重定向策略可能不能满足您的需要。</p>
</div>
<div class="paragraph">
<p>默认重定向策略可使用自定义实现更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Future = require("vertx-js/future");

client.redirectHandler(function (response) {

  // Only follow 301 code
  if (response.statusCode() === 301 &amp;&amp; (response.getHeader("Location") !== null &amp;&amp; response.getHeader("Location") !== undefined)) {

    // Compute the redirect URI
    var absoluteURI = resolveURI(response.request().absoluteURI(), response.getHeader("Location"));

    // Create a new ready to use request that the client will use
    return Future.succeededFuture(client.getAbs(absoluteURI))
  }

  // We don't redirect
  return null
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个策略将会处理接收到的原始 <code><a href="../../jsdoc/module-vertx-js_http_client_response-HttpClientResponse.html">HttpClientResponse</a></code> ，并返回 <code>null</code> 或 <code>Future&lt;HttpClientRequest&gt;</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当返回的是 <code>null</code> 时，处理原始响应</p>
</li>
<li>
<p>当返回的是 <code>Future</code> 时，请求将在它成功完成后发送</p>
</li>
<li>
<p>当返回的是 <code>Future</code> 时，请求失败时调用设置的异常处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>返回的请求必须是未发送的，这样原始请求处理器才会被发送而且客户端之后才能发送请求。</p>
</div>
<div class="paragraph">
<p>大多数原始请求设置将会传播（拷贝）到新请求中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求头，除非您已经设置了一些头（包括 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#setHost">setHost</a></code> ）</p>
</li>
<li>
<p>请求体，除非返回的请求使用了 <code>GET</code> 方法</p>
</li>
<li>
<p>响应处理器</p>
</li>
<li>
<p>请求异常处理器</p>
</li>
<li>
<p>请求超时</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_100_continue_处理">100-Continue 处理</h4>
<div class="paragraph">
<p>根据 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html">HTTP/1.1 规范</a> ，一个客户端可以设置请求头 <code>Expect: 100-Continue</code> ，并且在发送剩余请求体之前先发送请求头。</p>
</div>
<div class="paragraph">
<p>然后服务器可以通过回复临时响应状态 <code>Status: 100 (Continue)</code> 来告诉客户端可以发送请求的剩余部分。</p>
</div>
<div class="paragraph">
<p>这里的想法是允许服务器在发送大量数据之前授权、接收/拒绝请求，若请求不能被接收，则发送大量数据信息会浪费带宽，并将服务器绑定在读取即将丢弃的无用数据中。</p>
</div>
<div class="paragraph">
<p>Vert.x 允许您在客户端请求对象中设置一个 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#continueHandler">continueHandler</a></code> 。</p>
</div>
<div class="paragraph">
<p>它将在服务器发回一个状态 <code>Status: 100 (Continue)</code> 时被调用, 同时也表示（客户端）可以发送请求的剩余部分。</p>
</div>
<div class="paragraph">
<p>通常将其与 <code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#sendHead">sendHead</a></code> 结合起来发送请求的头信息。</p>
</div>
<div class="paragraph">
<p>以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var request = client.put("some-uri", function (response) {
  console.log("Received response with status code " + response.statusCode());
});

request.putHeader("Expect", "100-Continue");

request.continueHandler(function (v) {
  // OK to send rest of body
  request.write("Some data");
  request.write("Some more data");
  request.end();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在服务端，Vert.x HTTP Server可配置成接收到 <code>Expect: 100-Continue</code> 头时自动发回 <code>100 Continue</code> 临时响应信息。</p>
</div>
<div class="paragraph">
<p>这个可通过 <code><a href="../dataobjects.html#HttpServerOptions#setHandle100ContinueAutomatically">handle100ContinueAutomatically</a></code> 方法来设置。</p>
</div>
<div class="paragraph">
<p>若您想要决定是否手动发送持续响应，那么此属性可设置成 <code>false</code> （默认值），然后您可以通过检查头信息并且调用 <code><a href="../../jsdoc/module-vertx-js_http_server_response-HttpServerResponse.html#writeContinue">writeContinue</a></code>
方法让客户端持续发送请求体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">httpServer.requestHandler(function (request) {
  if (request.getHeader("Expect").equalsIgnoreCase("100-Continue")) {

    // Send a 100 continue response
    request.response().writeContinue();

    // The client should send the body when it receives the 100 response
    request.bodyHandler(function (body) {
      // Do something with body
    });

    request.endHandler(function (v) {
      request.response().end();
    });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以通过直接发送故障状态代码来拒绝该请求：这种情况下，请求体应该被忽略或连接应该被关闭（ <code>100-Continue</code> 是一个性能提示，并不是逻辑协议约束）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">httpServer.requestHandler(function (request) {
  if (request.getHeader("Expect").equalsIgnoreCase("100-Continue")) {

    //
    var rejectAndClose = true;
    if (rejectAndClose) {

      // Reject with a failure code and close the connection
      // this is probably best with persistent connection
      request.response().setStatusCode(405).putHeader("Connection", "close").end();
    } else {

      // Reject with a failure code and ignore the body
      // this may be appropriate if the body is small
      request.response().setStatusCode(405).end();
    }
  }
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端推送">客户端推送</h4>
<div class="paragraph">
<p>服务器推送(Server Push)是 HTTP/2 的一个新功能，它可以为单个客户端并行发送多个响应。</p>
</div>
<div class="paragraph">
<p>可以在接收服务器推送的请求/响应的请求上设置一个推送处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var request = client.get("/index.html", function (response) {
  // Process index.html response
});

// Set a push handler to be aware of any resource pushed by the server
request.pushHandler(function (pushedRequest) {

  // A resource is pushed for this request
  console.log("Server pushed " + pushedRequest.path());

  // Set an handler for the response
  pushedRequest.handler(function (pushedResponse) {
    console.log("The response for the pushed request");
  });
});

// End the request
request.end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>若客户端不想收到推送请求，它可重置流：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.pushHandler(function (pushedRequest) {
  if (pushedRequest.path() == "/main.js") {
    pushedRequest.reset();
  } else {
    // Handle it
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>若没有设置任何处理器时，任何被推送的流将被客户端自动重置流（错误代码 <code>8</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接收自定义_http_2_帧_2">接收自定义 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的具有各种帧的一个帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>要接收自定义帧，您可以在请求中使用 <code>customFrameHandler</code> ，每次自定义帧到达时就会调用它。以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">response.customFrameHandler(function (frame) {

  console.log("Received a frame type=" + frame.type() + " payload" + frame.payload().toString());
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_客户端启用压缩">客户端启用压缩</h3>
<div class="paragraph">
<p>HTTP 客户端支持开箱即用的 HTTP 压缩功能。</p>
</div>
<div class="paragraph">
<p>这意味着客户端可以让远程服务器知道它支持压缩，并且能处理压缩过的响应体（数据）。</p>
</div>
<div class="paragraph">
<p>HTTP 服务端可以自由地使用自己支持的压缩算法之一进行压缩，也可以在不压缩的情况下将响应体发回。所以这仅仅是 HTTP 服务端的一个可能被随意忽略的提示。</p>
</div>
<div class="paragraph">
<p>要告诉服务器当前客户端支持哪种压缩，则它（请求头）将包含一个 <code>Accept-Encoding</code> 头，其值为可支持的压缩算法，（该值可）支持多种压缩算法。这种情况 Vert.x 将添加以下头：</p>
</div>
<div class="paragraph">
<p>Accept-Encoding: gzip, deflate</p>
</div>
<div class="paragraph">
<p>服务器将从其中（算法）选择一个，您可以通过服务器发回的响应中响应头 <code>Content-Encoding</code> 来检测服务器是否适应这个正文。</p>
</div>
<div class="paragraph">
<p>若响应体通过 <code>gzip</code> 压缩，它将包含例如下边的头：</p>
</div>
<div class="paragraph">
<p>Content-Encoding: gzip</p>
</div>
<div class="paragraph">
<p>创建客户端时可使用 <code><a href="../dataobjects.html#HttpClientOptions#setTryUseCompression">tryUseCompression</a></code> 设置配置项启用压缩。</p>
</div>
<div class="paragraph">
<p>默认情况压缩被禁用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_1_x_pooling_和_keep_alive">HTTP/1.x Pooling 和 Keep alive</h3>
<div class="paragraph">
<p>HTTP 的 Keep Alive 允许单个 HTTP 连接用于多个请求。当您向同一台服务器发送多个请求时，可以更加有效使用连接。</p>
</div>
<div class="paragraph">
<p>对于 HTTP/1.x 版本，HTTP 客户端支持连接池，它允许您重用请求之间的连接。</p>
</div>
<div class="paragraph">
<p>为了连接池（能）工作，配置客户端时，keep alive 必须通过 <code><a href="../dataobjects.html#HttpClientOptions#setKeepAlive">keepAlive</a></code>
方法设置成 <code>true</code> 。默认值为 <code>true</code> 。</p>
</div>
<div class="paragraph">
<p>当 keep alive 启用时，Vert.x 将为每一个发送的 HTTP/1.0 请求添加一个 <code>Connection: Keep-Alive</code> 头。
当 keep alive 禁用时，Vert.x 将为每一个 HTTP/1.1 请求添加一个 <code>Connection: Close</code> 头 —— 表示在响应完成后连接将被关闭。</p>
</div>
<div class="paragraph">
<p>可使用 <code><a href="../dataobjects.html#HttpClientOptions#setMaxPoolSize">maxPoolSize</a></code> 方法为每个服务器配置连接池的最大连接数。</p>
</div>
<div class="paragraph">
<p>当启用连接池创建请求时，若存在少于已经为服务器创建的最大连接数，Vert.x 将创建一个新连接，否则直接将请求添加到队列中。</p>
</div>
<div class="paragraph">
<p>Keep Alive的连接将不会被客户端自动关闭，要关闭它们您可以关闭客户端实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>keep-alive: timeout=30</pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可使用 <code><a href="../dataobjects.html#HttpClientOptions#setKeepAliveTimeout">keepAliveTimeout</a></code> 设置空闲时间——在设置的时间内然后没使用的连接将被关闭。请注意空闲超时值以秒为单位而不是毫秒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_1_1_pipe_lining">HTTP/1.1 pipe-lining</h3>
<div class="paragraph">
<p>客户端还支持连接上的请求管道(pipeline)。</p>
</div>
<div class="paragraph">
<p>管道意味着在返回一个响应之前，在同一个连接上发送另一个请求，管道不适合所有请求。</p>
</div>
<div class="paragraph">
<p>若要启用管道，必须调用 <code><a href="../dataobjects.html#HttpClientOptions#setPipelining">pipelining</a></code> 方法，默认管道是禁止的。</p>
</div>
<div class="paragraph">
<p>当启用管道时，请求可以不等待以前的响应返回而写入到连接。</p>
</div>
<div class="paragraph">
<p>单个连接的管道请求限制数由 <code><a href="../dataobjects.html#HttpClientOptions#setPipeliningLimit">pipeliningLimit</a></code>
方法设置，此选项定义了发送到服务器的等待响应的最大请求数。这个限制可以确保和同一个服务器的连接分发到客户端的公平性。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_2_多路复用">HTTP/2 多路复用</h3>
<div class="paragraph">
<p>HTTP/2 提倡使用服务器的单一连接，默认情况下，HTTP 客户端针对每个服务器都使用单一连接，同样服务器上的所有流都会复用到对应连接中。</p>
</div>
<div class="paragraph">
<p>当客户端需要使用连接池并使用超过一个连接时，则可使用 <code><a href="../dataobjects.html#HttpClientOptions#setHttp2MaxPoolSize">http2MaxPoolSize</a></code>
设置。</p>
</div>
<div class="paragraph">
<p>当您希望限制每个连接的多路复用流数量而使用连接池而不是单个连接时，可使用 <code><a href="../dataobjects.html#HttpClientOptions#setHttp2MultiplexingLimit">http2MultiplexingLimit</a></code>
设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var clientOptions = {
  "http2MultiplexingLimit" : 10,
  "http2MaxPoolSize" : 3
};

// Uses up to 3 connections and up to 10 streams per connection
var client = vertx.createHttpClient(clientOptions);</code></pre>
</div>
</div>
<div class="paragraph">
<p>连接的复用限制是在客户端上设置限制单个连接的流数量，如果服务器使用 <code><a href="../dataobjects.html#Http2Settings#setMaxConcurrentStreams">SETTINGS_MAX_CONCURRENT_STREAMS</a></code> 设置了下限，则有效值可以更低。</p>
</div>
<div class="paragraph">
<p>HTTP/2 连接不会被客户端自动关闭，若要关闭它们，可以调用 <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#close">close</a></code>
来关闭客户端实例。</p>
</div>
<div class="paragraph">
<p>或者，您可以使用 <code><a href="../dataobjects.html#HttpClientOptions#setIdleTimeout">idleTimeout</a></code> 设置空闲时间——这个时间内没有使用的任何连接将被关闭，注意，空闲时间以秒为单位，不是毫秒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_连接">HTTP 连接</h3>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html">HttpConnection</a></code> 接口提供了处理HTTP 连接事件、生命周期、设置的API。</p>
</div>
<div class="paragraph">
<p>HTTP/2 实现了完整的 <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html">HttpConnection</a></code> API。</p>
</div>
<div class="paragraph">
<p>HTTP/1.x 实现了 <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html">HttpConnection</a></code> 中的部分API：仅关闭操作，实现了关闭处理器和异常处理器。该协议并不提供其他操作的语义。</p>
</div>
<div class="sect3">
<h4 id="_服务端连接">服务端连接</h4>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#connection">connection</a></code> 方法会返回服务器上的请求连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var connection = request.connection();</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在服务器上设置连接处理器，任意连接传入时可得到通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var server = vertx.createHttpServer(http2Options);

server.connectionHandler(function (connection) {
  console.log("A client connected");
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端连接">客户端连接</h4>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_http_client_request-HttpClientRequest.html#connection">connection</a></code> 方法会返回客户端上的连接请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var connection = request.connection();</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在请求上设置连接处理器在连接发生时通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">request.connectionHandler(function (connection) {
  console.log("Connected to the server");
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_连接配置">连接配置</h4>
<div class="paragraph">
<p>HTTP/2 由 <code><a href="../dataobjects.html#Http2Settings">Http2Settings</a></code> 数据对象来配置。</p>
</div>
<div class="paragraph">
<p>每个 Endpoint 都必须遵守连接另一端的发送设置。</p>
</div>
<div class="paragraph">
<p>当建立连接时，客户端和服务器交换初始配置，初始设置由客户端上的 <code><a href="../dataobjects.html#HttpClientOptions#setInitialSettings">initialSettings</a></code> 和服务器上的
<code><a href="../dataobjects.html#HttpServerOptions#setInitialSettings">initialSettings</a></code> 方法配置。</p>
</div>
<div class="paragraph">
<p>连接建立后可随时更改设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.updateSettings({
  "maxConcurrentStreams" : 100
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于远程方应该确认接收者的配置更新，也有可能在回调中接收确认通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.updateSettings({
  "maxConcurrentStreams" : 100
}, function (ar, ar_err) {
  if (ar_err == null) {
    console.log("The settings update has been acknowledged ");
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，在收到新的远程设置时会通知 <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#remoteSettingsHandler">remoteSettingsHandler</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.remoteSettingsHandler(function (settings) {
  console.log("Received new settings");
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
此功能仅适用于 HTTP/2 协议。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_连接_ping">连接 Ping</h4>
<div class="paragraph">
<p>HTTP/2 连接 ping 对于确定连接往返时间或检查连接有效性很有用： <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#ping">ping</a></code> 发送 {@literal PING} 帧到远端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");
var data = Buffer.buffer();
for (var i = 0;i &lt; 8;i++) {
  data.appendByte(i);
}
connection.ping(data, function (pong, pong_err) {
  console.log("Remote side replied");
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当接收到 {@literal PING} 帧时，Vert.x 将自动发送确认，可设置处理器当收到 ping 帧时发送通知调用处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.pingHandler(function (ping) {
  console.log("Got pinged by remote side");
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>处理器只是接到通知，确认被发送，这个功能旨在基于 HTTP/2 协议之上实现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
此功能仅适用于 HTTP/2 协议。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_连接关闭_goaway">连接关闭/GOAWAY</h4>
<div class="paragraph">
<p>调用 <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#shutdown">shutdown</a></code> 方法将发送 {@literal GOAWAY} 帧到远程的连接，要求其停止创建流：客户端将停止发送新请求，并且服务器将停止推送响应。发送 {@literal GOAWAY} 帧后，连接将等待一段时间（默认为30秒），直到所有当前流关闭和连接关闭。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#shutdownHandler">shutdownHandler</a></code> 通知何时关闭所有流，连接尚未关闭。</p>
</div>
<div class="paragraph">
<p>有可能只需发送 {@literal GOAWAY} 帧，和关闭主要的区别在于它将只是告诉远程连接停止创建新流，而没有计划关闭连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.goAway(0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，也可以在收到 {@literal GOAWAY} 时收到通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.goAwayHandler(function (goAway) {
  console.log("Received a go away frame");
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当所有当前流已经关闭并且可关闭连接时， <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#shutdownHandler">shutdownHandler</a></code> 将被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">connection.goAway(0);
connection.shutdownHandler(function (v) {

  // All streams are closed, close the connection
  connection.close();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当接收到 {@literal GOAWAY} 时也适用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
此功能仅适用于HTTP/2协议。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_连接关闭">连接关闭</h4>
<div class="paragraph">
<p>您可以通过 <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#close">close</a></code> 方法关闭连接：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于 HTTP/1.x 来说，它会关闭底层的 Socket</p>
</li>
<li>
<p>对于 HTTP/2 来说，它将执行无延迟关闭， {@literal GOAWAY} 帧将会在连接关闭之前被发送 *</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>连接关闭时 <code><a href="../../jsdoc/module-vertx-js_http_connection-HttpConnection.html#closeHandler">closeHandler</a></code> 将发出通知。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_httpclient_使用说明">HttpClient 使用说明</h3>
<div class="paragraph">
<p><code>HttpClient</code> 可以在一个 Verticle 中使用或者嵌入使用。</p>
</div>
<div class="paragraph">
<p>在 Verticle 中使用时，Verticle <strong>应该使用自己的客户端实例</strong>。</p>
</div>
<div class="paragraph">
<p>一般来说，不应该在不同的 Vert.x 上下文环境之间共享客户端，因为它可能导致不可预知的意外。</p>
</div>
<div class="paragraph">
<p>例如：保持活动连接将在打开连接的请求上下文环境调用客户端处理器，后续请求将使用相同上下文环境。</p>
</div>
<div class="paragraph">
<p>当这种情况发生时，Vert.x会检测到并记录下边警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Reusing a connection with a different context: an HttpClient is probably shared between different Verticles</pre>
</div>
</div>
<div class="paragraph">
<p><code>HttpClient</code> 可以嵌套在非 Vert.x 线程中，如单元测试或纯Java的 <code>main</code> 线程中：客户端处理器将被不同的Vert.x 线程和上下文调用，这样的上下文会根据需要创建。对于生产环境，不推荐这样使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务端共享">服务端共享</h3>
<div class="paragraph">
<p>当多个 HTTP 服务端在同一个端口上监听时，Vert.x 会使用轮询策略来管理请求处理。</p>
</div>
<div class="paragraph">
<p>我们用 Verticle 来创建 HTTP 服务端，如：</p>
</div>
<div class="listingblock">
<div class="title">io.vertx.examples.http.sharing.HttpServerVerticle</div>
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">vertx.createHttpServer().requestHandler(function (request) {
  request.response().end("Hello from server " + this);
}).listen(8080);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个服务正在监听 <code>8080</code> 端口。所以，当这个 Verticle 被实例化多次，如运行以下命令：
<code>vertx run io.vertx.examples.http.sharing.HttpServerVerticle -instances 2</code> ,
将会发生什么？如果两个 Verticle 都绑定到同一个端口，您将收到一个 Socket 异常。幸运的是，Vert.x 可以为您处理这种情况。在与现有服务端相同的主机和端口上部署另一个服务器时，实际上并不会尝试创建在同一主机/端口上监听的新服务端，它只绑定一次到Socket，当接收到请求时，会按照轮询策略调用服务端的请求处理函数。</p>
</div>
<div class="paragraph">
<p>我们现在想象一个客户端，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">vertx.setPeriodic(100, function (l) {
  vertx.createHttpClient().getNow(8080, "localhost", "/", function (resp) {
    resp.bodyHandler(function (body) {
      console.log(body.toString("ISO-8859-1"));
    });
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x 将请求顺序委托给其中一个服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Hello from i.v.e.h.s.HttpServerVerticle@1
Hello from i.v.e.h.s.HttpServerVerticle@2
Hello from i.v.e.h.s.HttpServerVerticle@1
Hello from i.v.e.h.s.HttpServerVerticle@2
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，服务器可直接扩展可用的核，而每个 Vert.x 中的 Verticle 实例仍然严格使用单线程，您不需要像编写负载均衡器那样使用任何特殊技巧去编写，以便在多核机器上扩展服务器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_https">使用 HTTPS</h3>
<div class="paragraph">
<p>Vert.x 的 HTTP 服务端和客户端可以配置成和网络服务器完全相同的方式使用 HTTPS。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅 <a href="#ssl">配置网络服务器以使用 SSL</a> 章节。</p>
</div>
<div class="paragraph">
<p>SSL可以通过每个请求的 <code><a href="../dataobjects.html#RequestOptions">RequestOptions</a></code> 来启用/禁用，或在指定模式时调用 <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html#requestAbs">requestAbs</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">client.getNow({
  "host" : "localhost",
  "port" : 8080,
  "uRI" : "/",
  "ssl" : true
}, function (response) {
  console.log("Received response with status code " + response.statusCode());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../dataobjects.html#HttpClientOptions#setSsl">ssl</a></code> 设置将用作客户端默认配置。</p>
</div>
<div class="paragraph">
<p><code><a href="../dataobjects.html#RequestOptions#setSsl">ssl</a></code> 将覆盖默认客户端设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>即使客户端配置成使用 SSL/TLS，该值设置成 <code>false</code> 将禁用SSL/TLS。</p>
</li>
<li>
<p>即使客户端配置成不使用 SSL/TLS，该值设置成 <code>true</code> 将启用SSL/TLS，实际的客户端SSL/TLS（如受信、密钥/证书、密码、ALPN 等）将被重用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>同样， <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html#requestAbs">requestAbs</a></code> 方法也会（在调用时）覆盖默认客户端设置。</p>
</div>
<div class="sect3">
<h4 id="_server_name_indication_sni">Server Name Indication (SNI)</h4>
<div class="paragraph">
<p>Vert.x http servers can be configured to use SNI in exactly the same way as {@linkplain io.vertx.core.net net servers} .</p>
</div>
<div class="paragraph">
<p>Vert.x http client will present the actual hostname as <em>server name</em> during the TLS handshake.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_websockets">WebSockets</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a> 是一种Web技术，可以在 HTTP 服务端和 HTTP 客户端（通常是浏览器）之间实现全双工 Socket 连接。</p>
</div>
<div class="paragraph">
<p>Vert.x HTTP 客户端和服务端都支持 WebSocket。</p>
</div>
<div class="sect3">
<h4 id="_服务端_websocket">服务端 WebSocket</h4>
<div class="paragraph">
<p>在服务端处理 WebSocket 有两种方法。</p>
</div>
<div class="sect4">
<h5 id="_websocket_handler">WebSocket handler</h5>
<div class="paragraph">
<p>第一种方法需要在服务端实例上提供一个 <code><a href="../../jsdoc/module-vertx-js_http_server-HttpServer.html#websocketHandler">websocketHandler</a></code> 。</p>
</div>
<div class="paragraph">
<p>当对服务端创建 WebSocket 连接时，Vert.x 将向 <code>Handler</code> 传入一个
<code><a href="../../jsdoc/module-vertx-js_server_web_socket-ServerWebSocket.html">ServerWebSocket</a></code> 实例，在其中去处理它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">server.websocketHandler(function (websocket) {
  console.log("Connected!");
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以调用 <code><a href="../../jsdoc/module-vertx-js_server_web_socket-ServerWebSocket.html#reject">reject</a></code> 方法来拒绝一个 WebSocket。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">server.websocketHandler(function (websocket) {
  if (websocket.path() == "/myapi") {
    websocket.reject();
  } else {
    // Do something
  }
});</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_转换到_websocket">转换到 WebSocket</h5>
<div class="paragraph">
<p>处理 WebSocket 的第二种方法是处理从客户端发送的HTTP升级请求，调用服务器请求对象的 <code><a href="../../jsdoc/module-vertx-js_http_server_request-HttpServerRequest.html#upgrade">upgrade</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">server.requestHandler(function (request) {
  if (request.path() == "/myapi") {

    var websocket = request.upgrade();
    // Do something

  } else {
    // Reject
    request.response().setStatusCode(400).end();
  }
});</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_服务端_websocket_2">服务端 WebSocket</h5>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_server_web_socket-ServerWebSocket.html">ServerWebSocket</a></code> 实例能够让您读取在WebSocket 握手中的HTTP 请求的 <code><a href="../../jsdoc/module-vertx-js_server_web_socket-ServerWebSocket.html#headers">headers</a></code> ,
<code><a href="../../jsdoc/module-vertx-js_server_web_socket-ServerWebSocket.html#path">path</a></code> , <code><a href="../../jsdoc/module-vertx-js_server_web_socket-ServerWebSocket.html#query">query</a></code> 和
<code><a href="../../jsdoc/module-vertx-js_server_web_socket-ServerWebSocket.html#uri">URI</a></code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端_websocket">客户端 WebSocket</h4>
<div class="paragraph">
<p>Vert.x 的 <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html">HttpClient</a></code> 支持 WebSocket。</p>
</div>
<div class="paragraph">
<p>您可以调用其中任意一个 <code><a href="../../jsdoc/module-vertx-js_http_client-HttpClient.html#websocket">websocket</a></code> 方法创建 WebSocket 连接到服务端，并提供回调函数。</p>
</div>
<div class="paragraph">
<p>当连接建立时，处理器将被调用并且传入 <code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html">WebSocket</a></code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">client.websocket("/some-uri", function (websocket) {
  console.log("Connected!");
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_向_websocket_写入消息">向 WebSocket 写入消息</h4>
<div class="paragraph">
<p>若您想将一个 WebSocket 消息写入 WebSocket，可使用
<code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html#writeBinaryMessage">writeBinaryMessage</a></code> 方法或
<code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html#writeTextMessage">writeTextMessage</a></code> 方法来执行该操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");
// Write a simple binary message
var buffer = Buffer.buffer().appendInt(123).appendFloat(1.23);
websocket.writeBinaryMessage(buffer);

// Write a simple text message
var message = "hello";
websocket.writeTextMessage(message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>若WebSocket 消息大于使用
<code><a href="../dataobjects.html#HttpClientOptions#setMaxWebsocketFrameSize">maxWebsocketFrameSize</a></code>
设置的WebSocket 的帧的最大值，则Vert.x在将其发送到报文之前将其拆分为多个WebSocket 帧。</p>
</div>
</div>
<div class="sect3">
<h4 id="_向_websocket_写入帧">向 WebSocket 写入帧</h4>
<div class="paragraph">
<p>WebSocket 消息可以由多个帧组成，在这种情况下，第一帧是二进制或文本帧（text | binary），后边跟着零个或多个 <strong>连续</strong> 帧。</p>
</div>
<div class="paragraph">
<p>消息中的最后一帧标记成 <strong>final</strong>。</p>
</div>
<div class="paragraph">
<p>要发送多个帧组成的消息，请使用
<code><a href="../../jsdoc/module-vertx-js_web_socket_frame-WebSocketFrame.html#binaryFrame">WebSocketFrame.binaryFrame</a></code>
, <code><a href="../../jsdoc/module-vertx-js_web_socket_frame-WebSocketFrame.html#textFrame">WebSocketFrame.textFrame</a></code> 或
<code><a href="../../jsdoc/module-vertx-js_web_socket_frame-WebSocketFrame.html#continuationFrame">WebSocketFrame.continuationFrame</a></code> 方法创建帧，并使用 <code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html#writeFrame">writeFrame</a></code> 方法将其写入WebSocket。</p>
</div>
<div class="paragraph">
<p>以下是二进制帧的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var WebSocketFrame = require("vertx-js/web_socket_frame");

var frame1 = WebSocketFrame.binaryFrame(buffer1, false);
websocket.writeFrame(frame1);

var frame2 = WebSocketFrame.continuationFrame(buffer2, false);
websocket.writeFrame(frame2);

// Write the final frame
var frame3 = WebSocketFrame.continuationFrame(buffer2, true);
websocket.writeFrame(frame3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>许多情况下，您只需要发送一个包含了单个最终帧的 WebSocket 消息，因此我们提供了 <code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html#writeFinalBinaryFrame">writeFinalBinaryFrame</a></code>
和 <code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html#writeFinalTextFrame">writeFinalTextFrame</a></code> 这两个快捷方法。</p>
</div>
<div class="paragraph">
<p>下边是示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var Buffer = require("vertx-js/buffer");

// Send a websocket messages consisting of a single final text frame:

websocket.writeFinalTextFrame("Geronimo!");

// Send a websocket messages consisting of a single final binary frame:

var buff = Buffer.buffer().appendInt(12).appendString("foo");

websocket.writeFinalBinaryFrame(buff);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_从_websocket_读取帧">从 WebSocket 读取帧</h4>
<div class="paragraph">
<p>要 从WebSocket 读取帧，您可以使用 <code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html#frameHandler">frameHandler</a></code> 方法。</p>
</div>
<div class="paragraph">
<p>当帧到达时，会传入一个 <code><a href="../../jsdoc/module-vertx-js_web_socket_frame-WebSocketFrame.html">WebSocketFrame</a></code> 实例给帧处理器，并调用它，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">websocket.frameHandler(function (frame) {
  console.log("Received a frame of size!");
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_关闭_websocket">关闭 WebSocket</h4>
<div class="paragraph">
<p>处理完成之后，请使用 <code><a href="../../jsdoc/module-vertx-js_web_socket_base-WebSocketBase.html#close">close</a></code> 方法关闭 WebSocket 连接。</p>
</div>
</div>
<div class="sect3">
<h4 id="_流式_websocket">流式 WebSocket</h4>
<div class="paragraph">
<p><code><a href="../../jsdoc/module-vertx-js_web_socket-WebSocket.html">WebSocket</a></code> 实例也是 <code><a href="../../jsdoc/module-vertx-js_read_stream-ReadStream.html">ReadStream</a></code> 和
<code><a href="../../jsdoc/module-vertx-js_write_stream-WriteStream.html">WriteStream</a></code> 的实现类，因此可以和泵(pump)一起使用。</p>
</div>
<div class="paragraph">
<p>当使用 WebSocket 作为可写流或可读流时，它只能用于不分割多个帧的二进制帧一起使用的 WebSocket 连接。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_http_https_连接代理">使用 HTTP/HTTPS 连接代理</h3>
<div class="paragraph">
<p>HTTP 客户端支持通过HTTP 代理（如Squid）或 <strong>SOCKS4a</strong> 或 <strong>SOCKS5</strong> 代理访问 HTTP/HTTPS 的 URL。CONNECT 协议使用 HTTP/1.x，但可以连接到 HTTP/1.x 和 HTTP/2 服务器。</p>
</div>
<div class="paragraph">
<p>到 <code>h2c</code> （未加密HTTP/2服务器）的连接可能不受 HTTP 代理支持，因为代理仅支持 HTTP/1.1。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../dataobjects.html#HttpClientOptions">HttpClientOptions</a></code> 中的
<code><a href="../dataobjects.html#ProxyOptions">ProxyOptions</a></code> 对象配置来配置代理（包括代理类型、主机名、端口和可选用户名和密码）。</p>
</div>
<div class="paragraph">
<p>以下是使用 HTTP 代理的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "proxyOptions" : {
    "type" : "HTTP",
    "host" : "localhost",
    "port" : 3128,
    "username" : "username",
    "password" : "secret"
  }
};
var client = vertx.createHttpClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当客户端连接到HTTP URL时，它连接到代理服务器，并在HTTP请求中提供完整URL ("GET <a href="http://www.somehost.com/path/file.html" class="bare">http://www.somehost.com/path/file.html</a> HTTP/1.1").</p>
</div>
<div class="paragraph">
<p>当客户端连接到HTTPS URL时，它要求代理使用 CONNECT 方法创建到远程主机的通道。</p>
</div>
<div class="paragraph">
<p>对于 SOCKS5 代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "proxyOptions" : {
    "type" : "SOCKS5",
    "host" : "localhost",
    "port" : 1080,
    "username" : "username",
    "password" : "secret"
  }
};
var client = vertx.createHttpClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>DNS 解析会一直在代理服务器上执行。为了实现 SOCKS4 客户端的功能，需要先在本地解析 DNS 地址。</p>
</div>
<div class="sect3">
<h4 id="_handling_of_other_protocols">Handling of other protocols</h4>
<div class="paragraph">
<p>The HTTP proxy implementation supports getting ftp:// urls if the proxy supports
that, which isn&#8217;t available in non-proxy getAbs requests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var options = {
  "proxyOptions" : {
    "type" : "HTTP"
  }
};
var client = vertx.createHttpClient(options);
client.getAbs("ftp://ftp.gnu.org/gnu/", function (response) {
  console.log("Received response with status code " + response.statusCode());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Support for other protocols is not available since java.net.URL does not
support them (gopher:// for example).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_中自动清理">Verticle 中自动清理</h3>
<div class="paragraph">
<p>如果您是在 Verticle 内部创建的 HTTP 服务端和客户端，则在撤销该Verticle时，它们将自动关闭。</p>
</div>
</div>
</div>
</div>
        

        
          <div id="footer">
            <div id="footer-text">
              
                上次更新时间 2018-12-28 15:22:46 CST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/">主页</a></li>
          <li><a href="https://vertx.tk/download/">下载</a></li>
          <li><a href="https://vertx.tk/docs/">文档</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
          <li><a href="https://vertx.tk/blog/">博客</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/community/">帮助 &amp; 贡献者</a></li>
          <li><a href="https://vertx.tk/materials/">学习资料</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
          <li><a href="//shang.qq.com/wpa/qunwpa?idkey=587f58cacb9557e3291b46098e0fe09427b98a1c0f866da23c04c2762bc7e2ad">QQ群</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual-licensed under the <a href="http://www.eclipse.org/legal/epl-v20.html">Eclipse Public License 2.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="https://vertx.tk/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="https://vertx.tk/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="https://vertx.tk/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://vertx.tk/javascripts/bootstrap.min.js"></script>
<script src="https://vertx.tk/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="https://vertx.tk/javascripts/sidebar.js"></script>


<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});
</script>
</body>
</html>

