<!DOCTYPE html>
<html lang="en">
<head>
  <title>编写 TCP 服务端和客户端 - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="https://vertx.tk/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://vertx.tk/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="https://vertx.tk/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="https://vertx.tk/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="https://vertx.tk/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://vertx.tk/" class="navbar-brand"><img alt="Brand" src="https://vertx.tk/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="https://vertx.tk/download/">Download</a></li>
        <li><a href="https://vertx.tk/docs/">Documentation</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">Wiki</a></li>
        <li><a href="https://vertx.tk/community/">Community</a></li>
        <li><a href="https://vertx.tk/materials/">Materials</a></li>
        <li><a href="https://vertx.tk/blog/">Blog</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>编写 TCP 服务端和客户端</h1>
          
        </div>
      </div>
    </div>
  </div>



<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_tcp_服务端">创建 TCP 服务端</a></li>
<li><a href="#_配置_tcp_服务端">配置 TCP 服务端</a></li>
<li><a href="#_启动服务端监听">启动服务端监听</a></li>
<li><a href="#_监听随机端口">监听随机端口</a></li>
<li><a href="#_接收传入连接的通知">接收传入连接的通知</a></li>
<li><a href="#_从socket读取数据">从Socket读取数据</a></li>
<li><a href="#_向socket中写入数据">向Socket中写入数据</a></li>
<li><a href="#_关闭处理器">关闭处理器</a></li>
<li><a href="#_处理异常">处理异常</a></li>
<li><a href="#_event_bus_写处理器">Event Bus 写处理器</a></li>
<li><a href="#_本地和远程地址">本地和远程地址</a></li>
<li><a href="#_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</a></li>
<li><a href="#_流式的socket">流式的Socket</a></li>
<li><a href="#_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</a></li>
<li><a href="#_关闭_tcp_服务端">关闭 TCP 服务端</a></li>
<li><a href="#_verticle中的自动清理">Verticle中的自动清理</a></li>
<li><a href="#_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</a></li>
<li><a href="#_创建_tcp_客户端">创建 TCP 客户端</a></li>
<li><a href="#_配置_tcp_客户端">配置 TCP 客户端</a></li>
<li><a href="#_创建连接">创建连接</a></li>
<li><a href="#_配置连接重试">配置连接重试</a></li>
<li><a href="#logging_network_activity">记录网络活动</a></li>
<li><a href="#ssl">配置服务端和客户端以使用SSL/TLS</a></li>
<li><a href="#_客户端连接使用代理">客户端连接使用代理</a></li>
</ul>
</li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_tcp_服务端">创建 TCP 服务端</a></li>
<li><a href="#_配置_tcp_服务端">配置 TCP 服务端</a></li>
<li><a href="#_启动服务端监听">启动服务端监听</a></li>
<li><a href="#_监听随机端口">监听随机端口</a></li>
<li><a href="#_接收传入连接的通知">接收传入连接的通知</a></li>
<li><a href="#_从socket读取数据">从Socket读取数据</a></li>
<li><a href="#_向socket中写入数据">向Socket中写入数据</a></li>
<li><a href="#_关闭处理器">关闭处理器</a></li>
<li><a href="#_处理异常">处理异常</a></li>
<li><a href="#_event_bus_写处理器">Event Bus 写处理器</a></li>
<li><a href="#_本地和远程地址">本地和远程地址</a></li>
<li><a href="#_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</a></li>
<li><a href="#_流式的socket">流式的Socket</a></li>
<li><a href="#_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</a></li>
<li><a href="#_关闭_tcp_服务端">关闭 TCP 服务端</a></li>
<li><a href="#_verticle中的自动清理">Verticle中的自动清理</a></li>
<li><a href="#_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</a></li>
<li><a href="#_创建_tcp_客户端">创建 TCP 客户端</a></li>
<li><a href="#_配置_tcp_客户端">配置 TCP 客户端</a></li>
<li><a href="#_创建连接">创建连接</a></li>
<li><a href="#_配置连接重试">配置连接重试</a></li>
<li><a href="#logging_network_activity">记录网络活动</a></li>
<li><a href="#ssl">配置服务端和客户端以使用SSL/TLS</a></li>
<li><a href="#_客户端连接使用代理">客户端连接使用代理</a></li>
</ul>
</li>
</ul>
        </div>
        <div class="sect1">
<h2 id="_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x允许您很容易编写非阻塞的TCP客户端和服务器。</p>
</div>
<div class="sect2">
<h3 id="_创建_tcp_服务端">创建 TCP 服务端</h3>
<div class="paragraph">
<p>最简单地使用所有默认配置项创建 TCP 服务端的方式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server = vertx.create_net_server()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_tcp_服务端">配置 TCP 服务端</h3>
<div class="paragraph">
<p>若您不想使用默认配置，可以在创建时通过传入一个 <code><a href="../dataobjects.html#NetServerOptions">NetServerOptions</a></code>
实例来配置服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'port' =&gt; 4321
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_启动服务端监听">启动服务端监听</h3>
<div class="paragraph">
<p>要告诉服务端监听传入的请求，您可以使用其中一个 <code><a href="../../yardoc/Vertx/NetServer.html#listen-instance_method">listen</a></code>
方法。</p>
</div>
<div class="paragraph">
<p>让服务器监听配置项指定的主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server = vertx.create_net_server()
server.listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在调用 <code>listen</code> 方法时指定主机和端口号，忽略配置项中的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server = vertx.create_net_server()
server.listen(1234, "localhost")</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认主机名是 <code>0.0.0.0</code>，它表示：监听所有可用地址。默认端口号是 <code>0</code>，这也是一个特殊值，它告诉服务器随机选择并监听一个本地没有被占用的端口。</p>
</div>
<div class="paragraph">
<p>实际的绑定也是异步的，因此服务器在调用了 <code>listen</code> 方法的一段时间之后才会实际开始监听。</p>
</div>
<div class="paragraph">
<p>若您希望在服务器实际监听时收到通知，您可以在调用 <code>listen</code> 方法时提供一个处理器。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server = vertx.create_net_server()
server.listen(1234, "localhost") { |res_err,res|
  if (res_err == nil)
    puts "Server is now listening!"
  else
    puts "Failed to bind!"
  end
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_监听随机端口">监听随机端口</h3>
<div class="paragraph">
<p>若设置监听端口为`0`，服务器将随机寻找一个没有使用的端口来监听。</p>
</div>
<div class="paragraph">
<p>可以调用 <code><a href="../../yardoc/Vertx/NetServer.html#actual_port-instance_method">actualPort</a></code> 方法来获得服务器实际监听的端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server = vertx.create_net_server()
server.listen(0, "localhost") { |res_err,res|
  if (res_err == nil)
    puts "Server is now listening on actual port: #{server.actual_port()}"
  else
    puts "Failed to bind!"
  end
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_接收传入连接的通知">接收传入连接的通知</h3>
<div class="paragraph">
<p>若您想要在连接创建完时收到通知，则需要设置一个 <code><a href="../../yardoc/Vertx/NetServer.html#connect_handler-instance_method">connectHandler</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server = vertx.create_net_server()
server.connect_handler() { |socket|
  # Handle the connection in here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当连接成功时，您可以在回调函数中处理得到的 <code><a href="../../yardoc/Vertx/NetSocket.html">NetSocket</a></code> 实例。</p>
</div>
<div class="paragraph">
<p>这是一个代表了实际连接的套接字接口，它允许您读取和写入数据、以及执行各种其他操作，如关闭 Socket。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从socket读取数据">从Socket读取数据</h3>
<div class="paragraph">
<p>您可以在Socket上调用 <code><a href="../../yardoc/Vertx/NetSocket.html#handler-instance_method">handler</a></code> 方法来设置用于读取数据的处理器。</p>
</div>
<div class="paragraph">
<p>每次 Socket 接收到数据时，会以 <code><a href="../../yardoc/Vertx/Buffer.html">Buffer</a></code> 对象为参数调用处理器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server = vertx.create_net_server()
server.connect_handler() { |socket|
  socket.handler() { |buffer|
    puts "I received some bytes: #{buffer.length()}"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_向socket中写入数据">向Socket中写入数据</h3>
<div class="paragraph">
<p>您可使用 <code><a href="../../yardoc/Vertx/NetSocket.html#write-instance_method">write</a></code> 方法写入数据到Socket：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">require 'vertx/buffer'

# Write a buffer
buffer = Vertx::Buffer.buffer().append_float(12.34).append_int(123)
socket.write(buffer)

# Write a string in UTF-8 encoding
socket.write("some data")

# Write a string using the specified encoding
socket.write("some data", "UTF-16")</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入操作是异步的，可能调用 <code>write</code> 方法返回过后一段时间才会发生。</p>
</div>
</div>
<div class="sect2">
<h3 id="_关闭处理器">关闭处理器</h3>
<div class="paragraph">
<p>若您想要在 Socket 关闭时收到通知，可以设置一个 <code><a href="../../yardoc/Vertx/NetSocket.html#close_handler-instance_method">closeHandler</a></code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">socket.close_handler() { |v|
  puts "The socket has been closed"
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理异常">处理异常</h3>
<div class="paragraph">
<p>您可以设置一个 <code><a href="../../yardoc/Vertx/NetSocket.html#exception_handler-instance_method">exceptionHandler</a></code> 用以在发生任何异常的时候接收异常信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_写处理器">Event Bus 写处理器</h3>
<div class="paragraph">
<p>每个 Socket 会自动在Event Bus中注册一个处理器，当这个处理器中收到任意 <code>Buffer</code> 时，它会将数据写入到 Socket。</p>
</div>
<div class="paragraph">
<p>这意味着您可以通过向这个地址发送 <code>Buffer</code> 的方式，从不同的 Verticle 甚至是不同的 Vert.x 实例中向指定的 Socket 发送数据。</p>
</div>
<div class="paragraph">
<p>处理器的地址由 <code><a href="../../yardoc/Vertx/NetSocket.html#write_handler_id-instance_method">writeHandlerID</a></code> 方法提供。</p>
</div>
</div>
<div class="sect2">
<h3 id="_本地和远程地址">本地和远程地址</h3>
<div class="paragraph">
<p>您可以通过 <code><a href="../../yardoc/Vertx/NetSocket.html#local_address-instance_method">localAddress</a></code> 方法获取 <code><a href="../../yardoc/Vertx/NetSocket.html">NetSocket</a></code> 的本地地址，</p>
</div>
<div class="paragraph">
<p>通过 <code><a href="../../yardoc/Vertx/NetSocket.html#remote_address-instance_method">remoteAddress</a></code> 方法获取 <code><a href="../../yardoc/Vertx/NetSocket.html">NetSocket</a></code> 的远程地址（即连接的另一端的地址）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</h3>
<div class="paragraph">
<p>您可以直接通过 <code><a href="../../yardoc/Vertx/NetSocket.html#send_file-instance_method">sendFile</a></code> 方法将文件和 classpath 中的资源写入Socket。
这种做法是非常高效的，它可以被操作系统内核直接处理。</p>
</div>
<div class="paragraph">
<p>请阅读 <a href="#classpath">从 Classpath 访问文件</a> 章节了解类路径的限制或禁用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">socket.send_file("myfile.dat")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_流式的socket">流式的Socket</h3>
<div class="paragraph">
<p><code><a href="../../yardoc/Vertx/NetSocket.html">NetSocket</a></code> 接口继承了 <code><a href="../../yardoc/Vertx/ReadStream.html">ReadStream</a></code> 和
<code><a href="../../yardoc/Vertx/WriteStream.html">WriteStream</a></code> 接口，因此您可以将它套用（pump）到其他的读写流上。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅 <a href="#streams">流和管道</a>  章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</h3>
<div class="paragraph">
<p>一个非SSL/TLS连接可以通过 <code><a href="../../yardoc/Vertx/NetSocket.html#upgrade_to_ssl-instance_method">upgradeToSsl</a></code> 方法升级到SSL/TLS连接。</p>
</div>
<div class="paragraph">
<p>必须为服务器或客户端配置SSL/TLS才能正常工作。请参阅 <a href="#ssl">SSL/TLS</a> 章节来获取详细信息。
for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_关闭_tcp_服务端">关闭 TCP 服务端</h3>
<div class="paragraph">
<p>您可以调用 <code><a href="../../yardoc/Vertx/NetServer.html#close-instance_method">close</a></code> 方法关闭服务端。关闭操作将关闭所有打开的连接并释放所有服务端资源。</p>
</div>
<div class="paragraph">
<p>关闭操作也是异步的，可能直到方法调用返回过后一段时间才会实际关闭。若您想在实际关闭完成时收到通知，那么您可以传递一个处理器。</p>
</div>
<div class="paragraph">
<p>当关闭操作完成后，绑定的处理器将被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">server.close() { |res_err,res|
  if (res_err == nil)
    puts "Server is now closed"
  else
    puts "close failed"
  end
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle中的自动清理">Verticle中的自动清理</h3>
<div class="paragraph">
<p>若您在 Verticle 内创建了 TCP 服务端和客户端，它们将会在Verticle 撤销时自动被关闭。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</h3>
<div class="paragraph">
<p>任意一个 TCP 服务端中的处理器总是在相同的 Event Loop 线程上执行。</p>
</div>
<div class="paragraph">
<p>这意味着如果您在多核的服务器上运行，并且只部署了一个实例，那么您的服务器上最多只能使用一个核。</p>
</div>
<div class="paragraph">
<p>为了利用更多的服务器核，您将需要部署更多的服务器实例。</p>
</div>
<div class="paragraph">
<p>您可以在代码中以编程方式实例化更多（Server的）实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># Create a few instances so we can utilise cores

(0...10).each do |i|
  server = vertx.create_net_server()
  server.connect_handler() { |socket|
    socket.handler() { |buffer|
      # Just echo back the data
      socket.write(buffer)
    }
  }
  server.listen(1234, "localhost")
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用的是 Verticle，您可以通过在命令行上使用 <code>-instances</code> 选项来简单部署更多的服务器实例：</p>
</div>
<div class="paragraph">
<p>vertx run com.mycompany.MyVerticle -instances 10</p>
</div>
<div class="paragraph">
<p>或者使用编程方式部署您的 Verticle 时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'instances' =&gt; 10
}
vertx.deploy_verticle("com.mycompany.MyVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦您这样做，您将发现echo服务器在功能上与之前相同，但是服务器上的所有核都可以被利用，并且可以处理更多的工作。</p>
</div>
<div class="paragraph">
<p>在这一点上，您可能会问自己：<strong>如何让多台服务器在同一主机和端口上侦听？尝试部署一个以上的实例时真的不会遇到端口冲突吗？</strong></p>
</div>
<div class="paragraph">
<p><strong>Vert.x在这里有一点魔法。</strong></p>
</div>
<div class="paragraph">
<p>当您在与现有服务器相同的主机和端口上部署另一个服务器实例时，实际上它并不会尝试创建在同一主机/端口上侦听的新服务器实例。</p>
</div>
<div class="paragraph">
<p>相反，它内部仅仅维护一个服务器实例。当传入新的连接时，它以轮询的方式将其分发给任意一个连接处理器处理。</p>
</div>
<div class="paragraph">
<p>因此，Vert.x TCP 服务端可以水平扩展到多个核，并且每个实例保持单线程环境不变。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建_tcp_客户端">创建 TCP 客户端</h3>
<div class="paragraph">
<p>使用所有默认选项创建 TCP 客户端的最简单方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">client = vertx.create_net_client()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_tcp_客户端">配置 TCP 客户端</h3>
<div class="paragraph">
<p>如果您不想使用默认值，则可以在创建实例时传入 <code><a href="../dataobjects.html#NetClientOptions">NetClientOptions</a></code>
给客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'connectTimeout' =&gt; 10000
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建连接">创建连接</h3>
<div class="paragraph">
<p>您可以使用 <code><a href="../../yardoc/Vertx/NetClient.html#connect-instance_method">connect</a></code> ,
方法创建到服务器的连接。请指定服务器的端口和主机，以及用于处理
<code><a href="../../yardoc/Vertx/NetSocket.html">NetSocket</a></code> 的处理器。当连接成功或失败时处理器会被调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'connectTimeout' =&gt; 10000
}
client = vertx.create_net_client(options)
client.connect(4321, "localhost") { |res_err,res|
  if (res_err == nil)
    puts "Connected!"
    socket = res
  else
    puts "Failed to connect: #{res_err.get_message()}"
  end
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置连接重试">配置连接重试</h3>
<div class="paragraph">
<p>可以将客户端配置为在无法连接的情况下自动重试。
这是通过 <code><a href="../dataobjects.html#NetClientOptions#set_reconnect_interval-instance_method">reconnectInterval</a></code> 和
<code><a href="../dataobjects.html#NetClientOptions#set_reconnect_attempts-instance_method">reconnectAttempts</a></code> 方法配置的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>注意：目前如果连接失效，Vert.x将不尝试重新连接。重新连接尝试和时间间隔仅适用于创建初始连接。</strong>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'reconnectAttempts' =&gt; 10,
  'reconnectInterval' =&gt; 500
}

client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，多个连接尝试是被禁用的。</p>
</div>
</div>
<div class="sect2">
<h3 id="logging_network_activity">记录网络活动</h3>
<div class="paragraph">
<p>网络活动可以被记录下来，用于调试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'logActivity' =&gt; true
}

server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'logActivity' =&gt; true
}

client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Netty 使用 <code>DEBUG</code> 级别和 <code>io.netty.handler.logging.LoggingHandler</code> 名称来记录网络活动。使用网络活动记录时，需要注意以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日志的记录是由Netty而不是Vert.x的日志来执行</p>
</li>
<li>
<p>这个功能不能用于生产环境</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您应该阅读 <a href="#netty-logging">Netty 日志记录</a> 章节来了解详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="ssl">配置服务端和客户端以使用SSL/TLS</h3>
<div class="paragraph">
<p>TCP 客户端和服务端可以通过配置来使用 <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">TLS（传输层安全性协议）</a>
。早期版本的TLS被称为SSL。</p>
</div>
<div class="paragraph">
<p>无论是否使用SSL/TLS，服务器和客户端的API都是相同的。通过创建客户端/服务器时使用的 <code><a href="../dataobjects.html#NetClientOptions">NetClientOptions</a></code> 或 <code><a href="../dataobjects.html#NetServerOptions">NetServerOptions</a></code> 来启用TLS/SSL。</p>
</div>
<div class="sect3">
<h4 id="_在服务端启用ssl_tls">在服务端启用SSL/TLS</h4>
<div class="paragraph">
<p>您需要设置 <code><a href="../dataobjects.html#NetServerOptions#set_ssl-instance_method">ssl</a></code> 配置项来启用 SSL/TLS。</p>
</div>
<div class="paragraph">
<p>默认是禁用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_指定服务端的密钥_证书">指定服务端的密钥/证书</h4>
<div class="paragraph">
<p>SSL/TLS 服务端通常向客户端提供证书，以便验证服务端的身份。</p>
</div>
<div class="paragraph">
<p>可以通过以下几种方式为服务端配置证书/密钥：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含证书和私钥的Java密钥库位置。</p>
</div>
<div class="paragraph">
<p>可以使用 JDK 附带的 <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
实用程序来管理Java密钥存储。</p>
</div>
<div class="paragraph">
<p>还应提供密钥存储的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; {
    'path' =&gt; "/path/to/your/server-keystore.jks",
    'password' =&gt; "password-of-your-keystore"
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以自己读取密钥库到一个`Buffer`，并将它直接提供给 <code>JksOptions</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myKeyStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/server-keystore.jks")
jksOptions = {
  'value' =&gt; myKeyStoreAsABuffer,
  'password' =&gt; "password-of-your-keystore"
}
options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; jksOptions
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为`.pfx`或`.p12`扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'pfxKeyCertOptions' =&gt; {
    'path' =&gt; "/path/to/your/server-keystore.pfx",
    'password' =&gt; "password-of-your-keystore"
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myKeyStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/server-keystore.pfx")
pfxOptions = {
  'value' =&gt; myKeyStoreAsABuffer,
  'password' =&gt; "password-of-your-keystore"
}
options = {
  'ssl' =&gt; true,
  'pfxKeyCertOptions' =&gt; pfxOptions
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外一种分别提供服务器私钥和证书的方法是使用`.pem`文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'pemKeyCertOptions' =&gt; {
    'keyPath' =&gt; "/path/to/your/server-key.pem",
    'certPath' =&gt; "/path/to/your/server-cert.pem"
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myKeyAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/server-key.pem")
myCertAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/server-cert.pem")
pemOptions = {
  'keyValue' =&gt; myKeyAsABuffer,
  'certValue' =&gt; myCertAsABuffer
}
options = {
  'ssl' =&gt; true,
  'pemKeyCertOptions' =&gt; pemOptions
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS8, PKCS1 and X.509 certificates wrapped in a PEM block formats are supported.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
请记住pem的配置和私钥是不加密的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_指定服务器信任">指定服务器信任</h4>
<div class="paragraph">
<p>SSL/TLS 服务端可以使用证书颁发机构来验证客户端的身份。</p>
</div>
<div class="paragraph">
<p>证书颁发机构可通过多种方式为服务端配置。</p>
</div>
<div class="paragraph">
<p>可使用JDK随附的 <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
实用程序来管理Java 受信存储。</p>
</div>
<div class="paragraph">
<p>还应提供受信存储的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'clientAuth' =&gt; "REQUIRED",
  'trustStoreOptions' =&gt; {
    'path' =&gt; "/path/to/your/truststore.jks",
    'password' =&gt; "password-of-your-truststore"
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您可以自己读取受信存储到`Buffer`，并将它直接提供：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myTrustStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/truststore.jks")
options = {
  'ssl' =&gt; true,
  'clientAuth' =&gt; "REQUIRED",
  'trustStoreOptions' =&gt; {
    'value' =&gt; myTrustStoreAsABuffer,
    'password' =&gt; "password-of-your-truststore"
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为`.pfx`或`.p12`扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'clientAuth' =&gt; "REQUIRED",
  'pfxTrustOptions' =&gt; {
    'path' =&gt; "/path/to/your/truststore.pfx",
    'password' =&gt; "password-of-your-truststore"
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myTrustStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/truststore.pfx")
options = {
  'ssl' =&gt; true,
  'clientAuth' =&gt; "REQUIRED",
  'pfxTrustOptions' =&gt; {
    'value' =&gt; myTrustStoreAsABuffer,
    'password' =&gt; "password-of-your-truststore"
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种提供服务器证书颁发机构的方法是使用一个 <code>.pem</code> 文件列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'clientAuth' =&gt; "REQUIRED",
  'pemTrustOptions' =&gt; {
    'certPaths' =&gt; [
      "/path/to/your/server-ca.pem"
    ]
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myCaAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/server-ca.pfx")
options = {
  'ssl' =&gt; true,
  'clientAuth' =&gt; "REQUIRED",
  'pemTrustOptions' =&gt; {
    'certValues' =&gt; [
      myCaAsABuffer
    ]
  }
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端启用ssl_tls">客户端启用SSL/TLS</h4>
<div class="paragraph">
<p>客户端也可以轻松地配置为SSL。使用SSL和使用标准套接字具有完全相同的API。</p>
</div>
<div class="paragraph">
<p>若要启用 <code>NetClient</code> 上的SSL，可调用函数 <code>setSSL(true)</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_客户端受信配置">客户端受信配置</h4>
<div class="paragraph">
<p>若客户端将 <code><a href="../dataobjects.html#ClientOptionsBase#set_trust_all-instance_method">trustALl</a></code> 设置为 <code>true</code>，则客户端将信任所有服务端证书。
连接仍然会被加密，但这种模式很容易受到中间人攻击。即您无法确定您正连接到谁，请谨慎使用。默认值为`false`。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'trustAll' =&gt; true
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>若客户端没有设置 <code><a href="../dataobjects.html#ClientOptionsBase#set_trust_all-instance_method">trustAll</a></code> ，则必须配置客户端受信存储，并且受信客户端应该包含服务器的证书。</p>
</div>
<div class="paragraph">
<p>默认情况下，客户端禁用主机验证。要启用主机验证，请在客户端上设置使用的算法（目前仅支持HTTPS和LDAPS）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'hostnameVerificationAlgorithm' =&gt; "HTTPS"
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>和服务器配置相同，也可通过以下几种方式配置受信客户端：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含证书颁发机构的Java受信库的位置。</p>
</div>
<div class="paragraph">
<p>它只是一个标准的Java密钥存储，与服务器端的密钥存储相同。通过在
<code><a href="../dataobjects.html#JksOptions">jks options</a></code> 上使用 <code><a href="../dataobjects.html#JksOptions#set_path-instance_method">path</a></code>
设置客户端受信存储位置。如果服务器在连接期间提供不在客户端受信存储中的证书，则尝试连接将不会成功。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'trustStoreOptions' =&gt; {
    'path' =&gt; "/path/to/your/truststore.jks",
    'password' =&gt; "password-of-your-truststore"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>它也支持`Buffer`的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myTrustStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/truststore.jks")
options = {
  'ssl' =&gt; true,
  'trustStoreOptions' =&gt; {
    'value' =&gt; myTrustStoreAsABuffer,
    'password' =&gt; "password-of-your-truststore"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为`.pfx`或`.p12`扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'pfxTrustOptions' =&gt; {
    'path' =&gt; "/path/to/your/truststore.pfx",
    'password' =&gt; "password-of-your-truststore"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myTrustStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/truststore.pfx")
options = {
  'ssl' =&gt; true,
  'pfxTrustOptions' =&gt; {
    'value' =&gt; myTrustStoreAsABuffer,
    'password' =&gt; "password-of-your-truststore"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种提供服务器证书颁发机构的方法是使用一个`.pem`文件列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'pemTrustOptions' =&gt; {
    'certPaths' =&gt; [
      "/path/to/your/ca-cert.pem"
    ]
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myTrustStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/ca-cert.pem")
options = {
  'ssl' =&gt; true,
  'pemTrustOptions' =&gt; {
    'certValues' =&gt; [
      myTrustStoreAsABuffer
    ]
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_指定客户端的密钥_证书">指定客户端的密钥/证书</h4>
<div class="paragraph">
<p>如果服务器需要客户端认证，那么当连接时，客户端必须向服务器提供自己的证书。可通过以下几种方式配置客户端：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含密钥和证书的Java 密钥库的位置，它只是一个常规的Java 密钥存储。使用 <code><a href="../dataobjects.html#JksOptions">jks options</a></code> 上的功能路径设置客户端密钥库位置 <code><a href="../dataobjects.html#JksOptions#set_path-instance_method">path</a></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; {
    'path' =&gt; "/path/to/your/client-keystore.jks",
    'password' =&gt; "password-of-your-keystore"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myKeyStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/client-keystore.jks")
jksOptions = {
  'value' =&gt; myKeyStoreAsABuffer,
  'password' =&gt; "password-of-your-keystore"
}
options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; jksOptions
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为`.pfx`或`.p12`扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'pfxKeyCertOptions' =&gt; {
    'path' =&gt; "/path/to/your/client-keystore.pfx",
    'password' =&gt; "password-of-your-keystore"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myKeyStoreAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/client-keystore.pfx")
pfxOptions = {
  'value' =&gt; myKeyStoreAsABuffer,
  'password' =&gt; "password-of-your-keystore"
}
options = {
  'ssl' =&gt; true,
  'pfxKeyCertOptions' =&gt; pfxOptions
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种单独提供服务器私钥和证书的方法是使用 <code>.pem</code> 文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'pemKeyCertOptions' =&gt; {
    'keyPath' =&gt; "/path/to/your/client-key.pem",
    'certPath' =&gt; "/path/to/your/client-cert.pem"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myKeyAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/client-key.pem")
myCertAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/client-cert.pem")
pemOptions = {
  'keyValue' =&gt; myKeyAsABuffer,
  'certValue' =&gt; myCertAsABuffer
}
options = {
  'ssl' =&gt; true,
  'pemKeyCertOptions' =&gt; pemOptions
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住 <code>pem</code> 的配置和私钥是不加密的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_用于测试和开发目的的自签名证书">用于测试和开发目的的自签名证书</h4>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
不要在生产设置中使用，这里生成的密钥非常不安全。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在运行单元/集成测试或是运行开发版的应用程序时都经常需要自签名证书。</p>
</div>
<div class="paragraph">
<p><code><a href="../../yardoc/Vertx/SelfSignedCertificate.html">SelfSignedCertificate</a></code> 可用于提供自签名PEM证书，并可以提供
give <code><a href="unavailable">KeyCertOptions</a></code> 和 <code><a href="unavailable">TrustOptions</a></code> configurations 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">require 'vertx/self_signed_certificate'
certificate = Vertx::SelfSignedCertificate.create()

serverOptions = {
  'ssl' =&gt; true,
  'keyCertOptions' =&gt; certificate.key_cert_options(),
  'trustOptions' =&gt; certificate.trust_options()
}

server = vertx.create_net_server(serverOptions).connect_handler() { |socket|
  socket.write("Hello!").end()
}.listen(1234, "localhost")

clientOptions = {
  'ssl' =&gt; true,
  'keyCertOptions' =&gt; certificate.key_cert_options(),
  'trustOptions' =&gt; certificate.trust_options()
}

client = vertx.create_net_client(clientOptions)
client.connect(1234, "localhost") { |ar_err,ar|
  if (ar_err == nil)
    ar.handler() { |buffer|
      puts buffer
    }
  else
    STDERR.puts "Woops: #{ar_err.get_message()}"
  end
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户端也可配置为信任所有证书：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">clientOptions = {
  'ssl' =&gt; true,
  'trustAll' =&gt; true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>自签名证书也适用于其他基于TCP的协议，如HTTPS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">require 'vertx/self_signed_certificate'
certificate = Vertx::SelfSignedCertificate.create()

vertx.create_http_server({
  'ssl' =&gt; true,
  'keyCertOptions' =&gt; certificate.key_cert_options(),
  'trustOptions' =&gt; certificate.trust_options()
}).request_handler() { |req|
  req.response().end("Hello!")
}.listen(8080)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_待撤销证书颁发机构">待撤销证书颁发机构</h4>
<div class="paragraph">
<p>可以通过配置证书吊销列表（CRL）来吊销不再被信任的证书机构。 <code><a href="../dataobjects.html#NetClientOptions#add_crl_path-instance_method">crlPath</a></code> 配置了使用的CRL：
the crl list to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'trustStoreOptions' =&gt; trustOptions,
  'crlPaths' =&gt; [
    "/path/to/your/crl.pem"
  ]
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过`Buffer`来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">myCrlAsABuffer = vertx.file_system().read_file_blocking("/path/to/your/crl.pem")
options = {
  'ssl' =&gt; true,
  'trustStoreOptions' =&gt; trustOptions,
  'crlValues' =&gt; [
    myCrlAsABuffer
  ]
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置密码套件">配置密码套件</h4>
<div class="paragraph">
<p>默认情况下，TLS配置将使用运行Vert.x的JVM 密码套件，该密码套件可以配置一套启用的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; keyStoreOptions,
  'enabledCipherSuites' =&gt; [
    "ECDHE-RSA-AES128-GCM-SHA256",
    "ECDHE-ECDSA-AES128-GCM-SHA256",
    "ECDHE-RSA-AES256-GCM-SHA384",
    "CDHE-ECDSA-AES256-GCM-SHA384"
  ]
}
server = vertx.create_net_server(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>密码套件可在 <code><a href="../dataobjects.html#NetServerOptions">NetServerOptions</a></code> 或 <code><a href="../dataobjects.html#NetClientOptions">NetClientOptions</a></code> 配置项中指定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置tls协议版本">配置TLS协议版本</h4>
<div class="paragraph">
<p>默认情况下，TLS配置将使用以下协议版本：SSLv2Hello、TLSv1、TLSv1.1 和 TLSv1.2。 协议版本可以通过显式添加启用协议进行配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">Code not translatable</code></pre>
</div>
</div>
<div class="paragraph">
<p>协议版本可在 <code><a href="../dataobjects.html#NetServerOptions">NetServerOptions</a></code> 或 <code><a href="../dataobjects.html#NetClientOptions">NetClientOptions</a></code> 配置项中指定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ssl引擎">SSL引擎</h4>
<div class="paragraph">
<p>引擎实现可以配置为使用 <a href="https://www.openssl.org">OpenSSL</a> 而不是JDK实现（来支持SSL）。 OpenSSL提供比JDK引擎更好的性能和CPU使用率、以及JDK版本独立性。</p>
</div>
<div class="paragraph">
<p>引擎选项可使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当 <code><a href="../dataobjects.html#TCPSSLOptions#get_ssl_engine_options-instance_method">getSslEngineOptions</a></code> 被设置时，使用该选项</p>
</li>
<li>
<p>否则使用 <code><a href="../dataobjects.html#JdkSSLEngineOptions">JdkSSLEngineOptions</a></code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># Use JDK SSL engine
options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; keyStoreOptions
}

# Use JDK SSL engine explicitly
options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; keyStoreOptions,
  'jdkSslEngineOptions' =&gt; {
  }
}

# Use OpenSSL engine
options = {
  'ssl' =&gt; true,
  'keyStoreOptions' =&gt; keyStoreOptions,
  'openSslEngineOptions' =&gt; {
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_server_name_indication_sni">Server Name Indication (SNI)</h4>
<div class="paragraph">
<p>Server Name Indication (SNI) is a TLS extension by which a client specifies a hostname attempting to connect: during
the TLS handshake the client gives a server name and the server can use it to respond with a specific certificate
for this server name instead of the default deployed certificate.
If the server requires client authentication the server can use a specific trusted CA certificate depending on the
indicated server name.</p>
</div>
<div class="paragraph">
<p>When SNI is active the server uses</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the certificate CN or SAN DNS (Subject Alternative Name with DNS) to do an exact match, e.g <code>www.example.com</code></p>
</li>
<li>
<p>the certificate CN or SAN DNS certificate to match a wildcard name, e.g <code>*.example.com</code></p>
</li>
<li>
<p>otherwise the first certificate when the client does not present a server name or the presented server name cannot be matched</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the server additionally requires client authentication:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if <code><a href="../dataobjects.html#JksOptions">JksOptions</a></code> were used to set the trust options
(<code><a href="../dataobjects.html#NetServerOptions#set_trust_options-instance_method">options</a></code>) then an exact match with the trust store
alias is done</p>
</li>
<li>
<p>otherwise the available CA certificates are used in the same way as if no SNI is in place</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can enable SNI on the server by setting <code><a href="../dataobjects.html#NetServerOptions#set_sni-instance_method">sni</a></code> to <code>true</code> and
configured the server with multiple key/certificate pairs.</p>
</div>
<div class="paragraph">
<p>Java KeyStore files or PKCS12 files can store multiple key/cert pairs out of the box.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">keyCertOptions = {
  'path' =&gt; "keystore.jks",
  'password' =&gt; "wibble"
}

netServer = vertx.create_net_server({
  'keyStoreOptions' =&gt; keyCertOptions,
  'ssl' =&gt; true,
  'sni' =&gt; true
})</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../dataobjects.html#PemKeyCertOptions">PemKeyCertOptions</a></code> can be configured to hold multiple entries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">keyCertOptions = {
  'keyPaths' =&gt; ["default-key.pem", "host1-key.pem", "etc..."],
  'certPaths' =&gt; ["default-cert.pem", "host2-key.pem", "etc..."]
}

netServer = vertx.create_net_server({
  'pemKeyCertOptions' =&gt; keyCertOptions,
  'ssl' =&gt; true,
  'sni' =&gt; true
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client implicitly sends the connecting host as an SNI server name for Fully Qualified Domain Name (FQDN).</p>
</div>
<div class="paragraph">
<p>You can provide an explicit server name when connecting a socket</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">client = vertx.create_net_client({
  'trustStoreOptions' =&gt; trustOptions,
  'ssl' =&gt; true
})

# Connect to 'localhost' and present 'server.name' server name
client.connect(1234, "localhost", "server.name") { |res_err,res|
  if (res_err == nil)
    puts "Connected!"
    socket = res
  else
    puts "Failed to connect: #{res_err.get_message()}"
  end
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can be used for different purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>present a server name different than the server host</p>
</li>
<li>
<p>present a server name while connecting to an IP</p>
</li>
<li>
<p>force to present a server name when using shortname</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_应用层协议协商_alpn">应用层协议协商 (ALPN)</h4>
<div class="paragraph">
<p>ALPN(Application-Layer Protocol Negotiation)是应用层协议协商的TLS扩展，它被HTTP/2使用：在TLS握手期时，客户端给出其接受的应用协议列表，之后服务器使用它所支持的协议响应。</p>
</div>
<div class="paragraph">
<p>If you are using Java 9, you are fine and you can use HTTP/2 out of the box without extra steps.</p>
</div>
<div class="paragraph">
<p>标准的Java 8不支持ALPN，所以ALPN应该通过其他方式启用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OpenSSL支持</p>
</li>
<li>
<p>Jetty-ALPN支持</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>引擎选项可使用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当 <code><a href="../dataobjects.html#TCPSSLOptions#get_ssl_engine_options-instance_method">getSslEngineOptions</a></code> 被设置时，使用该选项</p>
</li>
<li>
<p>JDK中ALPN可用时使用 <code><a href="../dataobjects.html#JdkSSLEngineOptions">JdkSSLEngineOptions</a></code></p>
</li>
<li>
<p>OpenSSL中ALPN可用时使用 <code><a href="../dataobjects.html#OpenSSLEngineOptions">OpenSSLEngineOptions</a></code></p>
</li>
<li>
<p>否则失败</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_openssl_alpn支持">OpenSSL ALPN支持</h5>
<div class="paragraph">
<p>OpenSSL提供了原生的ALPN支持。</p>
</div>
<div class="paragraph">
<p>OpenSSL需要配置 <code><a href="../dataobjects.html#TCPSSLOptions#set_open_ssl_engine_options-instance_method">openSslEngineOptions</a></code>
并在类路径上使用 <a href="http://netty.io/wiki/forked-tomcat-native.html">netty-tcnative</a> 的jar库。依赖于tcnative的实现它需要OpenSSL安装在您的操作系统中。</p>
</div>
</div>
<div class="sect4">
<h5 id="_jetty_alpn支持">Jetty-ALPN支持</h5>
<div class="paragraph">
<p>Jetty-ALPN是一个小型的jar，它覆盖了几种Java 8发行版用以支持ALPN。</p>
</div>
<div class="paragraph">
<p>JVM必须将 <code>alpn-boot-${version}.jar</code> 放在它的 <code>boot classpath</code> 中启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-Xbootclasspath/p:/path/to/alpn-boot${version}.jar</pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>${version}</code> 取决于JVM的版本，如 <strong>OpenJDK 1.8.0u74</strong> 中的 <strong>8.1.7.v20160121</strong>。这个完整列表可以在 <a href="http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html">Jetty-ALPN page</a>
页面上找到。</p>
</div>
<div class="paragraph">
<p>这种方法主要缺点是ALPN的实现版本依赖于JVM的版本。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，可以使用 <em><a href="https://github.com/jetty-project/jetty-alpn-agent">Jetty ALPN agent</a></em> 。agent是一个JVM代理，它会为运行它的JVM选择正确的ALPN版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-javaagent:/path/to/alpn/agent</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_客户端连接使用代理">客户端连接使用代理</h3>
<div class="paragraph">
<p><code><a href="../../yardoc/Vertx/NetClient.html">NetClient</a></code> 支持HTTP/1.x <strong>CONNECT</strong>、<strong>SOCKS4a</strong> 或 <strong>SOCKS5</strong> 代理。</p>
</div>
<div class="paragraph">
<p>代理可以在 <code><a href="../dataobjects.html#NetClientOptions">NetClientOptions</a></code> 内设置
<code><a href="../dataobjects.html#ProxyOptions">ProxyOptions</a></code> 来配置代理类型、主机名、端口、可选的用户名和密码。</p>
</div>
<div class="paragraph">
<p>以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">options = {
  'proxyOptions' =&gt; {
    'type' =&gt; "SOCKS5",
    'host' =&gt; "localhost",
    'port' =&gt; 1080,
    'username' =&gt; "username",
    'password' =&gt; "secret"
  }
}
client = vertx.create_net_client(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>DNS 解析总是在代理服务器上完成解析，为了实现 SOCKS4 客户端的功能，需要先在本地解析 DNS 地址。</p>
</div>
</div>
</div>
</div>

        

        
          <div id="footer">
            <div id="footer-text">
              
                上次更新时间 2018-09-04 18:06:08 CST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/">Home</a></li>
          <li><a href="https://vertx.tk/download/">Download</a></li>
          <li><a href="https://vertx.tk/docs/">Documentation</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">Wiki</a></li>
          <li><a href="https://vertx.tk/blog/">Blog</a></li>
          <li><a href="https://vertx.tk/vertx2/" class="vertx-2-link">Vert.x 2</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/community/">Help &amp; Contributors</a></li>
          <li><a href="https://vertx.tk/materials/">Learning materials</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual-licensed under the <a href="http://www.eclipse.org/legal/epl-v20.html">Eclipse Public License 2.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="https://vertx.tk/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="https://vertx.tk/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="https://vertx.tk/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://vertx.tk/javascripts/bootstrap.min.js"></script>
<script src="https://vertx.tk/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="https://vertx.tk/javascripts/sidebar.js"></script>


<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});
</script>
</body>
</html>

