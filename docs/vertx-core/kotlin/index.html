<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vert.x Core 手册 - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="https://okou19900722.gitee.io/cn.vertx.tk//stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="https://okou19900722.gitee.io/cn.vertx.tk//stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="https://okou19900722.gitee.io/cn.vertx.tk//javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="https://okou19900722.gitee.io/cn.vertx.tk//assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="https://okou19900722.gitee.io/cn.vertx.tk//feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
  <style>
    .page-link-to-github {
      position: relative;
      z-index: 1;
      display: inline-block;
      border: 1px solid #782B90;
      border-radius: 5px;
      color: #782B90;
      font-size: 12px;
      padding: 4px 10px;
      text-decoration: none;
      background-color: #ffffff;
    }
    .page-link-to-github:hover {
      color: #ffffff;
      border-color: #ffffff;
      background-color: #782B90;
    }

    .page-link-to-github .github-icon {
      position: absolute;
      display: inline-block;
      width: 20px;
      height: 20px;
      /*background-position: -50px 0*/
      background: url('https://okou19900722.gitee.io/cn.vertx.tk//assets/github.png') no-repeat 0 0;
    }

    @media (-webkit-min-device-pixel-ratio: 2),(min-resolution:192dpi) {
      .page-link-to-github .github-icon {
        background-image:url('https://okou19900722.gitee.io/cn.vertx.tk//assets/github@2x.png');
        background-size: 150px auto
      }
    }

    .page-link-to-github:hover .github-icon {
      /*background-position: 0 0*/
      background-position: -100px 0
    }
    .text {
      text-decoration: underline
    }
    .page-link-to-github .text {
      padding-left: 27px
    }
    .text {
      padding-right: 8px
    }
    .page-link-to-github {
      float: right;
      top: 4px
    }

  </style>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://okou19900722.gitee.io/cn.vertx.tk//" class="navbar-brand"><img alt="Brand" src="https://okou19900722.gitee.io/cn.vertx.tk//assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="https://vertx.io">官网</a></li>
        <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//download/">下载</a></li>
        <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//docs/">文档</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
        <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//community/">社区</a></li>
        <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//materials/">资料</a></li>
        <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//blog/">博客</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>Vert.x Core 手册</h1>
          
        </div>
      </div>
    </div>
  </div>



<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_故事从_vert_x_开始">故事从 Vert.x 开始</a>
<ul class="sectlevel2">
<li><a href="#_创建_vertx_对象时指定配置项">创建 Vertx 对象时指定配置项</a></li>
<li><a href="#_创建集群模式的_vert_x_对象">创建集群模式的 Vert.x 对象</a></li>
</ul>
</li>
<li><a href="#_是流式的吗">是流式的吗？</a></li>
<li><a href="#_don_t_call_us_we_ll_call_you">Don&#8217;t call us, we&#8217;ll call you.</a></li>
<li><a href="#_不要阻塞我">不要阻塞我！</a></li>
<li><a href="#_reactor_模式和_multi_reactor_模式">Reactor 模式和 Multi-Reactor 模式</a></li>
<li><a href="#golden_rule">黄金法则：不要阻塞Event Loop</a></li>
<li><a href="#blocking_code">运行阻塞式代码</a></li>
<li><a href="#_异步协调">异步协调</a>
<ul class="sectlevel2">
<li><a href="#_并发合并">并发合并</a></li>
<li><a href="#_顺序合并">顺序合并</a></li>
</ul>
</li>
<li><a href="#_verticles">Verticles</a>
<ul class="sectlevel2">
<li><a href="#_writing_verticles">Writing Verticles</a></li>
<li><a href="#_verticle_种类">Verticle 种类</a></li>
<li><a href="#_standard_verticles">Standard verticles</a></li>
<li><a href="#worker_verticles">Worker verticles</a></li>
<li><a href="#_编程方式部署verticle">编程方式部署Verticle</a></li>
<li><a href="#_verticle名称到factory的映射规则">Verticle名称到Factory的映射规则</a></li>
<li><a href="#_如何定位verticle_factory">如何定位Verticle Factory？</a></li>
<li><a href="#_等待部署完成">等待部署完成</a></li>
<li><a href="#_撤销verticle">撤销Verticle</a></li>
<li><a href="#_设置_verticle_实例数">设置 Verticle 实例数</a></li>
<li><a href="#_verticle_隔离组">Verticle 隔离组</a></li>
<li><a href="#_高可用性">高可用性</a></li>
<li><a href="#_从命令行运行verticle">从命令行运行Verticle</a></li>
<li><a href="#_退出_vert_x_环境">退出 Vert.x 环境</a></li>
<li><a href="#_context_对象">Context 对象</a></li>
<li><a href="#_执行周期性_延迟性操作">执行周期性/延迟性操作</a></li>
<li><a href="#_verticle_worker_pool">Verticle worker pool</a></li>
</ul>
</li>
<li><a href="#event_bus">The Event Bus</a>
<ul class="sectlevel2">
<li><a href="#_基本概念">基本概念</a></li>
<li><a href="#_event_bus_api">Event Bus API</a></li>
<li><a href="#_verticle_中的自动清理">Verticle 中的自动清理</a></li>
</ul>
</li>
<li><a href="#_配置_event_bus">配置 Event Bus</a></li>
<li><a href="#_json">JSON</a>
<ul class="sectlevel2">
<li><a href="#_builders">Builders</a></li>
<li><a href="#_postscript_operator_overloading">Postscript operator overloading</a></li>
</ul>
</li>
<li><a href="#_buffers">Buffers</a>
<ul class="sectlevel2">
<li><a href="#_创建_buffer">创建 Buffer</a></li>
<li><a href="#_向buffer写入数据">向Buffer写入数据</a></li>
<li><a href="#_从buffer中读取">从Buffer中读取</a></li>
<li><a href="#_使用无符号数">使用无符号数</a></li>
<li><a href="#_buffer长度">Buffer长度</a></li>
<li><a href="#_拷贝buffer">拷贝Buffer</a></li>
<li><a href="#_裁剪buffer">裁剪Buffer</a></li>
<li><a href="#_buffer_重用">Buffer 重用</a></li>
</ul>
</li>
<li><a href="#_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_tcp_服务端">创建 TCP 服务端</a></li>
<li><a href="#_配置_tcp_服务端">配置 TCP 服务端</a></li>
<li><a href="#_启动服务端监听">启动服务端监听</a></li>
<li><a href="#_监听随机端口">监听随机端口</a></li>
<li><a href="#_接收传入连接的通知">接收传入连接的通知</a></li>
<li><a href="#_从socket读取数据">从Socket读取数据</a></li>
<li><a href="#_向socket中写入数据">向Socket中写入数据</a></li>
<li><a href="#_关闭处理器">关闭处理器</a></li>
<li><a href="#_处理异常">处理异常</a></li>
<li><a href="#_event_bus_写处理器">Event Bus 写处理器</a></li>
<li><a href="#_本地和远程地址">本地和远程地址</a></li>
<li><a href="#_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</a></li>
<li><a href="#_流式的socket">流式的Socket</a></li>
<li><a href="#_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</a></li>
<li><a href="#_关闭_tcp_服务端">关闭 TCP 服务端</a></li>
<li><a href="#_verticle中的自动清理">Verticle中的自动清理</a></li>
<li><a href="#_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</a></li>
<li><a href="#_创建_tcp_客户端">创建 TCP 客户端</a></li>
<li><a href="#_配置_tcp_客户端">配置 TCP 客户端</a></li>
<li><a href="#_创建连接">创建连接</a></li>
<li><a href="#_配置连接重试">配置连接重试</a></li>
<li><a href="#logging_network_activity">记录网络活动</a></li>
<li><a href="#ssl">配置服务端和客户端以使用SSL/TLS</a></li>
<li><a href="#_客户端连接使用代理">客户端连接使用代理</a></li>
</ul>
</li>
<li><a href="#_编写_http_服务端和客户端">编写 HTTP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_http_服务端">创建 HTTP 服务端</a></li>
<li><a href="#_配置_http_服务端">配置 HTTP 服务端</a></li>
<li><a href="#_配置_http_2_服务端">配置 HTTP/2 服务端</a></li>
<li><a href="#_记录服务端网络活动">记录服务端网络活动</a></li>
<li><a href="#_开启服务端监听">开启服务端监听</a></li>
<li><a href="#_收到传入请求的通知">收到传入请求的通知</a></li>
<li><a href="#_处理请求">处理请求</a></li>
<li><a href="#_发回响应">发回响应</a></li>
<li><a href="#_http_压缩">HTTP 压缩</a></li>
<li><a href="#_创建_http_客户端">创建 HTTP 客户端</a></li>
<li><a href="#_记录客户端网络活动">记录客户端网络活动</a></li>
<li><a href="#_发出请求">发出请求</a></li>
<li><a href="#_处理_http_响应">处理 HTTP 响应</a></li>
<li><a href="#_客户端启用压缩">客户端启用压缩</a></li>
<li><a href="#_http_1_x_pooling_和_keep_alive">HTTP/1.x Pooling 和 Keep alive</a></li>
<li><a href="#_http_1_1_pipe_lining">HTTP/1.1 pipe-lining</a></li>
<li><a href="#_http_2_多路复用">HTTP/2 多路复用</a></li>
<li><a href="#_http_连接">HTTP 连接</a></li>
<li><a href="#_httpclient_使用说明">HttpClient 使用说明</a></li>
<li><a href="#_服务端共享">服务端共享</a></li>
<li><a href="#_使用_https">使用 HTTPS</a></li>
<li><a href="#_websockets">WebSockets</a></li>
<li><a href="#_使用_http_https_连接代理">使用 HTTP/HTTPS 连接代理</a></li>
<li><a href="#_verticle_中自动清理">Verticle 中自动清理</a></li>
</ul>
</li>
<li><a href="#_使用_vert_x_共享数据">使用 Vert.x 共享数据</a>
<ul class="sectlevel2">
<li><a href="#_本地共享map">本地共享Map</a></li>
<li><a href="#_集群范围异步map">集群范围异步Map</a></li>
<li><a href="#_集群范围锁">集群范围锁</a></li>
<li><a href="#_集群范围计数器">集群范围计数器</a></li>
</ul>
</li>
<li><a href="#_访问文件系统">访问文件系统</a>
<ul class="sectlevel2">
<li><a href="#_异步文件访问">异步文件访问</a></li>
</ul>
</li>
<li><a href="#_数据报套接字_udp">数据报套接字（UDP）</a>
<ul class="sectlevel2">
<li><a href="#_创建_datagramsocket">创建 DatagramSocket</a></li>
<li><a href="#_发送数据报包">发送数据报包</a></li>
<li><a href="#_接收数据报包">接收数据报包</a></li>
<li><a href="#_多播">多播</a></li>
</ul>
</li>
<li><a href="#_dns_客户端">DNS 客户端</a>
<ul class="sectlevel2">
<li><a href="#_lookup">lookup</a></li>
<li><a href="#_lookup4">lookup4</a></li>
<li><a href="#_lookup6">lookup6</a></li>
<li><a href="#_resolvea">resolveA</a></li>
<li><a href="#_resolveaaaa">resolveAAAA</a></li>
<li><a href="#_resolvecname">resolveCNAME</a></li>
<li><a href="#_resolvemx">resolveMX</a></li>
<li><a href="#_resolvetxt">resolveTXT</a></li>
<li><a href="#_resolvens">resolveNS</a></li>
<li><a href="#_resolvesrv">resolveSRV</a></li>
<li><a href="#_resolveptr">resolvePTR</a></li>
<li><a href="#_reverselookup">reverseLookup</a></li>
</ul>
</li>
<li><a href="#streams">流</a>
<ul class="sectlevel2">
<li><a href="#_readstream">ReadStream</a></li>
<li><a href="#_writestream">WriteStream</a></li>
<li><a href="#_泵">泵</a></li>
</ul>
</li>
<li><a href="#_记录解析器">记录解析器</a></li>
<li><a href="#_json_parser">Json Parser</a></li>
<li><a href="#_线程安全">线程安全</a></li>
<li><a href="#_metrics_spi">Metrics SPI</a></li>
<li><a href="#_osgi">OSGi</a></li>
<li><a href="#_vertx_命令行">vertx 命令行</a>
<ul class="sectlevel2">
<li><a href="#_运行_verticle">运行 Verticle</a></li>
<li><a href="#_执行打包成_fat_jar_的vert_x_应用">执行打包成 fat-jar 的Vert.x 应用</a></li>
<li><a href="#_显示vert_x的版本">显示Vert.x的版本</a></li>
<li><a href="#_其他命令">其他命令</a></li>
<li><a href="#_实时重部署">实时重部署</a></li>
</ul>
</li>
<li><a href="#_集群管理器">集群管理器</a></li>
<li><a href="#_日志记录">日志记录</a>
<ul class="sectlevel2">
<li><a href="#_配置jul日志记录">配置JUL日志记录</a></li>
<li><a href="#_使用另一个日志框架">使用另一个日志框架</a></li>
<li><a href="#_应用中记录日志">应用中记录日志</a></li>
<li><a href="#netty-logging">Netty日志记录</a></li>
<li><a href="#_故障排除">故障排除</a></li>
</ul>
</li>
<li><a href="#_主机名解析">主机名解析</a>
<ul class="sectlevel2">
<li><a href="#_故障转移">故障转移</a></li>
<li><a href="#_服务器列表轮询">服务器列表轮询</a></li>
<li><a href="#_主机映射">主机映射</a></li>
<li><a href="#_搜索域名">搜索域名</a></li>
</ul>
</li>
<li><a href="#high_Availability_and_Fail_Over">高可用和故障转移</a>
<ul class="sectlevel2">
<li><a href="#_自动故障转移">自动故障转移</a></li>
<li><a href="#_ha组">HA组</a></li>
<li><a href="#_处理网络分区_quora">处理网络分区 - Quora</a></li>
</ul>
</li>
<li><a href="#_native_transports">Native transports</a>
<ul class="sectlevel2">
<li><a href="#_native_linux_transport">Native Linux Transport</a></li>
<li><a href="#_native_bsd_transport">Native BSD Transport</a></li>
<li><a href="#_domain_sockets">Domain sockets</a></li>
</ul>
</li>
<li><a href="#_安全注意事项">安全注意事项</a>
<ul class="sectlevel2">
<li><a href="#_web_应用">Web 应用</a></li>
<li><a href="#_集群模式_event_bus_流量">集群模式 Event Bus 流量</a></li>
<li><a href="#_标准安全最佳实践">标准安全最佳实践</a></li>
</ul>
</li>
<li><a href="#_vert_x_命令行接口api">Vert.x 命令行接口API</a>
<ul class="sectlevel2">
<li><a href="#_定义阶段">定义阶段</a></li>
<li><a href="#_解析阶段">解析阶段</a></li>
<li><a href="#_查询_审问阶段">查询/审问阶段</a></li>
</ul>
</li>
<li><a href="#_the_vert_x_launcher">The vert.x Launcher</a>
<ul class="sectlevel2">
<li><a href="#Extending_the_vert_x_Launcher">扩展 Vert.x 启动器</a></li>
<li><a href="#_在_fat_jar_中使用启动器">在 fat-jar 中使用启动器</a></li>
<li><a href="#_启动器子类">启动器子类</a></li>
<li><a href="#_启动器和退出代码">启动器和退出代码</a></li>
</ul>
</li>
<li><a href="#_配置_vert_x_缓存">配置 Vert.x 缓存</a></li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_故事从_vert_x_开始">故事从 Vert.x 开始</a>
<ul class="sectlevel2">
<li><a href="#_创建_vertx_对象时指定配置项">创建 Vertx 对象时指定配置项</a></li>
<li><a href="#_创建集群模式的_vert_x_对象">创建集群模式的 Vert.x 对象</a></li>
</ul>
</li>
<li><a href="#_是流式的吗">是流式的吗？</a></li>
<li><a href="#_don_t_call_us_we_ll_call_you">Don&#8217;t call us, we&#8217;ll call you.</a></li>
<li><a href="#_不要阻塞我">不要阻塞我！</a></li>
<li><a href="#_reactor_模式和_multi_reactor_模式">Reactor 模式和 Multi-Reactor 模式</a></li>
<li><a href="#golden_rule">黄金法则：不要阻塞Event Loop</a></li>
<li><a href="#blocking_code">运行阻塞式代码</a></li>
<li><a href="#_异步协调">异步协调</a>
<ul class="sectlevel2">
<li><a href="#_并发合并">并发合并</a></li>
<li><a href="#_顺序合并">顺序合并</a></li>
</ul>
</li>
<li><a href="#_verticles">Verticles</a>
<ul class="sectlevel2">
<li><a href="#_writing_verticles">Writing Verticles</a></li>
<li><a href="#_verticle_种类">Verticle 种类</a></li>
<li><a href="#_standard_verticles">Standard verticles</a></li>
<li><a href="#worker_verticles">Worker verticles</a></li>
<li><a href="#_编程方式部署verticle">编程方式部署Verticle</a></li>
<li><a href="#_verticle名称到factory的映射规则">Verticle名称到Factory的映射规则</a></li>
<li><a href="#_如何定位verticle_factory">如何定位Verticle Factory？</a></li>
<li><a href="#_等待部署完成">等待部署完成</a></li>
<li><a href="#_撤销verticle">撤销Verticle</a></li>
<li><a href="#_设置_verticle_实例数">设置 Verticle 实例数</a></li>
<li><a href="#_verticle_隔离组">Verticle 隔离组</a></li>
<li><a href="#_高可用性">高可用性</a></li>
<li><a href="#_从命令行运行verticle">从命令行运行Verticle</a></li>
<li><a href="#_退出_vert_x_环境">退出 Vert.x 环境</a></li>
<li><a href="#_context_对象">Context 对象</a></li>
<li><a href="#_执行周期性_延迟性操作">执行周期性/延迟性操作</a></li>
<li><a href="#_verticle_worker_pool">Verticle worker pool</a></li>
</ul>
</li>
<li><a href="#event_bus">The Event Bus</a>
<ul class="sectlevel2">
<li><a href="#_基本概念">基本概念</a></li>
<li><a href="#_event_bus_api">Event Bus API</a></li>
<li><a href="#_verticle_中的自动清理">Verticle 中的自动清理</a></li>
</ul>
</li>
<li><a href="#_配置_event_bus">配置 Event Bus</a></li>
<li><a href="#_json">JSON</a>
<ul class="sectlevel2">
<li><a href="#_builders">Builders</a></li>
<li><a href="#_postscript_operator_overloading">Postscript operator overloading</a></li>
</ul>
</li>
<li><a href="#_buffers">Buffers</a>
<ul class="sectlevel2">
<li><a href="#_创建_buffer">创建 Buffer</a></li>
<li><a href="#_向buffer写入数据">向Buffer写入数据</a></li>
<li><a href="#_从buffer中读取">从Buffer中读取</a></li>
<li><a href="#_使用无符号数">使用无符号数</a></li>
<li><a href="#_buffer长度">Buffer长度</a></li>
<li><a href="#_拷贝buffer">拷贝Buffer</a></li>
<li><a href="#_裁剪buffer">裁剪Buffer</a></li>
<li><a href="#_buffer_重用">Buffer 重用</a></li>
</ul>
</li>
<li><a href="#_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_tcp_服务端">创建 TCP 服务端</a></li>
<li><a href="#_配置_tcp_服务端">配置 TCP 服务端</a></li>
<li><a href="#_启动服务端监听">启动服务端监听</a></li>
<li><a href="#_监听随机端口">监听随机端口</a></li>
<li><a href="#_接收传入连接的通知">接收传入连接的通知</a></li>
<li><a href="#_从socket读取数据">从Socket读取数据</a></li>
<li><a href="#_向socket中写入数据">向Socket中写入数据</a></li>
<li><a href="#_关闭处理器">关闭处理器</a></li>
<li><a href="#_处理异常">处理异常</a></li>
<li><a href="#_event_bus_写处理器">Event Bus 写处理器</a></li>
<li><a href="#_本地和远程地址">本地和远程地址</a></li>
<li><a href="#_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</a></li>
<li><a href="#_流式的socket">流式的Socket</a></li>
<li><a href="#_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</a></li>
<li><a href="#_关闭_tcp_服务端">关闭 TCP 服务端</a></li>
<li><a href="#_verticle中的自动清理">Verticle中的自动清理</a></li>
<li><a href="#_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</a></li>
<li><a href="#_创建_tcp_客户端">创建 TCP 客户端</a></li>
<li><a href="#_配置_tcp_客户端">配置 TCP 客户端</a></li>
<li><a href="#_创建连接">创建连接</a></li>
<li><a href="#_配置连接重试">配置连接重试</a></li>
<li><a href="#logging_network_activity">记录网络活动</a></li>
<li><a href="#ssl">配置服务端和客户端以使用SSL/TLS</a></li>
<li><a href="#_客户端连接使用代理">客户端连接使用代理</a></li>
</ul>
</li>
<li><a href="#_编写_http_服务端和客户端">编写 HTTP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_http_服务端">创建 HTTP 服务端</a></li>
<li><a href="#_配置_http_服务端">配置 HTTP 服务端</a></li>
<li><a href="#_配置_http_2_服务端">配置 HTTP/2 服务端</a></li>
<li><a href="#_记录服务端网络活动">记录服务端网络活动</a></li>
<li><a href="#_开启服务端监听">开启服务端监听</a></li>
<li><a href="#_收到传入请求的通知">收到传入请求的通知</a></li>
<li><a href="#_处理请求">处理请求</a></li>
<li><a href="#_发回响应">发回响应</a></li>
<li><a href="#_http_压缩">HTTP 压缩</a></li>
<li><a href="#_创建_http_客户端">创建 HTTP 客户端</a></li>
<li><a href="#_记录客户端网络活动">记录客户端网络活动</a></li>
<li><a href="#_发出请求">发出请求</a></li>
<li><a href="#_处理_http_响应">处理 HTTP 响应</a></li>
<li><a href="#_客户端启用压缩">客户端启用压缩</a></li>
<li><a href="#_http_1_x_pooling_和_keep_alive">HTTP/1.x Pooling 和 Keep alive</a></li>
<li><a href="#_http_1_1_pipe_lining">HTTP/1.1 pipe-lining</a></li>
<li><a href="#_http_2_多路复用">HTTP/2 多路复用</a></li>
<li><a href="#_http_连接">HTTP 连接</a></li>
<li><a href="#_httpclient_使用说明">HttpClient 使用说明</a></li>
<li><a href="#_服务端共享">服务端共享</a></li>
<li><a href="#_使用_https">使用 HTTPS</a></li>
<li><a href="#_websockets">WebSockets</a></li>
<li><a href="#_使用_http_https_连接代理">使用 HTTP/HTTPS 连接代理</a></li>
<li><a href="#_verticle_中自动清理">Verticle 中自动清理</a></li>
</ul>
</li>
<li><a href="#_使用_vert_x_共享数据">使用 Vert.x 共享数据</a>
<ul class="sectlevel2">
<li><a href="#_本地共享map">本地共享Map</a></li>
<li><a href="#_集群范围异步map">集群范围异步Map</a></li>
<li><a href="#_集群范围锁">集群范围锁</a></li>
<li><a href="#_集群范围计数器">集群范围计数器</a></li>
</ul>
</li>
<li><a href="#_访问文件系统">访问文件系统</a>
<ul class="sectlevel2">
<li><a href="#_异步文件访问">异步文件访问</a></li>
</ul>
</li>
<li><a href="#_数据报套接字_udp">数据报套接字（UDP）</a>
<ul class="sectlevel2">
<li><a href="#_创建_datagramsocket">创建 DatagramSocket</a></li>
<li><a href="#_发送数据报包">发送数据报包</a></li>
<li><a href="#_接收数据报包">接收数据报包</a></li>
<li><a href="#_多播">多播</a></li>
</ul>
</li>
<li><a href="#_dns_客户端">DNS 客户端</a>
<ul class="sectlevel2">
<li><a href="#_lookup">lookup</a></li>
<li><a href="#_lookup4">lookup4</a></li>
<li><a href="#_lookup6">lookup6</a></li>
<li><a href="#_resolvea">resolveA</a></li>
<li><a href="#_resolveaaaa">resolveAAAA</a></li>
<li><a href="#_resolvecname">resolveCNAME</a></li>
<li><a href="#_resolvemx">resolveMX</a></li>
<li><a href="#_resolvetxt">resolveTXT</a></li>
<li><a href="#_resolvens">resolveNS</a></li>
<li><a href="#_resolvesrv">resolveSRV</a></li>
<li><a href="#_resolveptr">resolvePTR</a></li>
<li><a href="#_reverselookup">reverseLookup</a></li>
</ul>
</li>
<li><a href="#streams">流</a>
<ul class="sectlevel2">
<li><a href="#_readstream">ReadStream</a></li>
<li><a href="#_writestream">WriteStream</a></li>
<li><a href="#_泵">泵</a></li>
</ul>
</li>
<li><a href="#_记录解析器">记录解析器</a></li>
<li><a href="#_json_parser">Json Parser</a></li>
<li><a href="#_线程安全">线程安全</a></li>
<li><a href="#_metrics_spi">Metrics SPI</a></li>
<li><a href="#_osgi">OSGi</a></li>
<li><a href="#_vertx_命令行">vertx 命令行</a>
<ul class="sectlevel2">
<li><a href="#_运行_verticle">运行 Verticle</a></li>
<li><a href="#_执行打包成_fat_jar_的vert_x_应用">执行打包成 fat-jar 的Vert.x 应用</a></li>
<li><a href="#_显示vert_x的版本">显示Vert.x的版本</a></li>
<li><a href="#_其他命令">其他命令</a></li>
<li><a href="#_实时重部署">实时重部署</a></li>
</ul>
</li>
<li><a href="#_集群管理器">集群管理器</a></li>
<li><a href="#_日志记录">日志记录</a>
<ul class="sectlevel2">
<li><a href="#_配置jul日志记录">配置JUL日志记录</a></li>
<li><a href="#_使用另一个日志框架">使用另一个日志框架</a></li>
<li><a href="#_应用中记录日志">应用中记录日志</a></li>
<li><a href="#netty-logging">Netty日志记录</a></li>
<li><a href="#_故障排除">故障排除</a></li>
</ul>
</li>
<li><a href="#_主机名解析">主机名解析</a>
<ul class="sectlevel2">
<li><a href="#_故障转移">故障转移</a></li>
<li><a href="#_服务器列表轮询">服务器列表轮询</a></li>
<li><a href="#_主机映射">主机映射</a></li>
<li><a href="#_搜索域名">搜索域名</a></li>
</ul>
</li>
<li><a href="#high_Availability_and_Fail_Over">高可用和故障转移</a>
<ul class="sectlevel2">
<li><a href="#_自动故障转移">自动故障转移</a></li>
<li><a href="#_ha组">HA组</a></li>
<li><a href="#_处理网络分区_quora">处理网络分区 - Quora</a></li>
</ul>
</li>
<li><a href="#_native_transports">Native transports</a>
<ul class="sectlevel2">
<li><a href="#_native_linux_transport">Native Linux Transport</a></li>
<li><a href="#_native_bsd_transport">Native BSD Transport</a></li>
<li><a href="#_domain_sockets">Domain sockets</a></li>
</ul>
</li>
<li><a href="#_安全注意事项">安全注意事项</a>
<ul class="sectlevel2">
<li><a href="#_web_应用">Web 应用</a></li>
<li><a href="#_集群模式_event_bus_流量">集群模式 Event Bus 流量</a></li>
<li><a href="#_标准安全最佳实践">标准安全最佳实践</a></li>
</ul>
</li>
<li><a href="#_vert_x_命令行接口api">Vert.x 命令行接口API</a>
<ul class="sectlevel2">
<li><a href="#_定义阶段">定义阶段</a></li>
<li><a href="#_解析阶段">解析阶段</a></li>
<li><a href="#_查询_审问阶段">查询/审问阶段</a></li>
</ul>
</li>
<li><a href="#_the_vert_x_launcher">The vert.x Launcher</a>
<ul class="sectlevel2">
<li><a href="#Extending_the_vert_x_Launcher">扩展 Vert.x 启动器</a></li>
<li><a href="#_在_fat_jar_中使用启动器">在 fat-jar 中使用启动器</a></li>
<li><a href="#_启动器子类">启动器子类</a></li>
<li><a href="#_启动器和退出代码">启动器和退出代码</a></li>
</ul>
</li>
<li><a href="#_配置_vert_x_缓存">配置 Vert.x 缓存</a></li>
</ul>
        </div>

  <a href="https://github.com/okou19900722/vertx-web-site-translation-chinese/tree/master/vertx-translation-stack/vertx-core-translation"
     class="page-link-to-github"
     target="_blank"
     title="Edit this page on GitHub">
    <i class="github-icon"></i>
    <span class="text">编辑本页</span>
  </a>

        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 的核心 Java API 被我们称为 <strong>Vert.x Core</strong></p>
</div>
<div class="paragraph">
<p><a href="https://github.com/eclipse/vert.x">源码</a>.</p>
</div>
<div class="paragraph">
<p>Vert.x Core 提供了下列功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>编写 TCP 客户端和服务端</p>
</li>
<li>
<p>编写支持 WebSocket 的 HTTP 客户端和服务端</p>
</li>
<li>
<p>事件总线</p>
</li>
<li>
<p>共享数据 —— 本地的Map和分布式集群Map</p>
</li>
<li>
<p>周期性、延迟性动作</p>
</li>
<li>
<p>部署和撤销 Verticle 实例</p>
</li>
<li>
<p>数据报套接字</p>
</li>
<li>
<p>DNS客户端</p>
</li>
<li>
<p>文件系统访问</p>
</li>
<li>
<p>高可用性</p>
</li>
<li>
<p>Native transports</p>
</li>
<li>
<p>集群</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Vert.x Core中的功能相当底层 —— 您在此不会找到诸如数据库访问、授权或高层Web应用的功能。您可以在 <strong>Vert.x ext</strong> （扩展包）
（译者注：Vert.x的扩展包是Vert.x的子项目集合，类似 <code><a href="../../#web">Web</a></code> 、 <code><a href="../../#web_client">Web Client</a></code>
、 <code><a href="../../#data_access">Data Access</a></code> 等）中找到这些功能。</p>
</div>
<div class="paragraph">
<p><strong>Vert.x Core</strong> 小而轻，您可以只使用您需要的部分。它可整体嵌入现存应用中。我们并不会强迫您用特定的方式构造您的应用。</p>
</div>
<div class="paragraph">
<p>您亦可在其它Vert.x支持的语言中使用Vert.x Core。很酷的是：我们并不强迫您在书写诸如 JavaScript 或 Ruby 时直接调用 Java API，
毕竟不同的语言有不同的代码风格，若强行让 Ruby 开发人员遵循 Java 的代码风格会很怪异，所以我们根据 Java API
自动生成了适应不同语言代码风格的 API。</p>
</div>
<div class="paragraph">
<p>From now on we&#8217;ll just use the word <strong>core</strong> to refer to Vert.x core.</p>
</div>
<div class="paragraph">
<p>If you are using Maven or Gradle, add the following dependency to the <em>dependencies</em> section of your
project descriptor to access the Vert.x Core API and enable the JavaScript support:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (in your <code>pom.xml</code>):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
&lt;groupId&gt;io.vertx&lt;/groupId&gt;
&lt;artifactId&gt;vertx-core&lt;/artifactId&gt;
&lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
 &lt;groupId&gt;io.vertx&lt;/groupId&gt;
 &lt;artifactId&gt;vertx-lang-kotlin&lt;/artifactId&gt;
 &lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (in your <code>build.gradle</code> file):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile "io.vertx:vertx-core:3.6.0"
compile "io.vertx:vertx-lang-kotlin:3.6.0"</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来讨论 Vert.x Core 中不同的概念和特性。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_故事从_vert_x_开始">故事从 Vert.x 开始</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除非您拿到 <code><a href="../../apidocs/io/vertx/core/Vertx.html">Vertx</a></code> 对象，否则在Vert.x领域中您做不了太多的事情。它是 Vert.x 的控制中心，也是您做几乎一切事情的基础，包括创建客户端和服务器、获取事件总线的引用、设置定时器等等。</p>
</div>
<div class="paragraph">
<p>那么如何获取它的实例呢？</p>
</div>
<div class="paragraph">
<p>如果您用嵌入方式使用Vert.x，可通过以下代码创建实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var vertx = Vertx.vertx()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>大部分应用将只会需要一个Vert.x实例，但如果您有需要也可创建多个Vert.x实例，如：隔离的事件总线或不同组的客户端和服务器。</strong>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_创建_vertx_对象时指定配置项">创建 Vertx 对象时指定配置项</h3>
<div class="paragraph">
<p>如果缺省的配置不适合您，可在创建 <code>Vertx</code> 对象的同时指定配置项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var vertx = Vertx.vertx(VertxOptions(
  workerPoolSize = 40))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/VertxOptions.html">VertxOptions</a></code> 对象有很多配置，包括集群、高可用、池大小等。在Javadoc中描述了所有配置的细节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建集群模式的_vert_x_对象">创建集群模式的 Vert.x 对象</h3>
<div class="paragraph">
<p>如果您想创建一个 <code>集群模式</code> 的 <code>Vertx</code> 对象（参考 <a href="#event_bus">Event Bus</a> 章节了解更多事件总线集群细节），那么通常情况下您将需要使用另一种异步的方式来创建 <code>Vertx</code> 对象。</p>
</div>
<div class="paragraph">
<p>这是因为让不同的 Vert.x 实例组成一个集群需要一些时间（也许是几秒钟）。在这段时间内，我们不想去阻塞调用线程，所以我们将结果异步返回给您。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_是流式的吗">是流式的吗？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您也许注意到前边的例子里使用了一个 <strong>流式</strong> （Fluent）的API。</p>
</div>
<div class="paragraph">
<p>一个流式的API表示将多个方法的调用链在一起。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.response().putHeader("Content-Type", "text/plain").write("some text").end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是贯穿 Vert.x API 中的一个通用模式，所以请适应这种代码风格。</p>
</div>
<div class="paragraph">
<p>这样的链式调用会让您的代码更为简洁。当然，如果您不喜欢流式风格，我们不强制您用这种方式书写代码。如果您更倾向于用以下方式编码，您可以忽略它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.putHeader("Content-Type", "text/plain")
response.write("some text")
response.end()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_don_t_call_us_we_ll_call_you">Don&#8217;t call us, we&#8217;ll call you.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 的 API 大部分都是事件驱动的。这意味着当您感兴趣的事情发生时，它会以事件的形式发送给您。</p>
</div>
<div class="paragraph">
<p>以下是一些事件的例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>触发一个计时器</p>
</li>
<li>
<p>Socket 收到了一些数据</p>
</li>
<li>
<p>从磁盘中读取了一些数据</p>
</li>
<li>
<p>发生了一个异常</p>
</li>
<li>
<p>HTTP 服务器收到了一个请求</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您提供处理器给Vert.x API来处理事件。例如每隔一秒发送一个事件的计时器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.setPeriodic(1000, { id -&gt;
  // This handler will get called every second
  println("timer fired!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>又或者收到一个HTTP请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Respond to each http request with "Hello World"
server.requestHandler({ request -&gt;
  // This handler will be called every time an HTTP request is received at the server
  request.response().end("hello world!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>稍后当Vert.x有一个事件要传给您的处理器时，它会 <strong>异步地</strong> 调用这个处理器。</p>
</div>
<div class="paragraph">
<p>由此引入了下面一些Vert.x中的重要概念。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_不要阻塞我">不要阻塞我！</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了很少的特例（如以 "Sync" 结尾的某些文件系统操作），Vert.x中的所有API都不会阻塞调用线程。</p>
</div>
<div class="paragraph">
<p>如果可以立即提供结果，它将立即返回，否则您需要提供一个处理器（ <code>Handler</code> ）来接收稍后回调的事件。</p>
</div>
<div class="paragraph">
<p>因为Vert.x API不会阻塞线程，所以通过Vert.x您可以只使用少量的线程来处理大量的并发。</p>
</div>
<div class="paragraph">
<p>当使用传统的阻塞式API做以下操作时，调用线程可能会被阻塞：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从 Socket 中读取数据</p>
</li>
<li>
<p>写数据到磁盘</p>
</li>
<li>
<p>发送消息给接收者并等待回复</p>
</li>
<li>
<p>其他很多情况</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在上述所有情况下，当您的线程在等待处理结果时它不能做任何事，此时这些线程并无实际用处。</p>
</div>
<div class="paragraph">
<p>这意味着如果您使用阻塞式API处理大量并发，您需要大量线程来防止应用程序逐步停止运转。</p>
</div>
<div class="paragraph">
<p>所需的内存（例如它们的栈）和上下文切换都是线程的开销。这意味着，阻塞式的方式对于现代应用程序所需要的并发级别来说是难于扩展的。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reactor_模式和_multi_reactor_模式">Reactor 模式和 Multi-Reactor 模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们前边提过 Vert.x 的 API 都是事件驱动的，当有事件时 Vert.x 会将事件传给处理器来处理。</p>
</div>
<div class="paragraph">
<p>在多数情况下，Vert.x使用被称为 <strong>Event Loop</strong> 的线程来调用您的处理器。</p>
</div>
<div class="paragraph">
<p>由于Vert.x或应用程序的代码块中没有阻塞， <strong>Event Loop</strong> 可以在事件到达时快速地分发到不同的处理器中。</p>
</div>
<div class="paragraph">
<p>由于没有阻塞，Event Loop 可在短时间内分发大量的事件。例如，一个单独的 <strong>Event Loop</strong> 可以非常迅速地处理数千个 HTTP 请求。</p>
</div>
<div class="paragraph">
<p>我们称之为 <a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor 模式</a>（译者注：Reactor Pattern 翻译成了 <a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F">反应器模式</a>）。</p>
</div>
<div class="paragraph">
<p>您之前也许听说过它，例如 Node.js 实现了这种模式。</p>
</div>
<div class="paragraph">
<p>在一个标准的反应器实现中，有 <strong>一个独立的 Event Loop</strong> 会循环执行，处理所有到达的事件并传递给处理器处理。</p>
</div>
<div class="paragraph">
<p>单一线程的问题在于它在任意时刻只能运行在一个核上。如果您希望单线程反应器应用（如您的 Node.js 应用）扩展到多核服务器上，则需要启动并且管理多个不同的进程。</p>
</div>
<div class="paragraph">
<p>Vert.x的工作方式有所不同。每个 <code>Vertx</code> 实例维护的是 <strong>多个Event Loop 线程</strong>。默认情况下，我们会根据机器上可用的核数量来设置 Event Loop 的数量，您亦可自行设置。</p>
</div>
<div class="paragraph">
<p>这意味着 Vertx 进程能够在您的服务器上扩展，与 Node.js 不同。</p>
</div>
<div class="paragraph">
<p>我们将这种模式称为 <strong>Multi-Reactor 模式</strong>（多反应器模式），区别于单线程的 Reactor 模式（反应器模式）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>即使一个 <code>Vertx</code> 实例维护了多个 Event Loop，任何一个特定的处理器永远不会被并发执行。大部分情况下（除了 <a href="#worker_verticles">Worker Verticle</a> 以外）它们总是在同一个 Event Loop 线程中被调用。</strong>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="golden_rule">黄金法则：不要阻塞Event Loop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>尽管我们已经知道，Vert.x 的 API 都是非阻塞式的并且不会阻塞 Event Loop，但是这并不能帮您避免在您自己的处理器中阻塞 Event Loop 的情况发生。</p>
</div>
<div class="paragraph">
<p>如果这样做，该 Event Loop 在被阻塞时就不能做任何事情。如果您阻塞了 <code>Vertx</code> 实例中的所有 Event Loop，那么您的应用就会完全停止！</p>
</div>
<div class="paragraph">
<p>所以不要这样做！<strong>这是一个警告!</strong></p>
</div>
<div class="paragraph">
<p>这些阻塞做法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Thead.sleep()</p>
</li>
<li>
<p>等待一个锁</p>
</li>
<li>
<p>等待一个互斥信号或监视器（例如同步的代码块）</p>
</li>
<li>
<p>执行一个长时间数据库操作并等待其结果</p>
</li>
<li>
<p>执行一个复杂的计算，占用了可感知的时长</p>
</li>
<li>
<p>在循环语句中长时间逗留</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果上述任何一种情况停止了 Event Loop 并占用了 <strong>显著执行时间</strong> ，那您应该去罚站（译者注：原文此处为 Naughy Step，英国父母会在家里选择一个角落作为小孩罚站或静坐的地方，被称为 naughty corner 或 naughty step），等待下一步的指示。</p>
</div>
<div class="paragraph">
<p>所以，什么是 <strong>显著执行时间</strong> ？</p>
</div>
<div class="paragraph">
<p>您要等多久？它取决于您的应用程序和所需的并发数量。</p>
</div>
<div class="paragraph">
<p>如果您只有单个 Event Loop，而且您希望每秒处理10000个 HTTP 请求，很明显的是每一个请求处理时间不可以超过0.1毫秒，所以您不能阻塞任何过多（大于0.1毫秒）的时间。</p>
</div>
<div class="paragraph">
<p><strong>这个数学题并不难，将留给读者作为练习。</strong></p>
</div>
<div class="paragraph">
<p>如果您的应用程序没有响应，可能这是一个迹象，表明您在某个地方阻塞了Event Loop。
为了帮助您诊断类似问题，若 Vert.x 检测到 Event Loop 有一段时间没有响应，将会自动记录这种警告。
若您在日志中看到类似警告，那么您需要检查您的代码。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x 还将提供堆栈跟踪，以精确定位发生阻塞的位置。</p>
</div>
<div class="paragraph">
<p>如果想关闭这些警告或更改设置，您可以在创建 <code>Vertx</code> 对象之前在 <code><a href="../../apidocs/io/vertx/core/VertxOptions.html">VertxOptions</a></code> 中完成此操作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="blocking_code">运行阻塞式代码</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在一个完美的世界中，不存在战争和饥饿，所有的API都将使用异步方式编写，兔兔和小羊羔将会在阳光明媚的绿色草地上手牵手地跳舞。</p>
</div>
<div class="paragraph">
<p><strong>但是……真实世界并非如此（您最近看新闻了吧？）</strong></p>
</div>
<div class="paragraph">
<p>事实是，很多，也非所有的库，特别是在JVM生态系统中有很多同步API，这些API中许多方法都是阻塞式的。一个很好的例子就是 JDBC API，它本质上是同步的，无论多么努力地去尝试，Vert.x都不能像魔法小精灵撒尘变法一样将它转换成异步API。</p>
</div>
<div class="paragraph">
<p>我们不会将所有的内容重写成异步方式，所以我们为您提供一种在 Vert.x 应用中安全调用"传统"阻塞API的方法。</p>
</div>
<div class="paragraph">
<p>如之前讨论，您不能在 Event Loop 中直接调用阻塞式操作，因为这样做会阻止 Event Loop 执行其他有用的任务。那您该怎么做？</p>
</div>
<div class="paragraph">
<p>可以通过调用 <code><a href="../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-">executeBlocking</a></code> 方法来指定阻塞式代码的执行以及阻塞式代码执行后处理结果的异步回调。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.executeBlocking&lt;Any&gt;({ future -&gt;
  // Call some blocking API that takes a significant amount of time to return
  var result = someAPI.blockingMethod("hello")
  future.complete(result)
}, { res -&gt;
  println("The result is: ${res.result()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，如果 <code>executeBlocking</code> 在同一个上下文环境中（如：同一个 Verticle 实例）被调用了多次，那么这些不同的 <code>executeBlocking</code> 代码块会 <strong>顺序执行</strong> （一个接一个）。</p>
</div>
<div class="paragraph">
<p>若您不需要关心您调用 <code><a href="../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-">executeBlocking</a></code>
的顺序，可以将 <code>ordered</code> 参数的值设为 <code>false</code> 。这样任何 <code>executeBlocking</code> 都会在 Worker Pool 中并行执行。</p>
</div>
<div class="paragraph">
<p>另外一种运行阻塞式代码的方法是使用<a href="#worker_verticles">Worker Verticle</a></p>
</div>
<div class="paragraph">
<p>一个 Worker Verticle 始终会使用 Worker Pool 中的某个线程来执行。</p>
</div>
<div class="paragraph">
<p>默认的阻塞式代码会在 Vert.x 的 Worker Pool 中执行，通过 <code><a href="../../apidocs/io/vertx/core/VertxOptions.html#setWorkerPoolSize-int-">setWorkerPoolSize</a></code> 配置。</p>
</div>
<div class="paragraph">
<p>可以为不同的用途创建不同的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var executor = vertx.createSharedWorkerExecutor("my-worker-pool")
executor.executeBlocking&lt;Any&gt;({ future -&gt;
  // Call some blocking API that takes a significant amount of time to return
  var result = someAPI.blockingMethod("hello")
  future.complete(result)
}, { res -&gt;
  println("The result is: ${res.result()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Worker Executor 在不需要的时候必须被关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">executor.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用同一个名字创建了许多 worker 时，它们将共享同一个 pool。当所有的 worker executor 调用了 <code>close</code> 方法被关闭过后，对应的 worker pool 会被销毁。</p>
</div>
<div class="paragraph">
<p>如果 Worker Executor 在 Verticle 中创建，那么 Verticle 实例销毁的同时 Vert.x 将会自动关闭这个 Worker Executor。</p>
</div>
<div class="paragraph">
<p>Worker Executor 可以在创建的时候配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">//
// 10 threads max
var poolSize = 10

// 2 minutes
var maxExecuteTime = 2
var maxExecuteTimeUnit = TimeUnit.MINUTES

var executor = vertx.createSharedWorkerExecutor("my-worker-pool", poolSize, maxExecuteTime, maxExecuteTimeUnit)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>这个配置信息在 worker pool 创建的时候设置。</strong>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异步协调">异步协调</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 中的 <code><a href="../../apidocs/io/vertx/core/Future.html">Future</a></code> 可以用来协调多个异步操作的结果。它支持并发组合（并行执行多个异步调用）和顺序组合（依次执行异步调用）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
译者注：Vert.x 中的 <code><a href="../../apidocs/io/vertx/core/Future.html">Future</a></code> 即异步开发模式中的 Future/Promise 模式的实现。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_并发合并">并发合并</h3>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/CompositeFuture.html#all-io.vertx.core.Future-io.vertx.core.Future-">CompositeFuture.all</a></code> 方法接受多个 <code>Future</code> 对象作为参数（最多6个，或者传入 <code>List</code> ）。当所有的 <code>Future</code> 都成功完成，该方法将返回一个 <strong>成功的</strong> <code>Future</code> ；当任一个 <code>Future</code> 执行失败，则返回一个 <strong>失败的</strong> <code>Future</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var httpServerFuture = Future.future&lt;Any&gt;()
httpServer.listen(httpServerFuture.completer())

var netServerFuture = Future.future&lt;Any&gt;()
netServer.listen(netServerFuture.completer())

CompositeFuture.all(httpServerFuture, netServerFuture).setHandler({ ar -&gt;
  if (ar.succeeded()) {
    // All servers started
  } else {
    // At least one server failed
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有被合并的 <code>Future</code> 中的操作同时运行。
当组合的处理操作完成时，该方法返回的 <code>Future</code> 上绑定的处理器 <code><a href="../../apidocs/io/vertx/core/Handler.html">Handler</a></code> 会被调用。
当一个操作失败（其中的某一个 <code>Future</code> 的状态被标记成失败），则返回的 <code>Future</code> 会被标记为失败。
当所有的操作都成功时，返回的 <code>Future</code> 将会成功完成。</p>
</div>
<div class="paragraph">
<p>您可以传入一个 <code>Future</code> 列表（可能为空）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">CompositeFuture.all(listOf(future1, future2, future3))</code></pre>
</div>
</div>
<div class="paragraph">
<p>不同于 <code>all</code> 方法的合并会等待所有的 Future 成功执行（或任一失败）， <code>any</code> 方法的合并会等待第一个成功执行的Future。 <code><a href="../../apidocs/io/vertx/core/CompositeFuture.html#any-io.vertx.core.Future-io.vertx.core.Future-">CompositeFuture.any</a></code> 方法接受多个 <code>Future</code> 作为参数（最多6个，或传入 <code>List</code> ）。当任意一个 <code>Future</code> 成功得到结果，则该 <code>Future</code> 成功；当所有的 <code>Future</code> 都执行失败，则该 <code>Future</code> 失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">CompositeFuture.any(future1, future2).setHandler({ ar -&gt;
  if (ar.succeeded()) {
    // At least one is succeeded
  } else {
    // All failed
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>它也可使用 <code>Future</code> 列表传参：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">CompositeFuture.any(listOf(f1, f2, f3))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>join</code> 方法的合并会等待所有的 <code>Future</code> 完成，无论成败。
<code><a href="../../apidocs/io/vertx/core/CompositeFuture.html#join-io.vertx.core.Future-io.vertx.core.Future-">CompositeFuture.join</a></code> 方法接受多个 <code>Future</code> 作为参数（最多6个），并将结果归并成一个 <code>Future</code> 。
当全部 <code>Future</code> 成功执行完成，得到的 <code>Future</code> 是成功状态的；当至少一个 <code>Future</code> 执行失败时，得到的 <code>Future</code> 是失败状态的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">CompositeFuture.join(future1, future2, future3).setHandler({ ar -&gt;
  if (ar.succeeded()) {
    // All succeeded
  } else {
    // All completed and at least one failed
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>它也可使用 <code>Future</code> 列表传参：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">CompositeFuture.join(listOf(future1, future2, future3))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_顺序合并">顺序合并</h3>
<div class="paragraph">
<p>和 <code>all</code> 以及 <code>any</code> 实现的并发组合不同， <code><a href="../../apidocs/io/vertx/core/Future.html#compose-io.vertx.core.Handler-io.vertx.core.Future-">compose</a></code> 方法作用于顺序组合 <code>Future</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var fs = vertx.fileSystem()
var startFuture = Future.future&lt;Any&gt;()

var fut1 = Future.future&lt;Any&gt;()
fs.createFile("/foo", fut1.completer())

fut1.compose&lt;Any&gt;({ v -&gt;
  // When the file is created (fut1), execute this:
  var fut2 = Future.future&lt;Any&gt;()
  fs.writeFile("/foo", Buffer.buffer(), fut2.completer())
  return fut2
}).compose({ v -&gt;
  // When the file is written (fut2), execute this:
  fs.move("/foo", "/bar", startFuture.completer())
}, startFuture)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里例子中，有三个操作被串起来了：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一个文件被创建（ <code>fut1</code> ）</p>
</li>
<li>
<p>一些东西被写入到文件（ <code>fut2</code> ）</p>
</li>
<li>
<p>文件被移走（ <code>startFuture</code> ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果这三个步骤全部成功，则最终的 <code>Future</code> （ <code>startFuture</code> ）会是成功的；其中任何一步失败，则最终 <code>Future</code> 就是失败的。</p>
</div>
<div class="paragraph">
<p>例子中使用了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/core/Future.html#compose-java.util.function.Function-">compose</a></code> ：当前 <code>Future</code> 完成时，执行相关代码，并返回 <code>Future</code> 。当返回的 <code>Future</code> 完成时，组合完成。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/Future.html#compose-io.vertx.core.Handler-io.vertx.core.Future-">compose</a></code> ：当前 <code>Future</code> 完成时，执行相关代码，并完成下一个 <code>Future</code> 的处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于第二个例子，处理器需要完成 <code>next</code> future，以此来汇报处理成功或者失败。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/Future.html#completer--">completer</a></code> 方法来串起一个带操作结果的或失败的 <code>Future</code> ，它可使您避免用传统方式编写代码：如果成功则完成 <code>Future</code> ，否则就标记为失败。（译者注：3.4.0 以后不需要再使用 <code>completer</code> 方法）</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verticles">Verticles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 通过开箱即用的方式提供了一个简单便捷的、可扩展的、类似 <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> 的部署和并发模型机制。您可以用此模型机制来保管您自己的代码组件。</p>
</div>
<div class="paragraph">
<p><strong>这个模型是可选的，如果您不想这样做，Vert.x 不会强迫您用这种方式创建您的应用程序。</strong></p>
</div>
<div class="paragraph">
<p>这个模型不能说是严格的 Actor 模式的实现，但它确实有相似之处，特别是在并发、扩展性和部署等方面。</p>
</div>
<div class="paragraph">
<p>要使用该模型，您需要将您的代码组织成一系列的 <strong>Verticle</strong>。</p>
</div>
<div class="paragraph">
<p>Verticle 是由 Vert.x 部署和运行的代码块。默认情况一个 Vert.x 实例维护了N（默认情况下N = CPU核数 x 2）个 Event Loop 线程。Verticle 实例可使用任意 Vert.x 支持的编程语言编写，而且一个简单的应用程序也可以包含多种语言编写的 Verticle。</p>
</div>
<div class="paragraph">
<p>您可以将 Verticle 想成 <a href="http://en.wikipedia.org/wiki/Actor_model">Actor Model</a>中的 Actor。（译者注: <a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E8%88%87%E8%80%85%E6%A8%A1%E5%BC%8F">参与者模式</a>）</p>
</div>
<div class="paragraph">
<p>一个应用程序通常是由在同一个 Vert.x 实例中同时运行的许多 Verticle 实例组合而成。不同的 Verticle 实例通过向 <a href="#event_bus">Event Bus</a> 上发送消息来相互通信。</p>
</div>
<div class="sect2">
<h3 id="_writing_verticles">Writing Verticles</h3>
<div class="paragraph">
<p>Writing a Verticle with Kotlin is achieved the same way you write a Java Verticle by
extending the <code><a href="../../apidocs/io/vertx/core/AbstractVerticle.html">AbstractVerticle</a></code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example verticle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">import io.vertx.core.AbstractVerticle

class MyVerticle : AbstractVerticle() {

 // Called when verticle is deployed
 override fun start() {
 }

 // Optional - called when verticle is undeployed
 override fun stop() {
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please refer to the Java documentation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_种类">Verticle 种类</h3>
<div class="paragraph">
<p>这儿有三种不同类型的 Verticle：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Standard Verticles</dt>
<dd>
<p>这是最常用的一类 Verticle —— 它们永远运行在 Event Loop 线程上。稍后的章节我们会讨论更多。</p>
</dd>
<dt class="hdlist1">Worker Verticles</dt>
<dd>
<p>这类 Verticle 会运行在 Worker Pool 中的线程上。一个实例绝对不会被多个线程同时执行。</p>
</dd>
<dt class="hdlist1">Multi-threaded worker verticles</dt>
<dd>
<p>这类 Verticle 也会运行在 Worker Pool 中的线程上。一个实例可以由多个线程同时执行（译者注：因此需要开发者自己确保线程安全）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_standard_verticles">Standard verticles</h3>
<div class="paragraph">
<p>当 Standard Verticle 被创建时，它会被分派给一个 Event Loop 线程，并在这个 Event Loop 中执行它的 <code>start</code> 方法。当您在一个 Event Loop 上调用了 Core API 中的方法并传入了处理器时，Vert.x 将保证用与调用该方法时相同的 Event Loop 来执行这些处理器。</p>
</div>
<div class="paragraph">
<p>这意味着我们可以保证您的 Verticle 实例中 <strong>所有的代码都是在相同Event Loop中执行</strong>（只要您不创建自己的线程并调用它！）</p>
</div>
<div class="paragraph">
<p>同样意味着您可以将您的应用中的所有代码用单线程方式编写，让 Vert.x 去考虑线程和扩展问题。您不用再考虑 synchronized 和 volatile 的问题，也可以避免传统的多线程应用经常会遇到的竞态条件和死锁的问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="worker_verticles">Worker verticles</h3>
<div class="paragraph">
<p>Worker Verticle 和 Standard Verticle 很像，但它并不是由一个 Event Loop 来执行，而是由Vert.x中的 Worker Pool 中的线程执行。</p>
</div>
<div class="paragraph">
<p>Worker Verticle 被设计来调用阻塞式代码，它不会阻塞任何 Event Loop。</p>
</div>
<div class="paragraph">
<p>如果您不想使用 Worker Verticle 来运行阻塞式代码，您还可以在一个Event Loop中直接使用 [内联阻塞式代码](#运行阻塞式代码)。</p>
</div>
<div class="paragraph">
<p>若您想要将 Verticle 部署成一个 Worker Verticle，您可以通过 <code><a href="../../apidocs/io/vertx/core/DeploymentOptions.html#setWorker-boolean-">setWorker</a></code> 方法来设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = DeploymentOptions(
  worker = true)
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Worker Verticle 实例绝对不会在 Vert.x 中被多个线程同时执行，但它可以在不同时间由不同线程执行。</p>
</div>
<div class="sect3">
<h4 id="_multi_threaded_worker_verticles">Multi-threaded worker verticles</h4>
<div class="paragraph">
<p>一个 Multi-threaded Worker Verticle 近似于普通的 Worker Verticle，但是它可以由不同的线程同时执行。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<strong>Multi-threaded Worker Verticle 是一个高级功能，大部分应用程序不会需要它。由于这些 Verticle 是并发的，您必须小心地使用标准的Java多线程技术来保持 Verticle 的状态一致性。</strong>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_编程方式部署verticle">编程方式部署Verticle</h3>
<div class="paragraph">
<p>您可以指定一个 Verticle 名称或传入您已经创建好的 Verticle 实例，使用任意一个 <code><a href="../../apidocs/io/vertx/core/Vertx.html#deployVerticle-io.vertx.core.Verticle-">deployVerticle</a></code> 方法来部署Verticle。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
请注意：通过 Verticle <strong>实例</strong> 来部署 Verticle 仅限Java语言。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">var myVerticle = examples.CoreExamples.MyVerticle()
vertx.deployVerticle(myVerticle)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您同样可以指定 Verticle 的 <strong>名称</strong> 来部署它。</p>
</div>
<div class="paragraph">
<p>这个 Verticle 的名称会用于查找实例化 Verticle 的特定 <code><a href="../../apidocs/io/vertx/core/spi/VerticleFactory.html">VerticleFactory</a></code></p>
</div>
<div class="paragraph">
<p>不同的 Verticle Factory 可用于实例化不同语言的 Verticle，也可用于其他目的，例如加载服务、运行时从Maven中获取Verticle实例等。</p>
</div>
<div class="paragraph">
<p>这允许您部署用任何使用Vert.x支持的语言编写的Verticle实例。</p>
</div>
<div class="paragraph">
<p>这儿有一个部署不同类型 Verticle 的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Deploy a Java verticle - the name is the fully qualified class name of the verticle class
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle")

// Deploy a JavaScript verticle
vertx.deployVerticle("verticles/myverticle.js")

// Deploy a Ruby verticle verticle
vertx.deployVerticle("verticles/my_verticle.rb")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle名称到factory的映射规则">Verticle名称到Factory的映射规则</h3>
<div class="paragraph">
<p>当使用名称部署Verticle时，会通过名称来选择一个用于实例化 Verticle 的 Verticle Factory。</p>
</div>
<div class="paragraph">
<p>Verticle 名称可以有一个前缀 —— 使用字符串紧跟着一个冒号，它用于查找存在的Factory，参考例子。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">js:foo.js</dt>
<dd>
<p>使用JavaScript的Factory</p>
</dd>
<dt class="hdlist1">groovy:com.mycompany.SomeGroovyCompiledVerticle</dt>
<dd>
<p>用Groovy的Factory</p>
</dd>
<dt class="hdlist1">service:com.mycompany:myorderservice</dt>
<dd>
<p>用Service的Factory</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果不指定前缀，Vert.x将根据提供名字后缀来查找对应Factory，如：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">foo.js</dt>
<dd>
<p>将使用JavaScript的Factory</p>
</dd>
<dt class="hdlist1">SomeScript.groovy</dt>
<dd>
<p>将使用Groovy的Factory</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>若前缀后缀都没指定，Vert.x将假定这个名字是一个Java 全限定类名（FQCN）然后尝试实例化它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_如何定位verticle_factory">如何定位Verticle Factory？</h3>
<div class="paragraph">
<p>大部分Verticle Factory会从 classpath 中加载，并在 Vert.x 启动时注册。</p>
</div>
<div class="paragraph">
<p>您同样可以使用编程的方式去注册或注销Verticle Factory：通过 <code><a href="../../apidocs/io/vertx/core/Vertx.html#registerVerticleFactory-io.vertx.core.spi.VerticleFactory-">registerVerticleFactory</a></code>
方法和 <code><a href="../../apidocs/io/vertx/core/Vertx.html#unregisterVerticleFactory-io.vertx.core.spi.VerticleFactory-">unregisterVerticleFactory</a></code> 方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_等待部署完成">等待部署完成</h3>
<div class="paragraph">
<p>Verticle的部署是异步方式，可能在 <code>deploy</code> 方法调用返回后一段时间才会完成部署。</p>
</div>
<div class="paragraph">
<p>如果您想要在部署完成时被通知则可以指定一个完成处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", { res -&gt;
  if (res.succeeded()) {
    println("Deployment id is: ${res.result()}")
  } else {
    println("Deployment failed!")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果部署成功，这个完成处理器的结果中将会包含部署ID的字符串。</p>
</div>
<div class="paragraph">
<p>这个部署 ID可以在之后您想要撤销它时使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_撤销verticle">撤销Verticle</h3>
<div class="paragraph">
<p>我们可以通过 <code><a href="../../apidocs/io/vertx/core/Vertx.html#undeploy-java.lang.String-">undeploy</a></code> 方法来撤销部署好的 Verticle。</p>
</div>
<div class="paragraph">
<p>撤销操作也是异步的，因此若您想要在撤销完成过后收到通知则可以指定另一个完成处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.undeploy(deploymentID, { res -&gt;
  if (res.succeeded()) {
    println("Undeployed ok")
  } else {
    println("Undeploy failed!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_设置_verticle_实例数">设置 Verticle 实例数</h3>
<div class="paragraph">
<p>当使用名称部署一个 Verticle 时，您可以指定您想要部署的 Verticle 实例的数量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = DeploymentOptions(
  instances = 16)
vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个功能对于跨多核扩展时很有用。例如，您有一个实现了Web服务器的Verticle需要部署在多核的机器上，您可以部署多个实例来利用所有的核。</p>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_隔离组">Verticle 隔离组</h3>
<div class="paragraph">
<p>默认情况，当Vert.x部署Verticle时它会调用当前类加载器来加载类，而不会创建一个新的。大多数情况下，这是最简单、最清晰和最干净。</p>
</div>
<div class="paragraph">
<p>但是在某些情况下，您可能需要部署一个Verticle，它包含的类要与应用程序中其他类隔离开来。</p>
</div>
<div class="paragraph">
<p>比如您想要在一个Vert.x实例中部署两个同名不同版本的Verticle，或者不同的Verticle使用了同一个jar包的不同版本。</p>
</div>
<div class="paragraph">
<p>当使用隔离组时，您需要用
<code><a href="../../apidocs/io/vertx/core/DeploymentOptions.html#setIsolatedClasses-java.util.List-">setIsolatedClasses</a></code>  方法来提供一个您想隔离的类名列表。列表项可以是一个Java 限定类全名，如 <code>com.mycompany.myproject.engine.MyClass</code> ；也可以是包含通配符的可匹配某个包或子包的任何类，例如 <code>com.mycompany.myproject.*</code> 将会匹配所有 <code>com.mycompany.myproject</code> 包或任意子包中的任意类名。</p>
</div>
<div class="paragraph">
<p>请注意仅仅只有匹配的类会被隔离，其他任意类会被当前类加载器加载。</p>
</div>
<div class="paragraph">
<p>若您想要加载的类和资源不存在于主类路径（main classpath），您可使用 <code><a href="../../apidocs/io/vertx/core/DeploymentOptions.html#setExtraClasspath-java.util.List-">setExtraClasspath</a></code> 方法将额外的类路径添加到这里。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
警告：<strong>谨慎使用此功能，类加载器可能会导致您的应用难于调试，变得一团乱麻（can of worms）。</strong>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下是使用隔离组隔离 Verticle 的部署例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = DeploymentOptions(
  isolationGroup = "mygroup")
options.isolatedClasses = listOf("com.mycompany.myverticle.*", "com.mycompany.somepkg.SomeClass", "org.somelibrary.*")
vertx.deployVerticle("com.mycompany.myverticle.VerticleClass", options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_高可用性">高可用性</h3>
<div class="paragraph">
<p>Verticle可以启用高可用方式（HA）部署。在这种方式下，当其中一个部署在 Vert.x 实例中的 Verticle 突然挂掉，这个 Verticle 可以在集群环境中的另一个 Vert.x 实例中重新部署。</p>
</div>
<div class="paragraph">
<p>若要启用高可用方式运行一个 Verticle，仅需要追加 <code>-ha</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-verticle.js -ha</code></pre>
</div>
</div>
<div class="paragraph">
<p>当启用高可用方式时，不需要追加 <code>-cluster</code> 参数。</p>
</div>
<div class="paragraph">
<p>关于高可用的功能和配置的更多细节可参考 <a href="#high_Availability_and_Fail_Over">高可用和故障转移</a> 章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从命令行运行verticle">从命令行运行Verticle</h3>
<div class="paragraph">
<p>您可以在 Maven 或 Gradle 项目中以正常方式添加 Vert.x Core 为依赖，在项目中直接使用 Vert.x。</p>
</div>
<div class="paragraph">
<p>但是，您也可以从命令行直接运行 Vert.x 的 Verticle。</p>
</div>
<div class="paragraph">
<p>为此，您需要下载并安装 Vert.x 的发行版，并且将安装的 <code>bin</code> 目录添加到您的 <code>PATH</code> 环境变量中，还要确保您的 <code>PATH</code> 中设置了Java 8的JDK环境。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>JDK需要支持Java代码的运行时编译（on the fly compilation）。</strong>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在您可以使用 <code>vertx run</code> 命令运行Verticle了，这儿是一些例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre># 运行JavaScript的Verticle
vertx run my_verticle.js

# 运行Ruby的Verticle
vertx run a_n_other_verticle.rb

# 使用集群模式运行Groovy的Verticle
vertx run FooVerticle.groovy -cluster</pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以不必编译 Java 源代码，直接运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>vertx run SomeJavaSourceFile.java</pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x 将在运行它之前对 Java 源代码文件执行运行时编译，这对于快速原型制作和演示很有用。不需要设置 Maven 或 Gradle 就能跑起来！</p>
</div>
<div class="paragraph">
<p>欲了解有关在命令行执行 <code>vertx</code> 可用的各种选项完整信息，可以直接在命令行键入 <code>vertx</code> 查看帮助。</p>
</div>
</div>
<div class="sect2">
<h3 id="_退出_vert_x_环境">退出 Vert.x 环境</h3>
<div class="paragraph">
<p>Vert.x 实例维护的线程不是守护线程，因此它们会阻止JVM退出。</p>
</div>
<div class="paragraph">
<p>如果您通过嵌入式的方式使用 Vert.x 并且完成了操作，您可以调用 <code><a href="../../apidocs/io/vertx/core/Vertx.html#close--">close</a></code> 方法关闭它。</p>
</div>
<div class="paragraph">
<p>这将关闭所有内部线程池并关闭其他资源，允许JVM退出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_context_对象">Context 对象</h3>
<div class="paragraph">
<p>当 Vert.x 传递一个事件给处理器或者调用 Verticle 的 <code>start</code> 或 <code>stop</code> 方法时，它会关联一个 <code>Context</code> 对象来执行。通常来说这个 <code>Context</code> 会是一个 <strong>Event Loop Context</strong>，它绑定到了一个特定的 Event Loop 线程上。所以在该 <code>Context</code> 上执行的操作总是在同一个 Event Loop 线程中。对于运行内联的阻塞代码的 Worker Verticle 来说，会关联一个 Worker Context，并且所有的操作运都会运行在 Worker 线程池的线程上。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
译者注：每个 <code>Verticle</code> 在部署的时候都会被分配一个 <code>Context</code> （根据配置不同，可以是Event Loop Context 或者 Worker Context），之后此 <code>Verticle</code> 上所有的普通代码都会在此 <code>Context</code> 上执行（即对应的 Event Loop 或Worker 线程）。一个 <code>Context</code> 对应一个 Event Loop 线程（或 Worker 线程），但一个 Event Loop 可能对应多个 <code>Context</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--">getOrCreateContext</a></code> 方法获取 <code>Context</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var context = vertx.getOrCreateContext()</code></pre>
</div>
</div>
<div class="paragraph">
<p>若已经有一个 <code>Context</code> 和当前线程关联，那么它直接重用这个 <code>Context</code> 对象，如果没有则创建一个新的。您可以检查获取的 <code>Context</code> 的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var context = vertx.getOrCreateContext()
if (context.isEventLoopContext()) {
  println("Context attached to Event Loop")
} else if (context.isWorkerContext()) {
  println("Context attached to Worker Thread")
} else if (context.isMultiThreadedWorkerContext()) {
  println("Context attached to Worker Thread - multi threaded worker")
} else if (!Context.isOnVertxThread()) {
  println("Context not attached to a thread managed by vert.x")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您获取了这个 <code>Context</code> 对象，您就可以在 <code>Context</code> 中异步执行代码了。换句话说，您提交的任务将会在同一个 <code>Context</code> 中运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.getOrCreateContext().runOnContext({ v -&gt;
  println("This will be executed asynchronously in the same context")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>当在同一个 <code>Context</code> 中运行了多个处理函数时，可能需要在它们之间共享数据。 <code>Context</code> 对象提供了存储和读取共享数据的方法。举例来说，它允许您将数据传递到
<code><a href="../../apidocs/io/vertx/core/Context.html#runOnContext-io.vertx.core.Handler-">runOnContext</a></code> 方法运行的某些操作中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var context = vertx.getOrCreateContext()
context.put("data", "hello")
context.runOnContext({ v -&gt;
  var hello = context.get&lt;Any&gt;("data")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过 <code><a href="../../apidocs/io/vertx/core/Context.html#config--">config</a></code> 方法访问 Verticle 的配置信息。查看 <a href="#Passing_configuration_to_a_verticle">向 Verticle 传入配置</a> 章节了解更多配置信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_执行周期性_延迟性操作">执行周期性/延迟性操作</h3>
<div class="paragraph">
<p>在 Vert.x 中，想要延迟之后执行或定期执行操作很常见。</p>
</div>
<div class="paragraph">
<p>在 Standard Verticle 中您不能直接让线程休眠以引入延迟，因为它会阻塞 Event Loop 线程。</p>
</div>
<div class="paragraph">
<p>取而代之是使用 Vert.x 定时器。定时器可以是一次性或周期性的，两者我们都会讨论到。</p>
</div>
<div class="sect3">
<h4 id="_一次性计时器">一次性计时器</h4>
<div class="paragraph">
<p>一次性计时器会在一定延迟后调用一个 Event Handler，以毫秒为单位计时。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-">setTimer</a></code> 方法传递延迟时间和一个处理器来设置计时器的触发。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var timerID = vertx.setTimer(1000, { id -&gt;
  println("And one second later this is printed")
})

println("First this is printed")</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回值是一个唯一的计时器id，该id可用于之后取消该计时器，这个计时器id会传入给处理器。</p>
</div>
</div>
<div class="sect3">
<h4 id="_周期性计时器">周期性计时器</h4>
<div class="paragraph">
<p>您同样可以使用 <code><a href="../../apidocs/io/vertx/core/Vertx.html#setPeriodic-long-io.vertx.core.Handler-">setPeriodic</a></code> 方法设置一个周期性触发的计时器。</p>
</div>
<div class="paragraph">
<p>第一次触发之前同样会有一段设置的延时时间。</p>
</div>
<div class="paragraph">
<p><code>setPeriodic</code> 方法的返回值也是一个唯一的计时器id，若之后该计时器需要取消则使用该id。</p>
</div>
<div class="paragraph">
<p>传给处理器的参数也是这个唯一的计时器id。</p>
</div>
<div class="paragraph">
<p>请记住这个计时器将会定期触发。如果您的定时任务会花费大量的时间，则您的计时器事件可能会连续执行甚至发生更坏的情况：重叠。</p>
</div>
<div class="paragraph">
<p>这种情况，您应考虑使用 <code><a href="../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-">setTimer</a></code> 方法，当任务执行完成时设置下一个计时器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var timerID = vertx.setPeriodic(1000, { id -&gt;
  println("And every second this is printed")
})

println("First this is printed")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_取消计时器">取消计时器</h4>
<div class="paragraph">
<p>指定一个计时器id并调用 <code><a href="../../apidocs/io/vertx/core/Vertx.html#cancelTimer-long-">cancelTimer</a></code> 方法来取消一个周期性计时器。如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.cancelTimer(timerID)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_verticle_中自动清除定时器">Verticle 中自动清除定时器</h4>
<div class="paragraph">
<p>如果您在 Verticle 中创建了计时器，当这个 Verticle 被撤销时这个计时器会被自动关闭。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_worker_pool">Verticle worker pool</h3>
<div class="paragraph">
<p>Verticle 使用 Vert.x 中的 Worker Pool 来执行阻塞式行为，例如 <code><a href="../../apidocs/io/vertx/core/Context.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-">executeBlocking</a></code> 或 Worker Verticle。</p>
</div>
<div class="paragraph">
<p>可以在部署配置项中指定不同的Worker 线程池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.deployVerticle("the-verticle", DeploymentOptions(
  workerPoolName = "the-specific-pool"))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="event_bus">The Event Bus</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/eventbus/EventBus.html">Event Bus</a></code> 是 Vert.x 的神经系统。</p>
</div>
<div class="paragraph">
<p>每一个 Vert.x 实例都有一个单独的 Event Bus 实例。您可以通过 <code>Vertx</code> 实例的 <code><a href="../../apidocs/io/vertx/core/Vertx.html#eventBus--">eventBus</a></code> 方法来获得对应的 <code>EventBus</code> 实例。</p>
</div>
<div class="paragraph">
<p>您的应用中的不同部分通过 Event Bus 相互通信，无论它们使用哪一种语言实现，无论它们在同一个 Vert.x 实例中或在不同的 Vert.x 实例中。</p>
</div>
<div class="paragraph">
<p>甚至可以通过桥接的方式允许在浏览器中运行的客户端JavaScript在相同的Event Bus上相互通信。</p>
</div>
<div class="paragraph">
<p>Event Bus可形成跨越多个服务器节点和多个浏览器的点对点的分布式消息系统。</p>
</div>
<div class="paragraph">
<p>Event Bus支持发布/订阅、点对点、请求/响应的消息通信方式。</p>
</div>
<div class="paragraph">
<p>Event Bus的API很简单。基本上只涉及注册处理器、撤销处理器和发送和发布消息。</p>
</div>
<div class="paragraph">
<p>首先来看些基本概念和理论。</p>
</div>
<div class="sect2">
<h3 id="_基本概念">基本概念</h3>
<div class="sect3">
<h4 id="_寻址">寻址</h4>
<div class="paragraph">
<p>消息会被 Event Bus 发送到一个 <strong>地址(address)</strong>。</p>
</div>
<div class="paragraph">
<p>同任何花哨的寻址方案相比，Vert.x的地址格式并不麻烦。Vert.x中的地址是一个简单的字符串，任意字符串都合法。当然，使用某种模式来命名仍然是明智的。如：使用点号来划分命名空间。</p>
</div>
<div class="paragraph">
<p>一些合法的地址形如： europe.news.feed1, acme.games.pacman, sausages, and X.</p>
</div>
</div>
<div class="sect3">
<h4 id="_处理器">处理器</h4>
<div class="paragraph">
<p>消息在处理器（<code>Handler</code>）中被接收。您可以在某个地址上注册一个处理器来接收消息。</p>
</div>
<div class="paragraph">
<p>同一个地址可以注册许多不同的处理器。</p>
</div>
<div class="paragraph">
<p>一个处理器也可以注册在多个不同的地址上。</p>
</div>
</div>
<div class="sect3">
<h4 id="_发布_订阅消息">发布/订阅消息</h4>
<div class="paragraph">
<p>Event Bus支持 <strong>发布消息</strong> 功能。</p>
</div>
<div class="paragraph">
<p>消息将被发布到一个地址中，发布意味着会将信息传递给 <strong>所有</strong> 注册在该地址上的处理器。</p>
</div>
<div class="paragraph">
<p>这和 <strong>发布/订阅模式</strong> 很类似。</p>
</div>
</div>
<div class="sect3">
<h4 id="_点对点模式_请求_响应模式">点对点模式/请求-响应模式</h4>
<div class="paragraph">
<p>Event Bus也支持 <strong>点对点消息模式</strong>。</p>
</div>
<div class="paragraph">
<p>消息将被发送到一个地址中，Vert.x将会把消息分发到某个注册在该地址上的处理器。</p>
</div>
<div class="paragraph">
<p>若这个地址上有不止一个注册过的处理器，它将使用 <strong>不严格的轮询算法</strong> 选择其中一个。</p>
</div>
<div class="paragraph">
<p>点对点消息传递模式下，可在消息发送的时候指定一个应答处理器（可选）。</p>
</div>
<div class="paragraph">
<p>当接收者收到消息并且已经被处理时，它可以选择性决定回复该消息，若选择回复则绑定的应答处理器将会被调用。</p>
</div>
<div class="paragraph">
<p>当发送者收到回复消息时，它也可以回复，这个过程可以不断重复。通过这种方式可以允许在两个不同的 Verticle 之间设置一个对话窗口。</p>
</div>
<div class="paragraph">
<p>这种消息模式被称作 <strong>请求-响应</strong> 模式。</p>
</div>
</div>
<div class="sect3">
<h4 id="_尽力传输">尽力传输</h4>
<div class="paragraph">
<p>Vert.x会尽它最大努力去传递消息，并且不会主动丢弃消息。这种方式称为 <strong>尽力传输(Best-effort delivery)</strong>。</p>
</div>
<div class="paragraph">
<p>但是，当 Event Bus 中的全部或部分发生故障时，则可能会丢失消息。</p>
</div>
<div class="paragraph">
<p>若您的应用关心丢失的消息，您应该编写具有幂等性的处理器，并且您的发送者可以在恢复后重试。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
译者注：RPC通信通常情况下有三种语义：<strong>at least once</strong>、<strong>at most once</strong> 和 <strong>exactly once</strong>。不同语义情况下要考虑的情况不同。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_消息类型">消息类型</h4>
<div class="paragraph">
<p>Vert.x 默认允许任何基本/简单类型、<code>String</code> 或 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">buffers</a></code> 作为消息发送。</p>
</div>
<div class="paragraph">
<p>不过在 Vert.x 中的通常做法是使用 <a href="http://json.org/">JSON</a> 格式来发送消息。</p>
</div>
<div class="paragraph">
<p>JSON 对于 Vert.x 支持的所有语言都是非常容易创建、读取和解析的，因此它已经成为了Vert.x中的通用语(<strong>lingua franca</strong>)。</p>
</div>
<div class="paragraph">
<p>但是若您不想用 JSON，我们并不强制您使用它。</p>
</div>
<div class="paragraph">
<p>Event Bus 非常灵活，它支持在 Event Bus 中发送任意对象。您可以通过为您想要发送的对象自定义一个 <code><a href="../../apidocs/io/vertx/core/eventbus/MessageCodec.html">codec</a></code> 来实现。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_api">Event Bus API</h3>
<div class="paragraph">
<p>下面我们来看一下 API。</p>
</div>
<div class="sect3">
<h4 id="_获取event_bus">获取Event Bus</h4>
<div class="paragraph">
<p>您可以通过下面的代码获取 Event Bus 的引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var eb = vertx.eventBus()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每一个 Vert.x 实例来说它是单例的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_注册处理器">注册处理器</h4>
<div class="paragraph">
<p>最简单的注册处理器的方式是使用 <code><a href="../../apidocs/io/vertx/core/eventbus/EventBus.html#consumer-java.lang.String-io.vertx.core.Handler-">consumer</a></code> 方法，
这儿有个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var eb = vertx.eventBus()

eb.consumer&lt;Any&gt;("news.uk.sport", { message -&gt;
  println("I have received a message: ${message.body()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>当一个消息达到您的处理器，该处理器会以 <code><a href="../../apidocs/io/vertx/core/eventbus/Message.html">message</a></code> 为参数被调用。</p>
</div>
<div class="paragraph">
<p>调用 <code>consumer</code> 方法会返回一个 <code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html">MessageConsumer</a></code> 对象。</p>
</div>
<div class="paragraph">
<p>该对象随后可用于撤销处理器、或将处理器用作流式处理。</p>
</div>
<div class="paragraph">
<p>您也可以不设置处理器而使用 <code><a href="../../apidocs/io/vertx/core/eventbus/EventBus.html#consumer-java.lang.String-io.vertx.core.Handler-">consumer</a></code> 方法直接返回一个 <code>MessageConsumer</code>，之后再来设置处理器。如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var eb = vertx.eventBus()

var consumer = eb.consumer&lt;Any&gt;("news.uk.sport")
consumer.handler({ message -&gt;
  println("I have received a message: ${message.body()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>在集群模式下的Event Bus上注册处理器时，注册信息会花费一些时间才能传播到集群中的所有节点。</p>
</div>
<div class="paragraph">
<p>若您希望在完成注册后收到通知，您可以在 <code>MessageConsumer</code> 对象上注册一个 <code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html#completionHandler-io.vertx.core.Handler-">completion handler</a></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">consumer.completionHandler({ res -&gt;
  if (res.succeeded()) {
    println("The handler registration has reached all nodes")
  } else {
    println("Registration failed!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_注销处理器">注销处理器</h4>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html#unregister--">unregister</a></code> 方法来注销处理器。</p>
</div>
<div class="paragraph">
<p>若您在集群模式下的 Event Bus 中撤销处理器，则同样会花费一些时间在节点中传播。若您想在完成后收到通知，可以使用 <code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html#unregister-io.vertx.core.Handler-">unregister</a></code> 方法注册处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">consumer.unregister({ res -&gt;
  if (res.succeeded()) {
    println("The handler un-registration has reached all nodes")
  } else {
    println("Un-registration failed!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_发布消息">发布消息</h4>
<div class="paragraph">
<p>发布消息很简单，只需使用 <code><a href="../../apidocs/io/vertx/core/eventbus/EventBus.html#publish-java.lang.String-java.lang.Object-">publish</a></code> 方法指定一个地址去发布即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">eventBus.publish("news.uk.sport", "Yay! Someone kicked a ball")</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个消息将会传递给所有在地址 <code>news.uk.sport</code> 上注册过的处理器。</p>
</div>
</div>
<div class="sect3">
<h4 id="_发送消息">发送消息</h4>
<div class="paragraph">
<p>与发布消息的不同之处在于，发送(<code>send</code>)的消息只会传递给在该地址注册的其中一个处理器，这就是点对点模式。Vert.x 使用不严格的轮询算法来选择绑定的处理器。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/eventbus/EventBus.html#send-java.lang.String-java.lang.Object-">send</a></code> 方法来发送消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">eventBus.send("news.uk.sport", "Yay! Someone kicked a ball")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_消息顺序">消息顺序</h4>
<div class="paragraph">
<p>Vert.x将按照特定发送者发送消息的顺序来传递消息给特定处理器。</p>
</div>
</div>
<div class="sect3">
<h4 id="_消息对象">消息对象</h4>
<div class="paragraph">
<p>您在消息处理器中接收到的对象的类型是 <code><a href="../../apidocs/io/vertx/core/eventbus/Message.html">Message</a></code> 。</p>
</div>
<div class="paragraph">
<p>消息的 <code><a href="../../apidocs/io/vertx/core/eventbus/Message.html#body--">body</a></code> 对应发送或发布的对象。</p>
</div>
<div class="paragraph">
<p>消息的头信息可以通过 <code><a href="../../apidocs/io/vertx/core/eventbus/Message.html#headers--">headers</a></code> 方法获取。</p>
</div>
</div>
<div class="sect3">
<h4 id="_应答消息_发送回复">应答消息/发送回复</h4>
<div class="paragraph">
<p>当使用 <code><a href="../../apidocs/io/vertx/core/eventbus/EventBus.html#send-java.lang.String-java.lang.Object-">send</a></code> 方法发送消息时，Event Bus会尝试将消息传递到注册在Event Bus上的
<code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html">MessageConsumer</a></code> 中。</p>
</div>
<div class="paragraph">
<p>在某些情况下，发送者需要知道消费者何时收到消息并 <strong>处理</strong> 了消息。</p>
</div>
<div class="paragraph">
<p>消费者可以通过调用 <code><a href="../../apidocs/io/vertx/core/eventbus/Message.html#reply-java.lang.Object-">reply</a></code> 方法来应答这个消息。</p>
</div>
<div class="paragraph">
<p>当这种情况发生时，它会将消息回复给发送者并且在发送者中调用应答处理器来处理回复的消息。</p>
</div>
<div class="paragraph">
<p>看这个例子会更清楚</p>
</div>
<div class="paragraph">
<p>接收者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var consumer = eventBus.consumer&lt;Any&gt;("news.uk.sport")
consumer.handler({ message -&gt;
  println("I have received a message: ${message.body()}")
  message.reply("how interesting!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>发送者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">eventBus.send&lt;Any&gt;("news.uk.sport", "Yay! Someone kicked a ball across a patch of grass", { ar -&gt;
  if (ar.succeeded()) {
    println("Received reply: ${ar.result().body()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>在应答的消息体中可以包含有用的信息。</p>
</div>
<div class="paragraph">
<p>关于 <strong>处理中</strong> 的含义实际上是由应用程序来定义的。这完全取决于消费者如何执行，Event Bus 对此并不关心。</p>
</div>
<div class="paragraph">
<p>一些例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个简单地实现了返回当天时间的服务，在应答的消息里会包含当天时间信息。</p>
</li>
<li>
<p>一个实现了持久化队列的消息消费者，当消息成功持久化到存储时，可以使用 <code>true</code> 来应答消息，或 <code>false</code> 表示失败。</p>
</li>
<li>
<p>一个处理订单的消息消费者也许会用 <code>true</code> 确认这个订单已经成功处理并且可以从数据库中删除。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_带超时的发送">带超时的发送</h4>
<div class="paragraph">
<p>当发送带有应答处理器的消息时，可以在 <code><a href="../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html">DeliveryOptions</a></code> 中指定一个超时时间。</p>
</div>
<div class="paragraph">
<p>如果在这个时间之内没有收到应答，则会以失败为参数调用应答处理器。</p>
</div>
<div class="paragraph">
<p>默认超时是 <strong>30 秒</strong>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_发送失败">发送失败</h4>
<div class="paragraph">
<p>消息发送可能会因为其他原因失败，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有可用的处理器来接收消息</p>
</li>
<li>
<p>接收者调用了 <code><a href="../../apidocs/io/vertx/core/eventbus/Message.html#fail-int-java.lang.String-">fail</a></code> 方法显式声明失败</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>发生这些情况时，应答处理器将会以这些失败为参数被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_集群模式的_event_bus">集群模式的 Event Bus</h4>
<div class="paragraph">
<p>Event Bus 不仅仅存在于单个 Vert.x 实例中。通过您在网络上将不同的 Vert.x 实例集群在一起，它可以形成一个单一的、分布式的Event Bus。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过代码的方式启用集群模式">通过代码的方式启用集群模式</h4>
<div class="paragraph">
<p>若您用编程的方式创建 Vert.x 实例（<code>Vertx</code>），则可以通过将 Vert.x 实例配置成集群模式来获取集群模式的Event Bus：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = VertxOptions()
Vertx.clusteredVertx(options, { res -&gt;
  if (res.succeeded()) {
    var vertx = res.result()
    var eventBus = vertx.eventBus()
    println("We now have a clustered event bus: ${eventBus}")
  } else {
    println("Failed: ${res.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>您需要确在您的 classpath 中（或构建工具的依赖中）包含 <code><a href="../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html">ClusterManager</a></code> 的实现类，如默认的 <code>HazelcastClusterManager</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过命令行启用集群模式">通过命令行启用集群模式</h4>
<div class="paragraph">
<p>您可以通过以下命令以集群模式运行 Vert.x 应用：</p>
</div>
<div class="paragraph">
<p>vertx run my-verticle.js -cluster</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_中的自动清理">Verticle 中的自动清理</h3>
<div class="paragraph">
<p>若您在 Verticle 中注册了 Event Bus 的处理器，那么这些处理器在 Verticle 被撤销的时候会自动被注销。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置_event_bus">配置 Event Bus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Event Bus 是可以配置的，这对于以集群模式运行的 Event Bus 是非常有用的。Event Bus 使用 TCP 连接发送和接收消息，因此可以通过
<code><a href="../../apidocs/io/vertx/core/eventbus/EventBusOptions.html">EventBusOptions</a></code> 对TCP连接进行全面的配置。由于 Event Bus 同时用作客户端和服务器，因此这些配置近似于
<code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html">NetClientOptions</a></code> 和 <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html">NetServerOptions</a></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = VertxOptions(
  eventBusOptions = EventBusOptions(
    ssl = true,
    keyStoreOptions = JksOptions(
      path = "keystore.jks",
      password = "wibble"),
    trustStoreOptions = JksOptions(
      path = "keystore.jks",
      password = "wibble"),
    clientAuth = ClientAuth.REQUIRED))

Vertx.clusteredVertx(options, { res -&gt;
  if (res.succeeded()) {
    var vertx = res.result()
    var eventBus = vertx.eventBus()
    println("We now have a clustered event bus: ${eventBus}")
  } else {
    println("Failed: ${res.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>上边代码段描述了如何在Event Bus中使用SSL连接替换传统的TCP连接。</p>
</div>
<div class="paragraph">
<p><strong>WARNING</strong>: 若要在集群模式下保证安全性，您 <strong>必须</strong> 将集群管理器配置成加密的或强制安全的。参考集群管理器的文档获取更多细节。</p>
</div>
<div class="paragraph">
<p>Event Bus 的配置需要在所有集群节点中保持一致性。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/eventbus/EventBusOptions.html">EventBusOptions</a></code> 还允许您指定 Event Bus 是否运行在集群模式下，以及它的主机信息和端口。您可使用
<code><a href="../../apidocs/io/vertx/core/VertxOptions.html#setClustered-boolean-">setClustered</a></code> 、
<code><a href="../../apidocs/io/vertx/core/VertxOptions.html#getClusterHost--">getClusterHost</a></code> 和 <code><a href="../../apidocs/io/vertx/core/VertxOptions.html#getClusterPort--">getClusterPort</a></code> 方法来设置。</p>
</div>
<div class="paragraph">
<p>在容器中使用时，您也可以配置公共主机和端口号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = VertxOptions(
  eventBusOptions = EventBusOptions(
    clusterPublicHost = "whatever",
    clusterPublicPort = 1234))

Vertx.clusteredVertx(options, { res -&gt;
  if (res.succeeded()) {
    var vertx = res.result()
    var eventBus = vertx.eventBus()
    println("We now have a clustered event bus: ${eventBus}")
  } else {
    println("Failed: ${res.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_json">JSON</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unlike some other languages, Java does not have first class support for <a href="http://json.org/">JSON</a> so we provide
two classes to make handling JSON in your Vert.x applications a bit easier.</p>
</div>
<div class="paragraph">
<p>Use the <code><a href="../../apidocs/io/vertx/core/json/JsonObject.html">JsonObject</a></code> class to represent JSON objects and the <code><a href="../../apidocs/io/vertx/core/json/JsonArray.html">JsonArray</a></code>
class to represent JSON arrays, you can refer to the Java documentation for more details.</p>
</div>
<div class="sect2">
<h3 id="_builders">Builders</h3>
<div class="paragraph">
<p>Builders are provided to provide a more fluent JSON construction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// The json builder declares a JSON structure
val result = json {

 // in this structure the obj function can be used

 // takes a vararg of Kotlin pairs
 obj(
   "key_1" to 1,
   "key_2" to 2,
   "key_3" to 3
 )

 // or an iterable of Kotlin pairs
 obj((1..3).map { "key_$it" to it })

 // or a Map&lt;String, Any?&gt;
 obj(someMap)

 // apply function on object receiver
 obj {
   for (i in 1..3) {
     put("key_$i", i)
   }
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also build JSON arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// The json builder declares a JSON structure
val result = json {

 // in this structure the array function can be used

 // takes a vararg of values
 array("1", "2", "3")

 // or an iterable of values
 array((1..3).map { "$it" })

 // apply function on array receiver
 array {
   for (i in 1..3) {
     add("$i")
   }
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course it is possible to mix objects and arrays</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// The json builder declares a JSON structure
val result = json {

 "firstName" to "Dale",
 "lastName" to "Cooper",
 "age" to 64,
 "names" to array("Dale", "Bartholomew")
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_postscript_operator_overloading">Postscript operator overloading</h3>
<div class="paragraph">
<p>The Kotlin postscript operator is overloaded for JSON object and array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">print(someObject["firstName"]);
print(someArray[4]);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buffers">Buffers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Vert.x 内部，大部分数据被重新组织（shuffle，表意为洗牌）成 <code>Buffer</code> 格式。</p>
</div>
<div class="paragraph">
<p>一个 <code>Buffer</code> 是可以读取或写入的0个或多个字节序列，并且根据需要可以自动扩容、将任意字节写入 <code>Buffer</code> 。您也可以将 <code>Buffer</code> 想象成字节数组（译者注：类似于 JDK 中的 <code>ByteBuffer</code> ）。</p>
</div>
<div class="sect2">
<h3 id="_创建_buffer">创建 Buffer</h3>
<div class="paragraph">
<p>可以使用静态方法 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html#buffer--">Buffer.buffer</a></code> 来创建 <code>Buffer</code> 。</p>
</div>
<div class="paragraph">
<p><code>Buffer</code> 可以从字符串或字节数组初始化，或者直接创建空的 <code>Buffer</code> 。</p>
</div>
<div class="paragraph">
<p>这儿有一些创建 <code>Buffer</code> 的例子。</p>
</div>
<div class="paragraph">
<p>创建一个空的 <code>Buffer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer()</code></pre>
</div>
</div>
<div class="paragraph">
<p>从字符串创建一个 <code>Buffer</code> ， 这个 <code>Buffer</code> 中的字符会以 UTF-8 格式编码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer("some string")</code></pre>
</div>
</div>
<div class="paragraph">
<p>从字符串创建一个 <code>Buffer</code> ，这个字符串可以用指定的编码方式编码，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer("some string", "UTF-16")</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个指定初始大小的 <code>Buffer</code> 。若您知道您的 <code>Buffer</code> 会写入一定量的数据，您可以创建 <code>Buffer</code> 并指定它的大小。
这使得这个 <code>Buffer</code> 初始化时分配了更多的内存，比数据写入时重新调整大小的效率更高。</p>
</div>
<div class="paragraph">
<p>注意以这种方式创建的 <code>Buffer</code> 是 <strong>空的</strong>。它不会创建一个填满了 0 的Buffer。代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer(10000)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_向buffer写入数据">向Buffer写入数据</h3>
<div class="paragraph">
<p>向 <code>Buffer</code> 写入数据的方式有两种：追加和随机写入。任何一种情况下 <code>Buffer</code> 都会自动进行扩容，所以不可能在使用 <code>Buffer</code> 时遇到 <code>IndexOutOfBoundsException</code> 。</p>
</div>
<div class="sect3">
<h4 id="_追加到buffer">追加到Buffer</h4>
<div class="paragraph">
<p>您可以使用 <code>appendXXX</code> 方法追加数据到 <code>Buffer</code> 。 <code>Buffer</code> 类提供了追加各种不同类型数据的追加写入方法。</p>
</div>
<div class="paragraph">
<p>因为 <code>appendXXX</code> 方法的返回值就是 Buffer 自身，所以它可以链式地调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer()

buff.appendInt(123).appendString("hello\n")

socket.write(buff)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_随机访问写buffer">随机访问写Buffer</h4>
<div class="paragraph">
<p>您还可以指定一个索引值，通过 <code>setXXX</code> 方法写入数据到 <code>Buffer</code> ，它也存在各种不同数据类型的方法。
所有的 set 方法都会将索引值作为第一个参数 —— 这表示 <code>Buffer</code> 中开始写入数据的位置。</p>
</div>
<div class="paragraph">
<p><code>Buffer</code> 始终根据需要进行自动扩容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer()

buff.setInt(1000, 123)
buff.setString(0, "hello")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_从buffer中读取">从Buffer中读取</h3>
<div class="paragraph">
<p>可使用 <code>getXXX</code> 方法从 Buffer 中读取数据，它存在各种不同数据类型的方法，这些方法的第一个参数是从哪里获取数据的索引（获取位置）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer()
var i = 0
while (i &lt; buff.length()) {
  println("int value at ${i} is ${buff.getInt(i)}")

  4}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用无符号数">使用无符号数</h3>
<div class="paragraph">
<p>可使用 <code>getUnsignedXXX</code> ,
<code>appendUnsignedXXX</code> 和 <code>setUnsignedXXX</code> 方法将无符号数从 <code>Buffer</code> 中读取或追加/设置到 <code>Buffer</code> 里。这对以优化网络协议和最小化带宽消耗为目的实现的编解码器是很有用的。</p>
</div>
<div class="paragraph">
<p>下边例子中，值 200 被设置到了仅占用一个字节的特定位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var buff = Buffer.buffer(128)
var pos = 15
buff.setUnsignedByte(pos, 200)
println(buff.getUnsignedByte(pos))</code></pre>
</div>
</div>
<div class="paragraph">
<p>控制台中显示 <code>200</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_buffer长度">Buffer长度</h3>
<div class="paragraph">
<p>可使用 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html#length--">length</a></code> 方法获取Buffer长度，Buffer的长度值是Buffer中包含的字节的最大索引 + 1。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拷贝buffer">拷贝Buffer</h3>
<div class="paragraph">
<p>可使用 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html#copy--">copy</a></code> 方法创建一个Buffer的副本。</p>
</div>
</div>
<div class="sect2">
<h3 id="_裁剪buffer">裁剪Buffer</h3>
<div class="paragraph">
<p>裁剪得到的Buffer是基于原始Buffer的一个新的Buffer。它不会拷贝实际的数据。使用 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html#slice--">slice</a></code> 方法裁剪一个Buffer。</p>
</div>
</div>
<div class="sect2">
<h3 id="_buffer_重用">Buffer 重用</h3>
<div class="paragraph">
<p>将Buffer写入到一个Socket或其他类似位置后，Buffer就不可被重用了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x允许您很容易编写非阻塞的TCP客户端和服务器。</p>
</div>
<div class="sect2">
<h3 id="_创建_tcp_服务端">创建 TCP 服务端</h3>
<div class="paragraph">
<p>最简单地使用所有默认配置项创建 TCP 服务端的方式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_tcp_服务端">配置 TCP 服务端</h3>
<div class="paragraph">
<p>若您不想使用默认配置，可以在创建时通过传入一个 <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html">NetServerOptions</a></code>
实例来配置服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  port = 4321)
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_启动服务端监听">启动服务端监听</h3>
<div class="paragraph">
<p>要告诉服务端监听传入的请求，您可以使用其中一个 <code><a href="../../apidocs/io/vertx/core/net/NetServer.html#listen--">listen</a></code>
方法。</p>
</div>
<div class="paragraph">
<p>让服务器监听配置项指定的主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer()
server.listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在调用 <code>listen</code> 方法时指定主机和端口号，忽略配置项中的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer()
server.listen(1234, "localhost")</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认主机名是 <code>0.0.0.0</code> ，它表示：监听所有可用地址。默认端口号是 <code>0</code> ，这也是一个特殊值，它告诉服务器随机选择并监听一个本地没有被占用的端口。</p>
</div>
<div class="paragraph">
<p>实际的绑定也是异步的，因此服务器在调用了 <code>listen</code> 方法的一段时间之后才会实际开始监听。</p>
</div>
<div class="paragraph">
<p>若您希望在服务器实际监听时收到通知，您可以在调用 <code>listen</code> 方法时提供一个处理器。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer()
server.listen(1234, "localhost", { res -&gt;
  if (res.succeeded()) {
    println("Server is now listening!")
  } else {
    println("Failed to bind!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_监听随机端口">监听随机端口</h3>
<div class="paragraph">
<p>若设置监听端口为 <code>0</code> ，服务器将随机寻找一个没有使用的端口来监听。</p>
</div>
<div class="paragraph">
<p>可以调用 <code><a href="../../apidocs/io/vertx/core/net/NetServer.html#actualPort--">actualPort</a></code> 方法来获得服务器实际监听的端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer()
server.listen(0, "localhost", { res -&gt;
  if (res.succeeded()) {
    println("Server is now listening on actual port: ${server.actualPort()}")
  } else {
    println("Failed to bind!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_接收传入连接的通知">接收传入连接的通知</h3>
<div class="paragraph">
<p>若您想要在连接创建完时收到通知，则需要设置一个 <code><a href="../../apidocs/io/vertx/core/net/NetServer.html#connectHandler-io.vertx.core.Handler-">connectHandler</a></code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer()
server.connectHandler({ socket -&gt;
  // Handle the connection in here
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>当连接成功时，您可以在回调函数中处理得到的 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 实例。</p>
</div>
<div class="paragraph">
<p>这是一个代表了实际连接的套接字接口，它允许您读取和写入数据、以及执行各种其他操作，如关闭 Socket。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从socket读取数据">从Socket读取数据</h3>
<div class="paragraph">
<p>您可以在Socket上调用 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#handler-io.vertx.core.Handler-">handler</a></code> 方法来设置用于读取数据的处理器。</p>
</div>
<div class="paragraph">
<p>每次 Socket 接收到数据时，会以 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code> 对象为参数调用处理器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer()
server.connectHandler({ socket -&gt;
  socket.handler({ buffer -&gt;
    println("I received some bytes: ${buffer.length()}")
  })
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_向socket中写入数据">向Socket中写入数据</h3>
<div class="paragraph">
<p>您可使用 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#write-io.vertx.core.buffer.Buffer-">write</a></code> 方法写入数据到Socket：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Write a buffer
var buffer = Buffer.buffer().appendFloat(12.34f).appendInt(123)
socket.write(buffer)

// Write a string in UTF-8 encoding
socket.write("some data")

// Write a string using the specified encoding
socket.write("some data", "UTF-16")</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入操作是异步的，可能调用 <code>write</code> 方法返回过后一段时间才会发生。</p>
</div>
</div>
<div class="sect2">
<h3 id="_关闭处理器">关闭处理器</h3>
<div class="paragraph">
<p>若您想要在 Socket 关闭时收到通知，可以设置一个 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#closeHandler-io.vertx.core.Handler-">closeHandler</a></code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">socket.closeHandler({ v -&gt;
  println("The socket has been closed")
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理异常">处理异常</h3>
<div class="paragraph">
<p>您可以设置一个 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#exceptionHandler-io.vertx.core.Handler-">exceptionHandler</a></code> 用以在发生任何异常的时候接收异常信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_写处理器">Event Bus 写处理器</h3>
<div class="paragraph">
<p>每个 Socket 会自动在Event Bus中注册一个处理器，当这个处理器中收到任意 <code>Buffer</code> 时，它会将数据写入到 Socket。</p>
</div>
<div class="paragraph">
<p>这意味着您可以通过向这个地址发送 <code>Buffer</code> 的方式，从不同的 Verticle 甚至是不同的 Vert.x 实例中向指定的 Socket 发送数据。</p>
</div>
<div class="paragraph">
<p>处理器的地址由 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#writeHandlerID--">writeHandlerID</a></code> 方法提供。</p>
</div>
</div>
<div class="sect2">
<h3 id="_本地和远程地址">本地和远程地址</h3>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#localAddress--">localAddress</a></code> 方法获取 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 的本地地址，</p>
</div>
<div class="paragraph">
<p>通过 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#remoteAddress--">remoteAddress</a></code> 方法获取 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 的远程地址（即连接的另一端的地址）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</h3>
<div class="paragraph">
<p>您可以直接通过 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#sendFile-java.lang.String-">sendFile</a></code> 方法将文件和 classpath 中的资源写入Socket。
这种做法是非常高效的，它可以被操作系统内核直接处理。</p>
</div>
<div class="paragraph">
<p>请阅读 <a href="#classpath">从 Classpath 访问文件</a> 章节了解类路径的限制或禁用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">socket.sendFile("myfile.dat")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_流式的socket">流式的Socket</h3>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 接口继承了 <code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 和
<code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 接口，因此您可以将它套用（pump）到其他的读写流上。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅 <a href="#streams">流和管道</a>  章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</h3>
<div class="paragraph">
<p>一个非SSL/TLS连接可以通过 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html#upgradeToSsl-io.vertx.core.Handler-">upgradeToSsl</a></code> 方法升级到SSL/TLS连接。</p>
</div>
<div class="paragraph">
<p>必须为服务器或客户端配置SSL/TLS才能正常工作。请参阅 <a href="#ssl">SSL/TLS</a> 章节来获取详细信息。
for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_关闭_tcp_服务端">关闭 TCP 服务端</h3>
<div class="paragraph">
<p>您可以调用 <code><a href="../../apidocs/io/vertx/core/net/NetServer.html#close--">close</a></code> 方法关闭服务端。关闭操作将关闭所有打开的连接并释放所有服务端资源。</p>
</div>
<div class="paragraph">
<p>关闭操作也是异步的，可能直到方法调用返回过后一段时间才会实际关闭。若您想在实际关闭完成时收到通知，那么您可以传递一个处理器。</p>
</div>
<div class="paragraph">
<p>当关闭操作完成后，绑定的处理器将被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">server.close({ res -&gt;
  if (res.succeeded()) {
    println("Server is now closed")
  } else {
    println("close failed")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle中的自动清理">Verticle中的自动清理</h3>
<div class="paragraph">
<p>若您在 Verticle 内创建了 TCP 服务端和客户端，它们将会在Verticle 撤销时自动被关闭。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</h3>
<div class="paragraph">
<p>任意一个 TCP 服务端中的处理器总是在相同的 Event Loop 线程上执行。</p>
</div>
<div class="paragraph">
<p>这意味着如果您在多核的服务器上运行，并且只部署了一个实例，那么您的服务器上最多只能使用一个核。</p>
</div>
<div class="paragraph">
<p>为了利用更多的服务器核，您将需要部署更多的服务器实例。</p>
</div>
<div class="paragraph">
<p>您可以在代码中以编程方式实例化更多（Server的）实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create a few instances so we can utilise cores

for (i in 0 until 10) {
  var server = vertx.createNetServer()
  server.connectHandler({ socket -&gt;
    socket.handler({ buffer -&gt;
      // Just echo back the data
      socket.write(buffer)
    })
  })
  server.listen(1234, "localhost")

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用的是 Verticle，您可以通过在命令行上使用 <code>-instances</code> 选项来简单部署更多的服务器实例：</p>
</div>
<div class="paragraph">
<p>vertx run com.mycompany.MyVerticle -instances 10</p>
</div>
<div class="paragraph">
<p>或者使用编程方式部署您的 Verticle 时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = DeploymentOptions(
  instances = 10)
vertx.deployVerticle("com.mycompany.MyVerticle", options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦您这样做，您将发现echo服务器在功能上与之前相同，但是服务器上的所有核都可以被利用，并且可以处理更多的工作。</p>
</div>
<div class="paragraph">
<p>在这一点上，您可能会问自己：<strong>如何让多台服务器在同一主机和端口上侦听？尝试部署一个以上的实例时真的不会遇到端口冲突吗？</strong></p>
</div>
<div class="paragraph">
<p><strong>Vert.x在这里有一点魔法。</strong></p>
</div>
<div class="paragraph">
<p>当您在与现有服务器相同的主机和端口上部署另一个服务器实例时，实际上它并不会尝试创建在同一主机/端口上侦听的新服务器实例。</p>
</div>
<div class="paragraph">
<p>相反，它内部仅仅维护一个服务器实例。当传入新的连接时，它以轮询的方式将其分发给任意一个连接处理器处理。</p>
</div>
<div class="paragraph">
<p>因此，Vert.x TCP 服务端可以水平扩展到多个核，并且每个实例保持单线程环境不变。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建_tcp_客户端">创建 TCP 客户端</h3>
<div class="paragraph">
<p>使用所有默认选项创建 TCP 客户端的最简单方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createNetClient()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_tcp_客户端">配置 TCP 客户端</h3>
<div class="paragraph">
<p>如果您不想使用默认值，则可以在创建实例时传入 <code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html">NetClientOptions</a></code>
给客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  connectTimeout = 10000)
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建连接">创建连接</h3>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/net/NetClient.html#connect-int-java.lang.String-io.vertx.core.Handler-">connect</a></code> ,
方法创建到服务器的连接。请指定服务器的端口和主机，以及用于处理
<code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 的处理器。当连接成功或失败时处理器会被调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  connectTimeout = 10000)
var client = vertx.createNetClient(options)
client.connect(4321, "localhost", { res -&gt;
  if (res.succeeded()) {
    println("Connected!")
    var socket = res.result()
  } else {
    println("Failed to connect: ${res.cause().getMessage()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置连接重试">配置连接重试</h3>
<div class="paragraph">
<p>可以将客户端配置为在无法连接的情况下自动重试。
这是通过 <code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html#setReconnectInterval-long-">setReconnectInterval</a></code> 和
<code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html#setReconnectAttempts-int-">setReconnectAttempts</a></code> 方法配置的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>注意：目前如果连接失效，Vert.x将不尝试重新连接。重新连接尝试和时间间隔仅适用于创建初始连接。</strong>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  reconnectAttempts = 10,
  reconnectInterval = 500)

var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，多个连接尝试是被禁用的。</p>
</div>
</div>
<div class="sect2">
<h3 id="logging_network_activity">记录网络活动</h3>
<div class="paragraph">
<p>网络活动可以被记录下来，用于调试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  logActivity = true)

var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  logActivity = true)

var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Netty 使用 <code>DEBUG</code> 级别和 <code>io.netty.handler.logging.LoggingHandler</code> 名称来记录网络活动。使用网络活动记录时，需要注意以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日志的记录是由Netty而不是Vert.x的日志来执行</p>
</li>
<li>
<p>这个功能不能用于生产环境</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您应该阅读 <a href="#netty-logging">Netty 日志记录</a> 章节来了解详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="ssl">配置服务端和客户端以使用SSL/TLS</h3>
<div class="paragraph">
<p>TCP 客户端和服务端可以通过配置来使用 <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">TLS（传输层安全性协议）</a>
。早期版本的TLS被称为SSL。</p>
</div>
<div class="paragraph">
<p>无论是否使用SSL/TLS，服务器和客户端的API都是相同的。通过创建客户端/服务器时使用的 <code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html">NetClientOptions</a></code> 或 <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html">NetServerOptions</a></code> 来启用TLS/SSL。</p>
</div>
<div class="sect3">
<h4 id="_在服务端启用ssl_tls">在服务端启用SSL/TLS</h4>
<div class="paragraph">
<p>您需要设置 <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html#setSsl-boolean-">ssl</a></code> 配置项来启用 SSL/TLS。</p>
</div>
<div class="paragraph">
<p>默认是禁用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_指定服务端的密钥_证书">指定服务端的密钥/证书</h4>
<div class="paragraph">
<p>SSL/TLS 服务端通常向客户端提供证书，以便验证服务端的身份。</p>
</div>
<div class="paragraph">
<p>可以通过以下几种方式为服务端配置证书/密钥：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含证书和私钥的Java密钥库位置。</p>
</div>
<div class="paragraph">
<p>可以使用 JDK 附带的 <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
实用程序来管理Java密钥存储。</p>
</div>
<div class="paragraph">
<p>还应提供密钥存储的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  ssl = true,
  keyStoreOptions = JksOptions(
    path = "/path/to/your/server-keystore.jks",
    password = "password-of-your-keystore"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以自己读取密钥库到一个 <code>Buffer</code> ，并将它直接提供给 <code>JksOptions</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.jks")
var jksOptions = JksOptions(
  value = myKeyStoreAsABuffer,
  password = "password-of-your-keystore")
var options = NetServerOptions(
  ssl = true,
  keyStoreOptions = jksOptions)
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  ssl = true,
  pfxKeyCertOptions = PfxOptions(
    path = "/path/to/your/server-keystore.pfx",
    password = "password-of-your-keystore"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.pfx")
var pfxOptions = PfxOptions(
  value = myKeyStoreAsABuffer,
  password = "password-of-your-keystore")
var options = NetServerOptions(
  ssl = true,
  pfxKeyCertOptions = pfxOptions)
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外一种分别提供服务器私钥和证书的方法是使用 <code>.pem</code> 文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  ssl = true,
  pemKeyCertOptions = PemKeyCertOptions(
    keyPath = "/path/to/your/server-key.pem",
    certPath = "/path/to/your/server-cert.pem"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-key.pem")
var myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-cert.pem")
var pemOptions = PemKeyCertOptions(
  keyValue = myKeyAsABuffer,
  certValue = myCertAsABuffer)
var options = NetServerOptions(
  ssl = true,
  pemKeyCertOptions = pemOptions)
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS8, PKCS1 and X.509 certificates wrapped in a PEM block formats are supported.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
请记住pem的配置和私钥是不加密的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_指定服务器信任">指定服务器信任</h4>
<div class="paragraph">
<p>SSL/TLS 服务端可以使用证书颁发机构来验证客户端的身份。</p>
</div>
<div class="paragraph">
<p>证书颁发机构可通过多种方式为服务端配置。</p>
</div>
<div class="paragraph">
<p>可使用JDK随附的 <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
实用程序来管理Java 受信存储。</p>
</div>
<div class="paragraph">
<p>还应提供受信存储的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  ssl = true,
  clientAuth = ClientAuth.REQUIRED,
  trustStoreOptions = JksOptions(
    path = "/path/to/your/truststore.jks",
    password = "password-of-your-truststore"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您可以自己读取受信存储到 <code>Buffer</code> ，并将它直接提供：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks")
var options = NetServerOptions(
  ssl = true,
  clientAuth = ClientAuth.REQUIRED,
  trustStoreOptions = JksOptions(
    value = myTrustStoreAsABuffer,
    password = "password-of-your-truststore"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  ssl = true,
  clientAuth = ClientAuth.REQUIRED,
  pfxTrustOptions = PfxOptions(
    path = "/path/to/your/truststore.pfx",
    password = "password-of-your-truststore"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx")
var options = NetServerOptions(
  ssl = true,
  clientAuth = ClientAuth.REQUIRED,
  pfxTrustOptions = PfxOptions(
    value = myTrustStoreAsABuffer,
    password = "password-of-your-truststore"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种提供服务器证书颁发机构的方法是使用一个 <code>.pem</code> 文件列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  ssl = true,
  clientAuth = ClientAuth.REQUIRED,
  pemTrustOptions = PemTrustOptions(
    certPaths = listOf("/path/to/your/server-ca.pem")))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myCaAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-ca.pfx")
var options = NetServerOptions(
  ssl = true,
  clientAuth = ClientAuth.REQUIRED,
  pemTrustOptions = PemTrustOptions(
    certValues = listOf(myCaAsABuffer)))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端启用ssl_tls">客户端启用SSL/TLS</h4>
<div class="paragraph">
<p>客户端也可以轻松地配置为SSL。使用SSL和使用标准套接字具有完全相同的API。</p>
</div>
<div class="paragraph">
<p>若要启用 <code>NetClient</code> 上的SSL，可调用函数 <code>setSSL(true)</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_客户端受信配置">客户端受信配置</h4>
<div class="paragraph">
<p>若客户端将 <code><a href="../../apidocs/io/vertx/core/net/ClientOptionsBase.html#setTrustAll-boolean-">trustALl</a></code> 设置为 <code>true</code> ，则客户端将信任所有服务端证书。
连接仍然会被加密，但这种模式很容易受到中间人攻击。即您无法确定您正连接到谁，请谨慎使用。默认值为 <code>false</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  trustAll = true)
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>若客户端没有设置 <code><a href="../../apidocs/io/vertx/core/net/ClientOptionsBase.html#setTrustAll-boolean-">trustAll</a></code> ，则必须配置客户端受信存储，并且受信客户端应该包含服务器的证书。</p>
</div>
<div class="paragraph">
<p>默认情况下，客户端禁用主机验证。要启用主机验证，请在客户端上设置使用的算法（目前仅支持HTTPS和LDAPS）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  hostnameVerificationAlgorithm = "HTTPS")
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>和服务器配置相同，也可通过以下几种方式配置受信客户端：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含证书颁发机构的Java受信库的位置。</p>
</div>
<div class="paragraph">
<p>它只是一个标准的Java密钥存储，与服务器端的密钥存储相同。通过在
<code><a href="../../apidocs/io/vertx/core/net/JksOptions.html">jks options</a></code> 上使用 <code><a href="../../apidocs/io/vertx/core/net/JksOptions.html#setPath-java.lang.String-">path</a></code>
设置客户端受信存储位置。如果服务器在连接期间提供不在客户端受信存储中的证书，则尝试连接将不会成功。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  trustStoreOptions = JksOptions(
    path = "/path/to/your/truststore.jks",
    password = "password-of-your-truststore"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>它也支持 <code>Buffer</code> 的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks")
var options = NetClientOptions(
  ssl = true,
  trustStoreOptions = JksOptions(
    value = myTrustStoreAsABuffer,
    password = "password-of-your-truststore"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  pfxTrustOptions = PfxOptions(
    path = "/path/to/your/truststore.pfx",
    password = "password-of-your-truststore"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx")
var options = NetClientOptions(
  ssl = true,
  pfxTrustOptions = PfxOptions(
    value = myTrustStoreAsABuffer,
    password = "password-of-your-truststore"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种提供服务器证书颁发机构的方法是使用一个 <code>.pem</code> 文件列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  pemTrustOptions = PemTrustOptions(
    certPaths = listOf("/path/to/your/ca-cert.pem")))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/ca-cert.pem")
var options = NetClientOptions(
  ssl = true,
  pemTrustOptions = PemTrustOptions(
    certValues = listOf(myTrustStoreAsABuffer)))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_指定客户端的密钥_证书">指定客户端的密钥/证书</h4>
<div class="paragraph">
<p>如果服务器需要客户端认证，那么当连接时，客户端必须向服务器提供自己的证书。可通过以下几种方式配置客户端：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含密钥和证书的Java 密钥库的位置，它只是一个常规的Java 密钥存储。使用 <code><a href="../../apidocs/io/vertx/core/net/JksOptions.html">jks options</a></code> 上的功能路径设置客户端密钥库位置 <code><a href="../../apidocs/io/vertx/core/net/JksOptions.html#setPath-java.lang.String-">path</a></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  keyStoreOptions = JksOptions(
    path = "/path/to/your/client-keystore.jks",
    password = "password-of-your-keystore"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.jks")
var jksOptions = JksOptions(
  value = myKeyStoreAsABuffer,
  password = "password-of-your-keystore")
var options = NetClientOptions(
  ssl = true,
  keyStoreOptions = jksOptions)
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  pfxKeyCertOptions = PfxOptions(
    path = "/path/to/your/client-keystore.pfx",
    password = "password-of-your-keystore"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.pfx")
var pfxOptions = PfxOptions(
  value = myKeyStoreAsABuffer,
  password = "password-of-your-keystore")
var options = NetClientOptions(
  ssl = true,
  pfxKeyCertOptions = pfxOptions)
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种单独提供服务器私钥和证书的方法是使用 <code>.pem</code> 文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  pemKeyCertOptions = PemKeyCertOptions(
    keyPath = "/path/to/your/client-key.pem",
    certPath = "/path/to/your/client-cert.pem"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-key.pem")
var myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-cert.pem")
var pemOptions = PemKeyCertOptions(
  keyValue = myKeyAsABuffer,
  certValue = myCertAsABuffer)
var options = NetClientOptions(
  ssl = true,
  pemKeyCertOptions = pemOptions)
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住 <code>pem</code> 的配置和私钥是不加密的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_用于测试和开发目的的自签名证书">用于测试和开发目的的自签名证书</h4>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
不要在生产设置中使用，这里生成的密钥非常不安全。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在运行单元/集成测试或是运行开发版的应用程序时都经常需要自签名证书。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/net/SelfSignedCertificate.html">SelfSignedCertificate</a></code> 可用于提供自签名PEM证书，并可以提供
give <code><a href="../../apidocs/io/vertx/core/net/KeyCertOptions.html">KeyCertOptions</a></code> 和 <code><a href="../../apidocs/io/vertx/core/net/TrustOptions.html">TrustOptions</a></code> configurations 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var certificate = SelfSignedCertificate.create()

var serverOptions = NetServerOptions(
  ssl = true,
  keyCertOptions = certificate.keyCertOptions(),
  trustOptions = certificate.trustOptions())

var server = vertx.createNetServer(serverOptions).connectHandler({ socket -&gt;
  socket.write("Hello!").end()
}).listen(1234, "localhost")

var clientOptions = NetClientOptions(
  ssl = true,
  keyCertOptions = certificate.keyCertOptions(),
  trustOptions = certificate.trustOptions())

var client = vertx.createNetClient(clientOptions)
client.connect(1234, "localhost", { ar -&gt;
  if (ar.succeeded()) {
    ar.result().handler({ buffer -&gt;
      println(buffer)
    })
  } else {
    System.err.println("Woops: ${ar.cause().getMessage()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户端也可配置为信任所有证书：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var clientOptions = NetClientOptions(
  ssl = true,
  trustAll = true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>自签名证书也适用于其他基于TCP的协议，如HTTPS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var certificate = SelfSignedCertificate.create()

vertx.createHttpServer(HttpServerOptions(
  ssl = true,
  keyCertOptions = certificate.keyCertOptions(),
  trustOptions = certificate.trustOptions())).requestHandler({ req -&gt;
  req.response().end("Hello!")
}).listen(8080)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_待撤销证书颁发机构">待撤销证书颁发机构</h4>
<div class="paragraph">
<p>可以通过配置证书吊销列表（CRL）来吊销不再被信任的证书机构。 <code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html#addCrlPath-java.lang.String-">crlPath</a></code> 配置了使用的CRL：
the crl list to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  ssl = true,
  trustStoreOptions = trustOptions,
  crlPaths = listOf("/path/to/your/crl.pem"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var myCrlAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/crl.pem")
var options = NetClientOptions(
  ssl = true,
  trustStoreOptions = trustOptions,
  crlValues = listOf(myCrlAsABuffer))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置密码套件">配置密码套件</h4>
<div class="paragraph">
<p>默认情况下，TLS配置将使用运行Vert.x的JVM 密码套件，该密码套件可以配置一套启用的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetServerOptions(
  ssl = true,
  keyStoreOptions = keyStoreOptions,
  enabledCipherSuites = listOf("ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-ECDSA-AES128-GCM-SHA256", "ECDHE-RSA-AES256-GCM-SHA384", "CDHE-ECDSA-AES256-GCM-SHA384"))
var server = vertx.createNetServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>密码套件可在 <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html">NetServerOptions</a></code> 或 <code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html">NetClientOptions</a></code> 配置项中指定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置tls协议版本">配置TLS协议版本</h4>
<div class="paragraph">
<p>默认情况下，TLS配置将使用以下协议版本：SSLv2Hello、TLSv1、TLSv1.1 和 TLSv1.2。 协议版本可以通过显式添加启用协议进行配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Code not translatable</code></pre>
</div>
</div>
<div class="paragraph">
<p>协议版本可在 <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html">NetServerOptions</a></code> 或 <code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html">NetClientOptions</a></code> 配置项中指定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ssl引擎">SSL引擎</h4>
<div class="paragraph">
<p>引擎实现可以配置为使用 <a href="https://www.openssl.org">OpenSSL</a> 而不是JDK实现（来支持SSL）。 OpenSSL提供比JDK引擎更好的性能和CPU使用率、以及JDK版本独立性。</p>
</div>
<div class="paragraph">
<p>引擎选项可使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当 <code><a href="../../apidocs/io/vertx/core/net/TCPSSLOptions.html#getSslEngineOptions--">getSslEngineOptions</a></code> 被设置时，使用该选项</p>
</li>
<li>
<p>否则使用 <code><a href="../../apidocs/io/vertx/core/net/JdkSSLEngineOptions.html">JdkSSLEngineOptions</a></code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Use JDK SSL engine
var options = NetServerOptions(
  ssl = true,
  keyStoreOptions = keyStoreOptions)

// Use JDK SSL engine explicitly
options = NetServerOptions(
  ssl = true,
  keyStoreOptions = keyStoreOptions,
  jdkSslEngineOptions = JdkSSLEngineOptions())

// Use OpenSSL engine
options = NetServerOptions(
  ssl = true,
  keyStoreOptions = keyStoreOptions,
  openSslEngineOptions = OpenSSLEngineOptions())</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_server_name_indication_sni">Server Name Indication (SNI)</h4>
<div class="paragraph">
<p>Server Name Indication (SNI) is a TLS extension by which a client specifies a hostname attempting to connect: during
the TLS handshake the client gives a server name and the server can use it to respond with a specific certificate
for this server name instead of the default deployed certificate.
If the server requires client authentication the server can use a specific trusted CA certificate depending on the
indicated server name.</p>
</div>
<div class="paragraph">
<p>When SNI is active the server uses</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the certificate CN or SAN DNS (Subject Alternative Name with DNS) to do an exact match, e.g <code>www.example.com</code></p>
</li>
<li>
<p>the certificate CN or SAN DNS certificate to match a wildcard name, e.g <code>*.example.com</code></p>
</li>
<li>
<p>otherwise the first certificate when the client does not present a server name or the presented server name cannot be matched</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the server additionally requires client authentication:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if <code><a href="../../apidocs/io/vertx/core/net/JksOptions.html">JksOptions</a></code> were used to set the trust options
( <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html#setTrustOptions-io.vertx.core.net.TrustOptions-">options</a></code> ) then an exact match with the trust store
alias is done</p>
</li>
<li>
<p>otherwise the available CA certificates are used in the same way as if no SNI is in place</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can enable SNI on the server by setting <code><a href="../../apidocs/io/vertx/core/net/NetServerOptions.html#setSni-boolean-">setSni</a></code> to <code>true</code> and
configured the server with multiple key/certificate pairs.</p>
</div>
<div class="paragraph">
<p>Java KeyStore files or PKCS12 files can store multiple key/cert pairs out of the box.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var keyCertOptions = JksOptions(
  path = "keystore.jks",
  password = "wibble")

var netServer = vertx.createNetServer(NetServerOptions(
  keyStoreOptions = keyCertOptions,
  ssl = true,
  sni = true))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/net/PemKeyCertOptions.html">PemKeyCertOptions</a></code> can be configured to hold multiple entries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var keyCertOptions = PemKeyCertOptions(
  keyPaths = listOf("default-key.pem", "host1-key.pem", "etc..."),
  certPaths = listOf("default-cert.pem", "host2-key.pem", "etc..."))

var netServer = vertx.createNetServer(NetServerOptions(
  pemKeyCertOptions = keyCertOptions,
  ssl = true,
  sni = true))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client implicitly sends the connecting host as an SNI server name for Fully Qualified Domain Name (FQDN).</p>
</div>
<div class="paragraph">
<p>You can provide an explicit server name when connecting a socket</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createNetClient(NetClientOptions(
  trustStoreOptions = trustOptions,
  ssl = true))

// Connect to 'localhost' and present 'server.name' server name
client.connect(1234, "localhost", "server.name", { res -&gt;
  if (res.succeeded()) {
    println("Connected!")
    var socket = res.result()
  } else {
    println("Failed to connect: ${res.cause().getMessage()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can be used for different purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>present a server name different than the server host</p>
</li>
<li>
<p>present a server name while connecting to an IP</p>
</li>
<li>
<p>force to present a server name when using shortname</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_应用层协议协商_alpn">应用层协议协商 (ALPN)</h4>
<div class="paragraph">
<p>ALPN(Application-Layer Protocol Negotiation)是应用层协议协商的TLS扩展，它被HTTP/2使用：在TLS握手期时，客户端给出其接受的应用协议列表，之后服务器使用它所支持的协议响应。</p>
</div>
<div class="paragraph">
<p>If you are using Java 9, you are fine and you can use HTTP/2 out of the box without extra steps.</p>
</div>
<div class="paragraph">
<p>标准的Java 8不支持ALPN，所以ALPN应该通过其他方式启用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OpenSSL支持</p>
</li>
<li>
<p>Jetty-ALPN支持</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>引擎选项可使用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当 <code><a href="../../apidocs/io/vertx/core/net/TCPSSLOptions.html#getSslEngineOptions--">getSslEngineOptions</a></code> 被设置时，使用该选项</p>
</li>
<li>
<p>JDK中ALPN可用时使用 <code><a href="../../apidocs/io/vertx/core/net/JdkSSLEngineOptions.html">JdkSSLEngineOptions</a></code></p>
</li>
<li>
<p>OpenSSL中ALPN可用时使用 <code><a href="../../apidocs/io/vertx/core/net/OpenSSLEngineOptions.html">OpenSSLEngineOptions</a></code></p>
</li>
<li>
<p>否则失败</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_openssl_alpn支持">OpenSSL ALPN支持</h5>
<div class="paragraph">
<p>OpenSSL提供了原生的ALPN支持。</p>
</div>
<div class="paragraph">
<p>OpenSSL需要配置 <code><a href="../../apidocs/io/vertx/core/net/TCPSSLOptions.html#setOpenSslEngineOptions-io.vertx.core.net.OpenSSLEngineOptions-">setOpenSslEngineOptions</a></code>
并在类路径上使用 <a href="http://netty.io/wiki/forked-tomcat-native.html">netty-tcnative</a> 的jar库。依赖于tcnative的实现它需要OpenSSL安装在您的操作系统中。</p>
</div>
</div>
<div class="sect4">
<h5 id="_jetty_alpn支持">Jetty-ALPN支持</h5>
<div class="paragraph">
<p>Jetty-ALPN是一个小型的jar，它覆盖了几种Java 8发行版用以支持ALPN。</p>
</div>
<div class="paragraph">
<p>JVM必须将 <code>alpn-boot-${version}.jar</code> 放在它的 <code>boot classpath</code> 中启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-Xbootclasspath/p:/path/to/alpn-boot${version}.jar</pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>${version}</code> 取决于JVM的版本，如 <strong>OpenJDK 1.8.0u74</strong> 中的 <strong>8.1.7.v20160121</strong>。这个完整列表可以在 <a href="http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html">Jetty-ALPN page</a>
页面上找到。</p>
</div>
<div class="paragraph">
<p>这种方法主要缺点是ALPN的实现版本依赖于JVM的版本。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，可以使用 <em><a href="https://github.com/jetty-project/jetty-alpn-agent">Jetty ALPN agent</a></em> 。agent是一个JVM代理，它会为运行它的JVM选择正确的ALPN版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-javaagent:/path/to/alpn/agent</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_客户端连接使用代理">客户端连接使用代理</h3>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/net/NetClient.html">NetClient</a></code> 支持HTTP/1.x <strong>CONNECT</strong>、<strong>SOCKS4a</strong> 或 <strong>SOCKS5</strong> 代理。</p>
</div>
<div class="paragraph">
<p>代理可以在 <code><a href="../../apidocs/io/vertx/core/net/NetClientOptions.html">NetClientOptions</a></code> 内设置
<code><a href="../../apidocs/io/vertx/core/net/ProxyOptions.html">ProxyOptions</a></code> 来配置代理类型、主机名、端口、可选的用户名和密码。</p>
</div>
<div class="paragraph">
<p>以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = NetClientOptions(
  proxyOptions = ProxyOptions(
    type = ProxyType.SOCKS5,
    host = "localhost",
    port = 1080,
    username = "username",
    password = "secret"))
var client = vertx.createNetClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>DNS 解析总是在代理服务器上完成解析，为了实现 SOCKS4 客户端的功能，需要先在本地解析 DNS 地址。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_编写_http_服务端和客户端">编写 HTTP 服务端和客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 允许您轻松编写非阻塞的 HTTP 客户端和服务端。</p>
</div>
<div class="paragraph">
<p>Vert.x 支持 HTTP/1.0、HTTP/1.1 和 HTTP/2 协议。</p>
</div>
<div class="paragraph">
<p>用于 HTTP 的基本 API 对 HTTP/1.x 和 HTTP/2 是相同的，特定的API功能也可用于处理 HTTP/2 协议。</p>
</div>
<div class="sect2">
<h3 id="_创建_http_服务端">创建 HTTP 服务端</h3>
<div class="paragraph">
<p>使用所有默认选项创建 HTTP 服务端的最简单方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createHttpServer()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_http_服务端">配置 HTTP 服务端</h3>
<div class="paragraph">
<p>若您不想用默认值，可以在创建服务器时传递一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html">HttpServerOptions</a></code>
实例给它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpServerOptions(
  maxWebsocketFrameSize = 1000000)

var server = vertx.createHttpServer(options)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_http_2_服务端">配置 HTTP/2 服务端</h3>
<div class="paragraph">
<p>Vert.x支持 TLS <code>h2</code> 和TCP <code>h2c</code> 之上的 HTTP/2 协议。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>h2</code> 表示使用了TLS的应用层协议协商(ALPN)协议来协商的 HTTP/2 协议</p>
</li>
<li>
<p><code>h2c</code> 表示在TCP层上使用明文形式的 HTTP/2 协议，这样的连接是使用 HTTP/1.1升级 请求或者直接建立</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要处理 h2 请求，你必须调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setUseAlpn-boolean-">setUseAlpn</a></code> 方法来启用TLS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpServerOptions(
  useAlpn = true,
  ssl = true,
  keyStoreOptions = JksOptions(
    path = "/path/to/my/keystore"))

var server = vertx.createHttpServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>ALPN是一个TLS的扩展，它在客户端和服务器开始交换数据之前协商协议。</p>
</div>
<div class="paragraph">
<p>不支持ALPN的客户端仍然可以执行经典的SSL握手。</p>
</div>
<div class="paragraph">
<p>通常情况，ALPN会对 <code>h2</code> 协议达成一致，尽管服务器或客户端决定了仍然使用 HTTP/1.1 协议。</p>
</div>
<div class="paragraph">
<p>要处理 <code>h2c</code> 请求，TLS必须被禁用，服务器将升级到 HTTP/2 以满足任何希望升级到 HTTP/2 的 HTTP/1.1 请求。它还将接受以 <code>PRI*HTTP/2.0\r\nSM\r\n</code> 开始的 <code>h2c</code> 直接连接。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
大多数浏览器不支持 <code>h2c</code> ，所以在建站时，您应该使用 <code>h2</code> 而不是 <code>h2c</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当服务器接受 HTTP/2 连接时， 它会向客户端发送其 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#getInitialSettings--">初始设置</a></code> 。定义客户端如何使用连接，服务器的默认初始设置为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/core/http/Http2Settings.html#getMaxConcurrentStreams--">getMaxConcurrentStreams</a></code> ：按照 HTTP/2 RFC建议推荐值为 <code>100</code></p>
</li>
<li>
<p>其他默认的 HTTP/2 的设置</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>Worker Verticle 和 HTTP/2 不兼容。</strong>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_记录服务端网络活动">记录服务端网络活动</h3>
<div class="paragraph">
<p>为了进行调试，可记录网络活动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpServerOptions(
  logActivity = true)

var server = vertx.createHttpServer(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>详细说明请参阅 <a href="#logging_network_activity">记录网络活动</a> 章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_开启服务端监听">开启服务端监听</h3>
<div class="paragraph">
<p>要告诉服务器监听传入的请求，您可以使用其中一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServer.html#listen--">listen</a></code>
方法。</p>
</div>
<div class="paragraph">
<p>在配置项中告诉服务器监听指定的主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createHttpServer()
server.listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在调用 <code>listen</code> 方法时指定主机和端口号，这样就忽略了配置项（中的主机和端口）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createHttpServer()
server.listen(8080, "myhost.com")</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认主机名是 <code>0.0.0.0</code> ，它表示：监听所有可用地址；默认端口号是 <code>80</code> 。</p>
</div>
<div class="paragraph">
<p>实际的绑定也是异步的，因此服务器也许并没有在调用 <code>listen</code> 方法返回时监听，而是在一段时间过后才监听。</p>
</div>
<div class="paragraph">
<p>若您希望在服务器实际监听时收到通知，您可以向 <code>listen</code> 提供一个处理器。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createHttpServer()
server.listen(8080, "myhost.com", { res -&gt;
  if (res.succeeded()) {
    println("Server is now listening!")
  } else {
    println("Failed to bind!")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_收到传入请求的通知">收到传入请求的通知</h3>
<div class="paragraph">
<p>若您需要在收到请求时收到通知，则需要设置一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServer.html#requestHandler-io.vertx.core.Handler-">requestHandler</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createHttpServer()
server.requestHandler({ request -&gt;
  // Handle the request in here
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理请求">处理请求</h3>
<div class="paragraph">
<p>当请求到达时，Vert.x 会像对应的处理函数传入一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html">HttpServerRequest</a></code> 实例并调用请求处理函数，此对象表示服务端 HTTP 请求。</p>
</div>
<div class="paragraph">
<p>当请求的头信息被完全读取时会调用该请求处理器。</p>
</div>
<div class="paragraph">
<p>如果请求包含请求体，那么该请求体将在请求处理器被调用后的某个时间到达服务器。</p>
</div>
<div class="paragraph">
<p>服务请求对象允许您检索 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#uri--">uri</a></code> ,
<code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#path--">path</a></code> , <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#params--">params</a></code> 和
<code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#headers--">headers</a></code> 等其他信息。</p>
</div>
<div class="paragraph">
<p>每一个服务请求对象和一个服务响应对象绑定，您可以用
<code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#response--">response</a></code> 方法获取一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html">HttpServerResponse</a></code>
对象的引用。</p>
</div>
<div class="paragraph">
<p>这是服务器处理请求并回复 “hello world” 的简单示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.createHttpServer().requestHandler({ request -&gt;
  request.response().end("Hello world")
}).listen(8080)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_请求版本">请求版本</h4>
<div class="paragraph">
<p>在请求中指定的 HTTP 版本可通过 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#version--">version</a></code> 方法获取。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求方法">请求方法</h4>
<div class="paragraph">
<p>使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#method--">method</a></code> 方法读取请求中的 HTTP Method（即GET、POST、PUT、DELETE、HEAD、OPTIONS等）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求uri">请求URI</h4>
<div class="paragraph">
<p>使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#uri--">uri</a></code> 方法读取请求中的URI路径。</p>
</div>
<div class="paragraph">
<p>请注意，这是在HTTP 请求中传递的实际URI，它总是一个相对的URI。</p>
</div>
<div class="paragraph">
<p>这个URI是在 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">Section 5.1.2 of the HTTP specification - Request-URI</a> 中定义的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求路径">请求路径</h4>
<div class="paragraph">
<p>使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#path--">path</a></code> 方法读取URI中的路径部分。</p>
</div>
<div class="paragraph">
<p>例如，请求的URI为：</p>
</div>
<div class="paragraph">
<p>a/b/c/page.html?param1=abc&amp;param2=xyz</p>
</div>
<div class="paragraph">
<p>路径部分应该是：</p>
</div>
<div class="paragraph">
<p>/a/b/c/page.html</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求查询">请求查询</h4>
<div class="paragraph">
<p>使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#query--">query</a></code> 读取URI中的查询部分。</p>
</div>
<div class="paragraph">
<p>例如，请求的URI为：</p>
</div>
<div class="paragraph">
<p>a/b/c/page.html?param1=abc&amp;param2=xyz</p>
</div>
<div class="paragraph">
<p>查询部分应该是：</p>
</div>
<div class="paragraph">
<p>param1=abc&amp;param2=xyz</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求头部">请求头部</h4>
<div class="paragraph">
<p>使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#headers--">headers</a></code> 方法获取HTTP 请求中的请求头部信息。</p>
</div>
<div class="paragraph">
<p>这个方法返回一个 <code><a href="../../apidocs/io/vertx/core/MultiMap.html">MultiMap</a></code>  实例。它像一个普通的Map或Hash，并且它还允许同一个键支持多个值 —— 因为HTTP允许同一个键支持多个请求头的值。</p>
</div>
<div class="paragraph">
<p>它的键值不区分大小写，这意味着您可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var headers = request.headers()

// Get the User-Agent:
println("User agent is ${headers.get("user-agent")}")

// You can also do this and get the same result:
println("User agent is ${headers.get("User-Agent")}")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_请求主机">请求主机</h4>
<div class="paragraph">
<p>使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#host--">host</a></code> 方法返回 HTTP 请求中的主机名。</p>
</div>
<div class="paragraph">
<p>对于 HTTP/1.x 请求返回请求头中的 <code>host</code> 值，对于 HTTP/1 请求则返回伪头中的 <code>:authority</code> 的值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求参数">请求参数</h4>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#params--">params</a></code> 方法返回HTTP请求中的参数信息。</p>
</div>
<div class="paragraph">
<p>像 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#headers--">headers</a></code> 方法一样它也会返回一个 <code><a href="../../apidocs/io/vertx/core/MultiMap.html">MultiMap</a></code> 实例，因为可以有多个具有相同名称的参数。</p>
</div>
<div class="paragraph">
<p>请求参数在请求URI的 path 部分之后，例如URI是：</p>
</div>
<div class="paragraph">
<p>/page.html?param1=abc&amp;param2=xyz</p>
</div>
<div class="paragraph">
<p>那么参数将包含以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>param1: 'abc'
param2: 'xyz</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这些请求参数是从请求的 URI 中解析读取的，若您已经将表单属性存放在请求体中发送出去，并且该请求为 <code>multi-part/form-data</code> 类型请求，那么它们将不会显示在此处的参数中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_远程地址">远程地址</h4>
<div class="paragraph">
<p>可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#remoteAddress--">remoteAddress</a></code> 方法读取请求发送者的地址。</p>
</div>
</div>
<div class="sect3">
<h4 id="_绝对uri">绝对URI</h4>
<div class="paragraph">
<p>HTTP 请求中传递的URI通常是相对的，若您想要读取请求中和相对URI对应的绝对URI，可调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#absoluteURI--">absoluteURI</a></code> 方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_结束处理器">结束处理器</h4>
<div class="paragraph">
<p>当整个请求（包括任何正文）已经被完全读取时，请求中的 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#endHandler-io.vertx.core.Handler-">endHandler</a></code> 方法会被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_请求体中读取数据">请求体中读取数据</h4>
<div class="paragraph">
<p>HTTP请求通常包含我们需要读取的主体。如前所述，当请求头部达到时，请求处理器会被调用，因此请求对象在此时没有请求体。</p>
</div>
<div class="paragraph">
<p>这是因为请求体可能非常大（如文件上传），并且我们不会在内容发送给您之前将其全部缓冲存储在内存中，这可能会导致服务器耗尽可用内存。</p>
</div>
<div class="paragraph">
<p>要接收请求体，您可在请求中调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#handler-io.vertx.core.Handler-">handler</a></code> 方法设置一个处理器，每次请求体的一小块数据收到时，该处理器都会被调用。以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.handler({ buffer -&gt;
  println("I have received a chunk of the body of length ${buffer.length()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递给处理器的对象是一个 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code> ，当数据从网络到达时，处理器可以多次被调用，这取决于请求体的大小。</p>
</div>
<div class="paragraph">
<p>在某些情况下（例：若请求体很小），您将需要将这个请求体聚合到内存中，以便您可以按照下边的方式进行聚合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create an empty buffer
var totalBuffer = Buffer.buffer()

request.handler({ buffer -&gt;
  println("I have received a chunk of the body of length ${buffer.length()}")
  totalBuffer.appendBuffer(buffer)
})

request.endHandler({ v -&gt;
  println("Full body received, length = ${totalBuffer.length()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个常见的情况，Vert.x为您提供了一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#bodyHandler-io.vertx.core.Handler-">bodyHandler</a></code> 方法来执行此操作。当所有请求体被收到时， <code>bodyHandler</code> 绑定的处理器会被调用一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.bodyHandler({ totalBuffer -&gt;
  println("Full body received, length = ${totalBuffer.length()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pumping_请求">Pumping 请求</h4>
<div class="paragraph">
<p>请求对象实现了 <code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 接口，因此您可以将请求体读取到任何
<code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code>  实例中。</p>
</div>
<div class="paragraph">
<p>详细请参阅 <a href="#streams">流和管道</a> 章节。</p>
</div>
</div>
<div class="sect3">
<h4 id="_处理_html_表单">处理 HTML 表单</h4>
<div class="paragraph">
<p>您可使用 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 这两种 <strong>content-type</strong> 来提交 HTML 表单。</p>
</div>
<div class="paragraph">
<p>对于使用 URL 编码过的表单，表单属性会被编码在URL中，如同普通查询参数一样。</p>
</div>
<div class="paragraph">
<p>对于 multipart 类型的表单，它会被编码在请求体中，而且在整个请求体被完全读取之前它是不可用的。Multipart 表单还可以包含文件上传。</p>
</div>
<div class="paragraph">
<p>Multipart 表单还可以包含文件上传。</p>
</div>
<div class="paragraph">
<p>若您想要读取 multipart 表单的属性，您应该告诉 Vert.x 您会在读取任何正文 <strong>之前</strong> 调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#setExpectMultipart-boolean-">setExpectMultipart</a></code>
方法，然后在整个请求体都被读取后，您可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#formAttributes--">formAttributes</a></code>
方法来读取实际的表单属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">server.requestHandler({ request -&gt;
  request.setExpectMultipart(true)
  request.endHandler({ v -&gt;
    // The body has now been fully read, so retrieve the form attributes
    var formAttributes = request.formAttributes()
  })
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_处理文件上传">处理文件上传</h4>
<div class="paragraph">
<p>Vert.x 可以处理以 multipart 编码形式上传的的文件。</p>
</div>
<div class="paragraph">
<p>要接收文件，您可以告诉 Vert.x 使用 multipart 表单，并对请求设置
<code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#uploadHandler-io.vertx.core.Handler-">uploadHandler</a></code> 。</p>
</div>
<div class="paragraph">
<p>当服务器每次接收到上传请求时，该处理器将被调用一次。</p>
</div>
<div class="paragraph">
<p>传递给处理器的对象是一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerFileUpload.html">HttpServerFileUpload</a></code> 实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">server.requestHandler({ request -&gt;
  request.setExpectMultipart(true)
  request.uploadHandler({ upload -&gt;
    println("Got a file upload ${upload.name()}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>上传的文件可能很大，我们不会在单个缓冲区中包含整个上传的数据，因为这样会导致内存耗尽。相反，上传数据是以块的形式被接收的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.uploadHandler({ upload -&gt;
  upload.handler({ chunk -&gt;
    println("Received a chunk of the upload of length ${chunk.length()}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>上传对象实现了 <code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 接口，因此您可以将请求体读取到任何
<code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 实例中。详细说明请参阅 <a href="#streams">流和管道（泵）</a> 章节。</p>
</div>
<div class="paragraph">
<p>若您只是想将文件上传到服务器的某个磁盘，可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerFileUpload.html#streamToFileSystem-java.lang.String-">streamToFileSystem</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.uploadHandler({ upload -&gt;
  upload.streamToFileSystem("myuploads_directory/${upload.filename()}")
})</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
确保您检查了生产系统的文件名，以避免恶意客户将文件上传到文件系统中的任意位置。有关详细信息，参阅 <a href="#Security notes">安全说明</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_处理压缩体">处理压缩体</h4>
<div class="paragraph">
<p>Vert.x 可以处理在客户端通过 <strong>deflate</strong> 或 <strong>gzip</strong> 算法压缩过的请求体信息。</p>
</div>
<div class="paragraph">
<p>若要启用解压缩功能则您要在创建服务器时调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setDecompressionSupported-boolean-">setDecompressionSupported</a></code> 方法设置配置项。</p>
</div>
<div class="paragraph">
<p>默认情况下解压缩是被禁用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接收自定义_http_2_帧">接收自定义 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的包含各种帧的一种帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>若要接收自定义帧(frame)，您可以在请求中使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#customFrameHandler-io.vertx.core.Handler-">customFrameHandler</a></code> ，每次当自定义的帧数据到达时，这个处理器会被调用。这而是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.customFrameHandler({ frame -&gt;

  println("Received a frame type=${frame.type()} payload${frame.payload().toString()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2 帧不受流量控制限制 —— 当接收到自定义帧时，不论请求是否暂停，自定义帧处理器都将立即被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_非标准的_http_方法">非标准的 HTTP 方法</h4>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpMethod.html#OTHER">OTHER</a></code> HTTP 方法可用于非标准方法，在这种情况下，
<code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#rawMethod--">rawMethod</a></code> 方法返回客户端发送的实际 HTTP 方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_发回响应">发回响应</h3>
<div class="paragraph">
<p>服务器响应对象是一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html">HttpServerResponse</a></code> 实例，它可以从 <code>request</code> 对应的
<code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#response--">response</a></code> 方法中读取。</p>
</div>
<div class="paragraph">
<p>您可以使用响应对象回写一个响应到 HTTP客户端。</p>
</div>
<div class="sect3">
<h4 id="_设置状态码和消息">设置状态码和消息</h4>
<div class="paragraph">
<p>默认的 HTTP 状态响应码为 <code>200</code> ，表示 <code>OK</code> 。</p>
</div>
<div class="paragraph">
<p>可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#setStatusCode-int-">setStatusCode</a></code> 方法设置不同状态代码。</p>
</div>
<div class="paragraph">
<p>您还可用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#setStatusMessage-java.lang.String-">setStatusMessage</a></code> 方法指定自定义状态消息。</p>
</div>
<div class="paragraph">
<p>若您不指定状态信息，将会使用默认的状态码响应。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
对于 HTTP/2 中的状态不会在响应中描述 —— 因为协议不会将消息发送回客户端。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_向_http_响应写入数据">向 HTTP 响应写入数据</h4>
<div class="paragraph">
<p>想要将数据写入 HTTP Response，您可使用任意一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#write-io.vertx.core.buffer.Buffer-">write</a></code> 方法。</p>
</div>
<div class="paragraph">
<p>它们可以在响应结束之前被多次调用，它们可以通过以下几种方式调用：</p>
</div>
<div class="paragraph">
<p>对用单个缓冲区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.write(buffer)</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入字符串，这种请求字符串将使用 UTF-8 进行编码，并将结果写入到报文中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.write("hello world!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入带编码方式的字符串，这种情况字符串将使用指定的编码方式编码，并将结果写入到报文中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.write("hello world!", "UTF-16")</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应写入是异步的，并且在写操作进入队列之后会立即返回。</p>
</div>
<div class="paragraph">
<p>若您只需要将单个字符串或 <code>Buffer</code> 写入到HTTP 响应，则可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#end-java.lang.String-">end</a></code> 方法将其直接写入响应中并发回到客户端。</p>
</div>
<div class="paragraph">
<p>第一次写入操作会触发响应头的写入，因此，若您不使用HTTP 分块，那么必须在写入响应之前设置 <code>Content-Length</code> 头，否则会太迟。若您使用 HTTP 分块则不需要担心这点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_完成_http_响应">完成 HTTP 响应</h4>
<div class="paragraph">
<p>一旦您完成了 HTTP 响应，可调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#end-java.lang.String-">end</a></code> 将其发回客户端。</p>
</div>
<div class="paragraph">
<p>这可以通过几种方式完成：</p>
</div>
<div class="paragraph">
<p>没有参数，直接结束响应，发回客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.write("hello world!")
response.end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以和调用 <code>write</code> 方法一样传 <code>String</code> 或 <code>Buffer</code> 给 <code>end</code> 方法。这种情况，它和先调用带 <code>String</code> 或 <code>Buffer</code> 参数的 <code>write</code> 方法，之后调用无参 <code>end</code> 方法一样。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.end("hello world!")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_关闭底层连接">关闭底层连接</h4>
<div class="paragraph">
<p>您可以调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#close--">close</a></code> 方法关闭底层的TCP 连接。</p>
</div>
<div class="paragraph">
<p>当响应结束时，Vert.x 将自动关闭非 keep-alive 的连接。</p>
</div>
<div class="paragraph">
<p>默认情况下，Vert.x 不会自动关闭 keep-alive 的连接，若您想要在一段空闲时间之后让 Vert.x 自动关闭 keep-alive 的连接，则使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setIdleTimeout-int-">setIdleTimeout</a></code> 方法进行配置。</p>
</div>
<div class="paragraph">
<p>HTTP/2 连接在关闭响应之前会发送 <code>GOAWAY</code> 帧。</p>
</div>
</div>
<div class="sect3">
<h4 id="_设置响应头">设置响应头</h4>
<div class="paragraph">
<p>HTTP 响应头可直接添加到 HTTP 响应中，通常直接操作
<code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#headers--">headers</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
var headers = response.headers()
headers.set("content-type", "text/html")
headers.set("other-header", "wibble")</code></pre>
</div>
</div>
<div class="paragraph">
<p>或您可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#putHeader-java.lang.String-java.lang.String-">putHeader</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.putHeader("content-type", "text/html").putHeader("other-header", "wibble")</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应头必须在写入响应正文消息之前进行设置。</p>
</div>
</div>
<div class="sect3">
<h4 id="_分块_http_响应和附加尾部">分块 HTTP 响应和附加尾部</h4>
<div class="paragraph">
<p>Vert.x 支持 <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">分块传输编码(HTTP Chunked Transfer Encoding)</a>.</p>
</div>
<div class="paragraph">
<p>这允许HTTP 响应体以块的形式写入，通常在响应体预先不知道尺寸、需要将很大响应正文以流式传输到客户端时使用。</p>
</div>
<div class="paragraph">
<p>您可以通过如下方式开启分块模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.setChunked(true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认是不分块的，当处于分块模式，每次调用任意一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#write-io.vertx.core.buffer.Buffer-">write</a></code>
方法将导致新的 HTTP 块被写出。</p>
</div>
<div class="paragraph">
<p>在分块模式下，您还可以将响应的HTTP 响应附加尾部(trailers)写入响应，这种方式实际上是在写入响应的最后一块。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
分块响应在 HTTP/2 流中无效。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>若要向响应添加尾部，则直接添加到 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#trailers--">trailers</a></code> 里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.setChunked(true)
var trailers = response.trailers()
trailers.set("X-wibble", "woobble").set("X-quux", "flooble")</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#putTrailer-java.lang.String-java.lang.String-">putTrailer</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()
response.setChunked(true)
response.putTrailer("X-wibble", "woobble").putTrailer("X-quux", "flooble")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_直接从磁盘或_classpath_读文件">直接从磁盘或 Classpath 读文件</h4>
<div class="paragraph">
<p>若您正在编写一个Web 服务端，一种从磁盘中读取并提供文件的方法是将文件作为 <code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html">AsyncFile</a></code>
对象打开并其传送到HTTP 响应中。</p>
</div>
<div class="paragraph">
<p>或您可以使用 <code><a href="../../apidocs/io/vertx/core/file/FileSystem.html#readFile-java.lang.String-io.vertx.core.Handler-">readFile</a></code> 方法一次性加载它，并直接将其写入响应。</p>
</div>
<div class="paragraph">
<p>或者，Vert.x 提供了一种方法，允许您在一个操作中将文件从磁盘或文件系统中读取并提供给HTTP 响应。若底层操作系统支持，这会导致操作系统不通过用户空间复制而直接将文件内容中字节数据从文件传输到Socket。</p>
</div>
<div class="paragraph">
<p>这是使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#sendFile-java.lang.String-">sendFile</a></code> 方法完成的，对于大文件处理通常更有效，而这个方法对于小文件可能很慢。</p>
</div>
<div class="paragraph">
<p>这儿是一个非常简单的 Web 服务器，它使用 <code>sendFile</code> 方法从文件系统中读取并提供文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.createHttpServer().requestHandler({ request -&gt;
  var file = ""
  if (request.path() == "/") {
    file = "index.html"
  } else if (!request.path().contains("..")) {
    file = request.path()
  }
  request.response().sendFile("web/${file}")
}).listen(8080)</code></pre>
</div>
</div>
<div class="paragraph">
<p>发送文件是异步的，可能在调用返回一段时间后才能完成。如果要在文件写入时收到通知，可以在 <code>sendFile</code> 方法中设置一个处理器。 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#sendFile-java.lang.String-io.vertx.core.Handler-">sendFile</a></code></p>
</div>
<div class="paragraph">
<p>请阅读 <a href="#classpath">从 Classpath 访问文件</a> 章节了解类路径的限制或禁用它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
若在 HTTPS 协议中使用 <code>sendFile</code> 方法，它将会通过用户空间进行复制，因为若内核将数据直接从磁盘复制到 Socket，则不会给我们任何加密的机会。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
若您要直接使用 Vert.x 编写 Web 服务器，请注意，您想提供文件和类路径之外访问的位置 —— 用户是无法直接利用路径访问的。更安全的做法是使用Vert.x Web替代。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当需要提供文件的一部分，从给定的字节开始，您可以像下边这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.createHttpServer().requestHandler({ request -&gt;
  var offset = 0
  try {
    offset = Long.parseLong(request.getParam("start"))
  } catch(e: Exception) {
    // error handling...
  }


  var end = Long.MAX_VALUE
  try {
    end = Long.parseLong(request.getParam("end"))
  } catch(e: Exception) {
    // error handling...
  }


  request.response().sendFile("web/mybigfile.txt", offset, end)
}).listen(8080)</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您想要从偏移量开始发送文件直到尾部，则不需要提供长度信息，这种情况下，您可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.createHttpServer().requestHandler({ request -&gt;
  var offset = 0
  try {
    offset = Long.parseLong(request.getParam("start"))
  } catch(e: Exception) {
    // error handling...
  }


  request.response().sendFile("web/mybigfile.txt", offset)
}).listen(8080)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pumping_响应">Pumping 响应</h4>
<div class="paragraph">
<p>服务端响应 <code>HttpServerResponse</code> 也是一个 <code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 实例，因此您可以从任何
<code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 向其泵送数据，如 <code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html">AsyncFile</a></code> , <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> ,
<code><a href="../../apidocs/io/vertx/core/http/WebSocket.html">WebSocket</a></code> 或 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html">HttpServerRequest</a></code> 。</p>
</div>
<div class="paragraph">
<p>这儿有一个例子，它回应了任何 PUT 方法的响应中的请求体，它为请求体使用了 Pump，所以即使 HTTP 请求体很大并填满了内存，任何时候它依旧会工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.createHttpServer().requestHandler({ request -&gt;
  var response = request.response()
  if (request.method() == HttpMethod.PUT) {
    response.setChunked(true)
    Pump.pump(request, response).start()
    request.endHandler({ v -&gt;
      response.end()
    })
  } else {
    response.setStatusCode(400).end()
  }
}).listen(8080)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_写入_http_2_帧">写入 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的包含各种帧的一种帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>要发送这样的帧，您可以在响应中使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#writeCustomFrame-int-int-io.vertx.core.buffer.Buffer-">writeCustomFrame</a></code> 方法，以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var frameType = 40
var frameStatus = 10
var payload = Buffer.buffer("some data")

// Sending a frame to the client
response.writeCustomFrame(frameType, frameStatus, payload)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些帧被立即发送，并且不受流程控制的影响——当这样的帧被发送到那里时，可以在其他的 {@literal DATA} 帧之前完成。</p>
</div>
</div>
<div class="sect3">
<h4 id="_流重置">流重置</h4>
<div class="paragraph">
<p>HTTP/1.x 不允许请求或响应流执行清除重置，如当客户端上传的资源已经存在于服务器上，服务器就需要接受整个响应。</p>
</div>
<div class="paragraph">
<p>HTTP/2 在请求/响应期间随时支持流重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Reset the stream
request.response().reset()</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认的 <code>NO_ERROR(0)</code> 错误代码会发送，您也可以发送另外一个错误代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Cancel the stream
request.response().reset(8)</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2 规范中定义了可用的 <a href="http://httpwg.org/specs/rfc7540.html#ErrorCodes">错误码</a> 列表：</p>
</div>
<div class="paragraph">
<p>若使用了 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#exceptionHandler-io.vertx.core.Handler-">request handler</a></code> 和
<code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#exceptionHandler-io.vertx.core.Handler-">response handler</a></code> 两个处理器过后，在流重置完成时您将会收到通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.response().exceptionHandler({ err -&gt;
  if (err is io.vertx.core.http.StreamResetException) {
    var reset = err
    println("Stream reset ${reset.getCode()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_服务器推送">服务器推送</h4>
<div class="paragraph">
<p>服务器推送(Server Push)是 HTTP/2 支持的一个新功能，可以为单个客户端请求并行发送多个响应。</p>
</div>
<div class="paragraph">
<p>当服务器处理请求时，它可以向客户端推送请求/响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var response = request.response()

// Push main.js to the client
response.push(HttpMethod.GET, "/main.js", { ar -&gt;

  if (ar.succeeded()) {

    // The server is ready to push the response
    var pushedResponse = ar.result()

    // Send main.js response
    pushedResponse.putHeader("content-type", "application/json").end("alert(\"Push response hello\")")
  } else {
    println("Could not push client resource ${ar.cause()}")
  }
})

// Send the requested resource
response.sendFile("&lt;html&gt;&lt;head&gt;&lt;script src=\"/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;")</code></pre>
</div>
</div>
<div class="paragraph">
<p>当服务器准备推送响应时，推送响应处理器会被调用，并会发送响应。</p>
</div>
<div class="paragraph">
<p>推送响应处理器客户能会接收到失败，如：客户端可能取消推送，因为它已经在缓存中包含了 <code>main.js</code> ，并不在需要它。</p>
</div>
<div class="paragraph">
<p>您必须在响应结束之前调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#push-io.vertx.core.http.HttpMethod-java.lang.String-java.lang.String-io.vertx.core.Handler-">push</a></code> 方法，但是在推送响应过后依然可以写响应。</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions">Handling exceptions</h4>
<div class="paragraph">
<p>You can set an <code><a href="../../apidocs/io/vertx/core/http/HttpServer.html#exceptionHandler-io.vertx.core.Handler-">exceptionHandler</a></code> to receive any
exceptions that happens before the connection is passed to the <code><a href="../../apidocs/io/vertx/core/http/HttpServer.html#requestHandler-io.vertx.core.Handler-">requestHandler</a></code>
or to the <code><a href="../../apidocs/io/vertx/core/http/HttpServer.html#websocketHandler-io.vertx.core.Handler-">websocketHandler</a></code> , e.g during the TLS handshake.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http_压缩">HTTP 压缩</h3>
<div class="paragraph">
<p>Vert.x 支持 HTTP 压缩。</p>
</div>
<div class="paragraph">
<p>这意味着在响应发送回客户端之前，您可以将响应体自动压缩。</p>
</div>
<div class="paragraph">
<p>若客户端不支持HTTP 压缩，则它可以发回没有压缩过的请求。</p>
</div>
<div class="paragraph">
<p>这允许它同时处理支持HTTP 压缩的客户端和不支持的客户端。</p>
</div>
<div class="paragraph">
<p>要启用压缩，可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setCompressionSupported-boolean-">setCompressionSupported</a></code> 方法进行配置。默认情况下，未启用压缩。</p>
</div>
<div class="paragraph">
<p>默认情况下，未启用压缩。</p>
</div>
<div class="paragraph">
<p>当启用HTTP 压缩时，服务器将检查客户端请求头中是否包含了 <code>Accept-Encoding</code> 并支持常用的 deflate 和 gzip 压缩算法。Vert.x 两者都支持。</p>
</div>
<div class="paragraph">
<p>若找到这样的请求头，服务器将使用所支持的压缩算法之一自动压缩响应正文并发送回客户端。</p>
</div>
<div class="paragraph">
<p>Whenever the response needs to be sent without compression you can set the header <code>content-encoding</code> to <code>identity</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Disable compression and send an image
request.response().putHeader(io.vertx.core.http.HttpHeaders.CONTENT_ENCODING, io.vertx.core.http.HttpHeaders.IDENTITY).sendFile("/path/to/image.jpg")</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：压缩可以减少网络流量，但是CPU密集度会更高。</p>
</div>
<div class="paragraph">
<p>为了解决后边一个问题，Vert.x也允许您调整原始的 gzip/deflate 压缩算法的 “压缩级别” 参数</p>
</div>
<div class="paragraph">
<p>压缩级别允许根据所得数据的压缩比和压缩/解压的计算成本来配置 gzip/deflate 算法。</p>
</div>
<div class="paragraph">
<p>压缩级别是从 1 到 9 的整数值，其中 1 表示更低的压缩比但是最快的算法，9 表示可用的最大压缩比但比较慢的算法。</p>
</div>
<div class="paragraph">
<p>使用高于 1-2 的压缩级别通常允许仅仅保存一些字节大小 —— 它的增益不是线性的，并取决于要压缩的特定数据 —— 但它可以满足服务器所要求的CPU周期的不可控的成本（注意现在Vert.x不支持任何缓存形式的响应数据，如静态文件，因此压缩是在每个请求体生成时进行的）,它可生成压缩过的响应数据、并对接收的响应解码（膨胀）—— 和客户端使用的方式一致，这种操作随着压缩级别的增长会变得更加倾向于CPU密集型。</p>
</div>
<div class="paragraph">
<p>默认情况下 —— 如果通过 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setCompressionSupported-boolean-">setCompressionSupported</a></code> 方法启用压缩，Vert.x 将使用 <strong>6</strong> 作为压缩级别，但是该参数可通过 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setCompressionLevel-int-">setCompressionLevel</a></code> 方法来更改。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建_http_客户端">创建 HTTP 客户端</h3>
<div class="paragraph">
<p>您可通过以下方式创建一个具有默认配置的 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a></code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createHttpClient()</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您想要配置客户端选项，可按以下方式创建：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpClientOptions(
  keepAlive = false)
var client = vertx.createHttpClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x 支持基于 TLS <code>h2</code> 和 TCP <code>h2c</code> 的 HTTP/2 协议。</p>
</div>
<div class="paragraph">
<p>默认情况下，HTTP 客户端会发送 HTTP/1.1 请求。若要执行 HTTP/2 请求，则必须调用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setProtocolVersion-io.vertx.core.http.HttpVersion-">setProtocolVersion</a></code>
方法将版本设置成 <code><a href="../../apidocs/io/vertx/core/http/HttpVersion.html#HTTP_2">HTTP_2</a></code> 。</p>
</div>
<div class="paragraph">
<p>对于 <code>h2</code> 请求，必须使用应用层协议协商(ALPN)启用TLS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpClientOptions(
  protocolVersion = HttpVersion.HTTP_2,
  ssl = true,
  useAlpn = true,
  trustAll = true)

var client = vertx.createHttpClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 <code>h2c</code> 请求，TLS必须禁用，客户端将执行 HTTP/1.1 请求并尝试升级到 HTTP/2：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpClientOptions(
  protocolVersion = HttpVersion.HTTP_2)

var client = vertx.createHttpClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>h2c</code> 连接也可以直接建立，如连接可以使用前文提到的方式创建，当
<code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setHttp2ClearTextUpgrade-boolean-">setHttp2ClearTextUpgrade</a></code> 选项设置为 <code>false</code> 时：建立连接后，客户端将发送 HTTP/2 连接前缀，并期望从服务端接收相同的连接偏好。</p>
</div>
<div class="paragraph">
<p>HTTP 服务端可能不支持 HTTP/2，当响应到达时，可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#version--">version</a></code> 方法检查响应实际HTTP版本。</p>
</div>
<div class="paragraph">
<p>当客户端连接到 HTTP/2 服务端时，它将向服务端发送其 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#getInitialSettings--">初始设置</a></code>.
。设置定义服务器如何使用连接、客户端的默认初始设置是由 HTTP/2 RFC定义的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_记录客户端网络活动">记录客户端网络活动</h3>
<div class="paragraph">
<p>为了进行调试，可以记录网络活动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpClientOptions(
  logActivity = true)
var client = vertx.createHttpClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>详情请参阅 <a href="#logging_network_activity">记录网络活动</a> 章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_发出请求">发出请求</h3>
<div class="paragraph">
<p>HTTP 客户端是很灵活的，您可以通过各种方式发出请求。</p>
</div>
<div class="paragraph">
<p>通常您希望使用 HTTP 客户端向同一个主机/端口发送很多请求。为避免每次发送请求时重复设主机/端口，您可以为客户端配置默认主机/端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Set the default host
var options = HttpClientOptions(
  defaultHost = "wibble.com")
// Can also set default port if you want...
var client = vertx.createHttpClient(options)
client.getNow("/some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您发现自己使用相同的客户端向不同主机的主机/端口发送大量请求，则可以在发出请求时简单指定主机/端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createHttpClient()

// Specify both port and host name
client.getNow(8080, "myserver.mycompany.com", "/some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

// This time use the default port 80 but specify the host name
client.getNow("foo.othercompany.com", "/other-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>用客户端发出请求的所有不同方式都支持这两种指定主机/端口的方法。</p>
</div>
<div class="sect3">
<h4 id="_无请求体的简单请求">无请求体的简单请求</h4>
<div class="paragraph">
<p>通常，您想发出没有请求体的HTTP 请求，这种情况通常如HTTP GET、OPTIONS 和 HEAD 请求。</p>
</div>
<div class="paragraph">
<p>使用 Vert.x HTTP Client 执行这种请求最简单的方式是使用加了 <code>Now</code> 后缀的请求方法，如
<code><a href="../../apidocs/io/vertx/core/http/HttpClient.html#getNow-io.vertx.core.http.RequestOptions-io.vertx.core.Handler-">getNow</a></code> 。</p>
</div>
<div class="paragraph">
<p>这些方法会创建HTTP 请求，并在单个方法调用中发送它，而且允许您提供一个处理器，当HTTP 响应发送回来时调用该处理器来处理响应结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createHttpClient()

// Send a GET request
client.getNow("/some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

// Send a GET request
client.headNow("/other-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_发送通用请求">发送通用请求</h4>
<div class="paragraph">
<p>有时您在运行时不知道发送请求的 HTTP 方法，对于这种情况，我们提供通用请求方法 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html#request-io.vertx.core.http.HttpMethod-io.vertx.core.http.RequestOptions-">request</a></code> ，允许您在运行时指定 HTTP 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createHttpClient()

client.request(HttpMethod.GET, "some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).end()

client.request(HttpMethod.POST, "foo-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).end("some-data")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_写请求体">写请求体</h4>
<div class="paragraph">
<p>有时您想要发送一个包含了请求体的请求，或者也许您想要在发送请求之前写入头部到请求中。</p>
</div>
<div class="paragraph">
<p>为此，您可以调用其中一个指定的请求方法，如 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html#post-io.vertx.core.http.RequestOptions-">post</a></code> 或一个其他通用请求方法，如 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html#request-io.vertx.core.http.HttpMethod-io.vertx.core.http.RequestOptions-">request</a></code> 。</p>
</div>
<div class="paragraph">
<p>这些方法都不会立即发送请求，而是返回一个 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html">HttpClientRequest</a></code>
实例，它可以用来写数据到请求体和请求头。</p>
</div>
<div class="paragraph">
<p>这儿有一些写入请求体的 POST 请求例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createHttpClient()

var request = client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

// Now do stuff with the request
request.putHeader("content-length", "1000")
request.putHeader("content-type", "text/plain")
request.write(body)

// Make sure the request is ended when you're done with it
request.end()

// Or fluently:

client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).putHeader("content-length", "1000").putHeader("content-type", "text/plain").write(body).end()

// Or event more simply:

client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).putHeader("content-type", "text/plain").end(body)</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以用UTF-8编码方式编码字符串和以指定方式编码编码字符串、或写 <code>Buffer</code> 的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Write string encoded in UTF-8
request.write("some data")

// Write string encoded in specific encoding
request.write("some other data", "UTF-16")

// Write a buffer
var buffer = Buffer.buffer()
buffer.appendInt(123).appendLong(245L)
request.write(buffer)</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您仅需要写单个字符串或 <code>Buffer</code> 到HTTP请求中，您可以直接调用 <code>end</code> 函数完成写入和请求的发送操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Write string and end the request (send it) in a single call
request.end("some simple data")

// Write buffer and end the request (send it) in a single call
var buffer = Buffer.buffer().appendDouble(12.34).appendLong(432L)
request.end(buffer)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您写入请求时，第一次调用 <code>write</code> 方法将先将请求头写入到请求报文中。</p>
</div>
<div class="paragraph">
<p>实际写入操作是异步的，它可能在调用返回一段时间后才发生。</p>
</div>
<div class="paragraph">
<p>带请求体的非分块 HTTP 请求需要提供 <code>Content-Length</code> 头。</p>
</div>
<div class="paragraph">
<p>因此，若您不使用 HTTP 分块，则必须在写入请求之前设置 <code>Content-Length</code> 头，否则会出错。</p>
</div>
<div class="paragraph">
<p>若您在调用其中一个 <code>end</code> 方法处理 String 或 Buffer，在写入请求体之前，Vert.x 将自动计算并设置 <code>Content-Length</code> 。</p>
</div>
<div class="paragraph">
<p>若您在使用HTTP 分块模式，则不需要 <code>Content-Length</code> 头，因此您不必先计算大小。</p>
</div>
</div>
<div class="sect3">
<h4 id="_写请求头">写请求头</h4>
<div class="paragraph">
<p>您可以直接使用 MultiMap 结构的 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#headers--">headers</a></code> 来设置请求头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Write some headers using the headers() multimap

var headers = request.headers()
headers.set("content-type", "application/json").set("other-header", "foo")</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个headers是一个 <code><a href="../../apidocs/io/vertx/core/MultiMap.html">MultiMap</a></code> 的实例，它提供了添加、设置、删除条目的操作。HTTP Header允许一个特定的键包含多个值。</p>
</div>
<div class="paragraph">
<p>您也可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#putHeader-java.lang.String-java.lang.String-">putHeader</a></code> 方法编写头文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Write some headers using the putHeader method

request.putHeader("content-type", "application/json").putHeader("other-header", "foo")</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您想写入请求头，则您必须在写入任何请求体之前这样做来设置请求头。</p>
</div>
</div>
<div class="sect3">
<h4 id="_非标准的http_方法">非标准的HTTP 方法</h4>
<div class="paragraph">
<p>The <code><a href="../../apidocs/io/vertx/core/http/HttpMethod.html#OTHER">OTHER</a></code> HTTP method is used for non standard methods, when this method
is used, <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#setRawMethod-java.lang.String-">setRawMethod</a></code> must be used to
set the raw method to send to the server.</p>
</div>
</div>
<div class="sect3">
<h4 id="_发送_http_请求">发送 HTTP 请求</h4>
<div class="paragraph">
<p>一旦完成了 HTTP 请求的准备工作，您必须调用其中一个 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#end-java.lang.String-">end</a></code> 方法来发送该请求（结束请求）。</p>
</div>
<div class="paragraph">
<p>结束一个请求时，若请求头尚未被写入，会导致它们被写入，并且请求被标记成完成的。</p>
</div>
<div class="paragraph">
<p>请求可以通过多种方式结束。无参简单结束请求的方式如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>或可以在调用 <code>end</code> 方法时提供 String 或 Buffer，这个和先调用带 String/Buffer 参数的 <code>write</code> 方法之后再调用无参 <code>end</code> 方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// End the request with a string
request.end("some-data")

// End it with a buffer
var buffer = Buffer.buffer().appendFloat(12.3f).appendInt(321)
request.end(buffer)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_分块_http_请求">分块 HTTP 请求</h4>
<div class="paragraph">
<p>Vert.x 支持 <a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">HTTP Chunked Transfer Encoding</a> 请求。</p>
</div>
<div class="paragraph">
<p>这允许使用块方式写入HTTP 请求体，这个在请求体比较大需要流式发送到服务器，或预先不知道大小时很常用。</p>
</div>
<div class="paragraph">
<p>您可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#setChunked-boolean-">setChunked</a></code> 将HTTP 请求设置成分块模式。</p>
</div>
<div class="paragraph">
<p>在分块模式下，每次调用 <code>write</code> 方法将导致新的块被写入到报文，这种模式中，无需先设置请求头中的 <code>Content-Length</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.setChunked(true)

// Write some chunks
for (i in 0 until 10) {
  request.write("this-is-chunk-${i}")

}


request.end()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_请求超时">请求超时</h4>
<div class="paragraph">
<p>您可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#setTimeout-long-">setTimeout</a></code> 设置一个特定 HTTP 请求的超时时间。</p>
</div>
<div class="paragraph">
<p>若请求在超时期限内未返回任何数据，则异常将会被传给异常处理器（若提供），并且请求将会被关闭。</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions_2">Handling exceptions</h4>
<div class="paragraph">
<p>您可以通过在 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html">HttpClientRequest</a></code> 实例中设置异常处理器来处理请求时发生的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var request = client.post("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})
request.exceptionHandler({ e -&gt;
  println("Received exception: ${e.getMessage()}")
  e.printStackTrace()
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种处理器不处理需要在 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html">HttpClientResponse</a></code> 中处理的非 2xx 响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var request = client.post("some-uri", { response -&gt;
  if (response.statusCode() == 200) {
    println("Everything fine")
    return
  }
  if (response.statusCode() == 500) {
    println("Unexpected behavior on the server side")
    return
  }
})
request.end()</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
一系列的 <code>XXXNow</code> 方法均不接收异常处理器做为参数。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_客户端请求中指定处理器">客户端请求中指定处理器</h4>
<div class="paragraph">
<p>不像在调用中提供响应处理器来创建客户端请求对象，相反您可以当请求创建时不提供处理器、稍后在请求对象中调用
<code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#handler-io.vertx.core.Handler-">handler</a></code> 来设置。如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var request = client.post("some-uri")
request.handler({ response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用流式请求">使用流式请求</h4>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html">HttpClientRequest</a></code> 实例实现了 <code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 接口，这意味着您可以从任何 <code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 实例将数据泵入请求中。</p>
</div>
<div class="paragraph">
<p>例如，您可以将磁盘上的文件直接泵送到HTTP 请求体中，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.setChunked(true)
var pump = Pump.pump(file, request)
file.endHandler({ v -&gt;
  request.end()
})
pump.start()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_写_http_2_帧">写 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的具有各种帧的一个帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>要发送这样的帧，您可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#write-io.vertx.core.buffer.Buffer-">write</a></code> 方法写入请求，以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var frameType = 40
var frameStatus = 10
var payload = Buffer.buffer("some data")

// Sending a frame to the server
request.writeCustomFrame(frameType, frameStatus, payload)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_流重置_2">流重置</h4>
<div class="paragraph">
<p>HTTP/1.x 不允许请求或响应流进行重置，如当客户端上传了服务器上存在的资源时，服务器依然要接收整个响应。</p>
</div>
<div class="paragraph">
<p>HTTP/2 在请求/响应期间随时支持流重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.reset()</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况，发送 <code>NO_ERROR(0)</code> 错误代码，可发送另一个代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.reset(8)</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2规范定义了可使用的 <a href="http://httpwg.org/specs/rfc7540.html#ErrorCodes">错误码</a> 列表。</p>
</div>
<div class="paragraph">
<p>若使用了 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#exceptionHandler-io.vertx.core.Handler-">request handler</a></code> 和
<code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#exceptionHandler-io.vertx.core.Handler-">response handler</a></code> 两个处理器过后，在流重置完成时您将会收到通知。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.exceptionHandler({ err -&gt;
  if (err is io.vertx.core.http.StreamResetException) {
    var reset = err
    println("Stream reset ${reset.getCode()}")
  }
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理_http_响应">处理 HTTP 响应</h3>
<div class="paragraph">
<p>您可以在请求方法中指定处理器或通过 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html">HttpClientResponse</a></code> 对象直接设置处理器来接收到 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html">HttpClientRequest</a></code> 的实例。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#statusCode--">statusCode</a></code>
和 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#statusMessage--">statusMessage</a></code> 方法从响应中查询响应的状态码和状态消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.getNow("some-uri", { response -&gt;
  // the status code - e.g. 200 or 404
  println("Status code is ${response.statusCode()}")

  // the status message e.g. "OK" or "Not Found".
  println("Status message is ${response.statusMessage()}")
})</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_使用流式响应">使用流式响应</h4>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html">HttpClientResponse</a></code> 实例也是一个 <code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 实例，这意味着您可以泵送数据到任何 <code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 实例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_响应头和尾">响应头和尾</h4>
<div class="paragraph">
<p>HTTP 响应可包含头信息。您可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#headers--">headers</a></code> 方法来读取响应头。</p>
</div>
<div class="paragraph">
<p>该方法返回的对象是 一个 <code><a href="../../apidocs/io/vertx/core/MultiMap.html">MultiMap</a></code> 实例，因为 HTTP 响应头中单个键可以关联多个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var contentType = response.headers().get("content-type")
var contentLength = response.headers().get("content-lengh")</code></pre>
</div>
</div>
<div class="paragraph">
<p>分块 HTTP 响应还可以包含响应尾(trailer) —— 这实际上是在发送响应体的最后一个（数据）块。</p>
</div>
<div class="paragraph">
<p>您可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#trailers--">trailers</a></code> 方法读取响应尾，尾数据也是一个 <code><a href="../../apidocs/io/vertx/core/MultiMap.html">MultiMap</a></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_读取请求体">读取请求体</h4>
<div class="paragraph">
<p>当从报文中读取到响应头时，响应处理器就会被调用。</p>
</div>
<div class="paragraph">
<p>如果收到的HTTP 响应包含响应体（正文），它可能会在响应头被读取后的某个时间以分片的方式到达。在调用响应处理器之前，我们不要等待所有的响应体到达，因为它可能非常大而要等待很长时间、又或者会花费大量内存。</p>
</div>
<div class="paragraph">
<p>当响应体的某部分（数据）到达时，<code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#handler-io.vertx.core.Handler-">handler</a></code>
方法绑定的回调函数将会被调用，其中传入的 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code> 中包含了响应体的这一分片（部分）内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.getNow("some-uri", { response -&gt;

  response.handler({ buffer -&gt;
    println("Received a part of the response body: ${buffer}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>若您知道响应体不是很大，并想在处理之前在内存中聚合所有响应体数据，那么您可以自己聚合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.getNow("some-uri", { response -&gt;

  // Create an empty buffer
  var totalBuffer = Buffer.buffer()

  response.handler({ buffer -&gt;
    println("Received a part of the response body: ${buffer.length()}")

    totalBuffer.appendBuffer(buffer)
  })

  response.endHandler({ v -&gt;
    // Now all the body has been read
    println("Total response body length is ${totalBuffer.length()}")
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者当响应已被完全读取时，您可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#bodyHandler-io.vertx.core.Handler-">bodyHandler</a></code> 方法以便读取整个响应体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.getNow("some-uri", { response -&gt;

  response.bodyHandler({ totalBuffer -&gt;
    // Now all the body has been read
    println("Total response body length is ${totalBuffer.length()}")
  })
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_响应完成处理器">响应完成处理器</h4>
<div class="paragraph">
<p>当整个响应体被完全读取或者无响应体的响应头被完全读取时，响应的 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#endHandler-io.vertx.core.Handler-">endHandler</a></code> 就会被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_从响应中读取cookie">从响应中读取Cookie</h4>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html#cookies--">cookies</a></code> 方法从响应中获取 Cookie 列表。</p>
</div>
<div class="paragraph">
<p>或者您可以在响应中自己解析 <code>Set-Cookie</code> 头。</p>
</div>
</div>
<div class="sect3">
<h4 id="_30x_重定向处理器">30x 重定向处理器</h4>
<div class="paragraph">
<p>客户端可配置成遵循HTTP 重定向：当客户端接收到 <code>301</code> 、 <code>302</code> 、 <code>303</code> 或 <code>307</code> 状态代码时，它遵循由 <code>Location</code> 响应头提供的重定向，并且响应处理器将传递重定向响应以替代原始响应。</p>
</div>
<div class="paragraph">
<p>这有个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.get("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).setFollowRedirects(true).end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>重定向策略如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当接收到 <code>301</code> 、 <code>302</code> 或 <code>303</code> 状态代码时，使用 GET 方法执行重定向</p>
</li>
<li>
<p>当接收到 <code>307</code> 状态代码时，使用相同的 HTTP 方法和缓存的请求体执行重定向</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
随后的重定向会缓存请求体。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况最大的重定向数为 <code>16</code> ，您可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setMaxRedirects-int-">setMaxRedirects</a></code> 方法设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createHttpClient(HttpClientOptions(
  maxRedirects = 32))

client.get("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
}).setFollowRedirects(true).end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有放之四海而皆准的策略，缺省的重定向策略可能不能满足您的需要。</p>
</div>
<div class="paragraph">
<p>默认重定向策略可使用自定义实现更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.redirectHandler({ response -&gt;

  // Only follow 301 code
  if (response.statusCode() == 301 &amp;&amp; response.getHeader("Location") != null) {

    // Compute the redirect URI
    var absoluteURI = resolveURI(response.request().absoluteURI(), response.getHeader("Location"))

    // Create a new ready to use request that the client will use
    return Future.succeededFuture(client.getAbs(absoluteURI))
  }

  // We don't redirect
  return null
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个策略将会处理接收到的原始 <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html">HttpClientResponse</a></code> ，并返回 <code>null</code> 或 <code>Future&lt;HttpClientRequest&gt;</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当返回的是 <code>null</code> 时，处理原始响应</p>
</li>
<li>
<p>当返回的是 <code>Future</code> 时，请求将在它成功完成后发送</p>
</li>
<li>
<p>当返回的是 <code>Future</code> 时，请求失败时调用设置的异常处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>返回的请求必须是未发送的，这样原始请求处理器才会被发送而且客户端之后才能发送请求。</p>
</div>
<div class="paragraph">
<p>大多数原始请求设置将会传播（拷贝）到新请求中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求头，除非您已经设置了一些头（包括 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#setHost-java.lang.String-">setHost</a></code> ）</p>
</li>
<li>
<p>请求体，除非返回的请求使用了 <code>GET</code> 方法</p>
</li>
<li>
<p>响应处理器</p>
</li>
<li>
<p>请求异常处理器</p>
</li>
<li>
<p>请求超时</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_100_continue_处理">100-Continue 处理</h4>
<div class="paragraph">
<p>根据 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html">HTTP/1.1 规范</a> ，一个客户端可以设置请求头 <code>Expect: 100-Continue</code> ，并且在发送剩余请求体之前先发送请求头。</p>
</div>
<div class="paragraph">
<p>然后服务器可以通过回复临时响应状态 <code>Status: 100 (Continue)</code> 来告诉客户端可以发送请求的剩余部分。</p>
</div>
<div class="paragraph">
<p>这里的想法是允许服务器在发送大量数据之前授权、接收/拒绝请求，若请求不能被接收，则发送大量数据信息会浪费带宽，并将服务器绑定在读取即将丢弃的无用数据中。</p>
</div>
<div class="paragraph">
<p>Vert.x 允许您在客户端请求对象中设置一个 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#continueHandler-io.vertx.core.Handler-">continueHandler</a></code> 。</p>
</div>
<div class="paragraph">
<p>它将在服务器发回一个状态 <code>Status: 100 (Continue)</code> 时被调用, 同时也表示（客户端）可以发送请求的剩余部分。</p>
</div>
<div class="paragraph">
<p>通常将其与 <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#sendHead--">sendHead</a></code> 结合起来发送请求的头信息。</p>
</div>
<div class="paragraph">
<p>以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var request = client.put("some-uri", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})

request.putHeader("Expect", "100-Continue")

request.continueHandler({ v -&gt;
  // OK to send rest of body
  request.write("Some data")
  request.write("Some more data")
  request.end()
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>在服务端，Vert.x HTTP Server可配置成接收到 <code>Expect: 100-Continue</code> 头时自动发回 <code>100 Continue</code> 临时响应信息。</p>
</div>
<div class="paragraph">
<p>这个可通过 <code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setHandle100ContinueAutomatically-boolean-">setHandle100ContinueAutomatically</a></code> 方法来设置。</p>
</div>
<div class="paragraph">
<p>若您想要决定是否手动发送持续响应，那么此属性可设置成 <code>false</code> （默认值），然后您可以通过检查头信息并且调用 <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html#writeContinue--">writeContinue</a></code>
方法让客户端持续发送请求体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">httpServer.requestHandler({ request -&gt;
  if (request.getHeader("Expect").equalsIgnoreCase("100-Continue")) {

    // Send a 100 continue response
    request.response().writeContinue()

    // The client should send the body when it receives the 100 response
    request.bodyHandler({ body -&gt;
      // Do something with body
    })

    request.endHandler({ v -&gt;
      request.response().end()
    })
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以通过直接发送故障状态代码来拒绝该请求：这种情况下，请求体应该被忽略或连接应该被关闭（ <code>100-Continue</code> 是一个性能提示，并不是逻辑协议约束）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">httpServer.requestHandler({ request -&gt;
  if (request.getHeader("Expect").equalsIgnoreCase("100-Continue")) {

    //
    var rejectAndClose = true
    if (rejectAndClose) {

      // Reject with a failure code and close the connection
      // this is probably best with persistent connection
      request.response().setStatusCode(405).putHeader("Connection", "close").end()
    } else {

      // Reject with a failure code and ignore the body
      // this may be appropriate if the body is small
      request.response().setStatusCode(405).end()
    }
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端推送">客户端推送</h4>
<div class="paragraph">
<p>服务器推送(Server Push)是 HTTP/2 的一个新功能，它可以为单个客户端并行发送多个响应。</p>
</div>
<div class="paragraph">
<p>可以在接收服务器推送的请求/响应的请求上设置一个推送处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var request = client.get("/index.html", { response -&gt;
  // Process index.html response
})

// Set a push handler to be aware of any resource pushed by the server
request.pushHandler({ pushedRequest -&gt;

  // A resource is pushed for this request
  println("Server pushed ${pushedRequest.path()}")

  // Set an handler for the response
  pushedRequest.handler({ pushedResponse -&gt;
    println("The response for the pushed request")
  })
})

// End the request
request.end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>若客户端不想收到推送请求，它可重置流：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.pushHandler({ pushedRequest -&gt;
  if (pushedRequest.path() == "/main.js") {
    pushedRequest.reset()
  } else {
    // Handle it
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>若没有设置任何处理器时，任何被推送的流将被客户端自动重置流（错误代码 <code>8</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接收自定义_http_2_帧_2">接收自定义 HTTP/2 帧</h4>
<div class="paragraph">
<p>HTTP/2 是用于 HTTP 请求/响应模型的具有各种帧的一个帧协议，该协议允许发送和接收其他类型的帧。</p>
</div>
<div class="paragraph">
<p>要接收自定义帧，您可以在请求中使用 <code>customFrameHandler</code> ，每次自定义帧到达时就会调用它。以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">response.customFrameHandler({ frame -&gt;

  println("Received a frame type=${frame.type()} payload${frame.payload().toString()}")
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_客户端启用压缩">客户端启用压缩</h3>
<div class="paragraph">
<p>HTTP 客户端支持开箱即用的 HTTP 压缩功能。</p>
</div>
<div class="paragraph">
<p>这意味着客户端可以让远程服务器知道它支持压缩，并且能处理压缩过的响应体（数据）。</p>
</div>
<div class="paragraph">
<p>HTTP 服务端可以自由地使用自己支持的压缩算法之一进行压缩，也可以在不压缩的情况下将响应体发回。所以这仅仅是 HTTP 服务端的一个可能被随意忽略的提示。</p>
</div>
<div class="paragraph">
<p>要告诉服务器当前客户端支持哪种压缩，则它（请求头）将包含一个 <code>Accept-Encoding</code> 头，其值为可支持的压缩算法，（该值可）支持多种压缩算法。这种情况 Vert.x 将添加以下头：</p>
</div>
<div class="paragraph">
<p>Accept-Encoding: gzip, deflate</p>
</div>
<div class="paragraph">
<p>服务器将从其中（算法）选择一个，您可以通过服务器发回的响应中响应头 <code>Content-Encoding</code> 来检测服务器是否适应这个正文。</p>
</div>
<div class="paragraph">
<p>若响应体通过 <code>gzip</code> 压缩，它将包含例如下边的头：</p>
</div>
<div class="paragraph">
<p>Content-Encoding: gzip</p>
</div>
<div class="paragraph">
<p>创建客户端时可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setTryUseCompression-boolean-">setTryUseCompression</a></code> 设置配置项启用压缩。</p>
</div>
<div class="paragraph">
<p>默认情况压缩被禁用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_1_x_pooling_和_keep_alive">HTTP/1.x Pooling 和 Keep alive</h3>
<div class="paragraph">
<p>HTTP 的 Keep Alive 允许单个 HTTP 连接用于多个请求。当您向同一台服务器发送多个请求时，可以更加有效使用连接。</p>
</div>
<div class="paragraph">
<p>对于 HTTP/1.x 版本，HTTP 客户端支持连接池，它允许您重用请求之间的连接。</p>
</div>
<div class="paragraph">
<p>为了连接池（能）工作，配置客户端时，keep alive 必须通过 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setKeepAlive-boolean-">setKeepAlive</a></code>
方法设置成 <code>true</code> 。默认值为 <code>true</code> 。</p>
</div>
<div class="paragraph">
<p>当 keep alive 启用时，Vert.x 将为每一个发送的 HTTP/1.0 请求添加一个 <code>Connection: Keep-Alive</code> 头。
当 keep alive 禁用时，Vert.x 将为每一个 HTTP/1.1 请求添加一个 <code>Connection: Close</code> 头 —— 表示在响应完成后连接将被关闭。</p>
</div>
<div class="paragraph">
<p>可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setMaxPoolSize-int-">setMaxPoolSize</a></code> 方法为每个服务器配置连接池的最大连接数。</p>
</div>
<div class="paragraph">
<p>当启用连接池创建请求时，若存在少于已经为服务器创建的最大连接数，Vert.x 将创建一个新连接，否则直接将请求添加到队列中。</p>
</div>
<div class="paragraph">
<p>Keep Alive的连接将不会被客户端自动关闭，要关闭它们您可以关闭客户端实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>keep-alive: timeout=30</pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setKeepAliveTimeout-int-">setKeepAliveTimeout</a></code> 设置空闲时间——在设置的时间内然后没使用的连接将被关闭。请注意空闲超时值以秒为单位而不是毫秒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_1_1_pipe_lining">HTTP/1.1 pipe-lining</h3>
<div class="paragraph">
<p>客户端还支持连接上的请求管道(pipeline)。</p>
</div>
<div class="paragraph">
<p>管道意味着在返回一个响应之前，在同一个连接上发送另一个请求，管道不适合所有请求。</p>
</div>
<div class="paragraph">
<p>若要启用管道，必须调用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setPipelining-boolean-">setPipelining</a></code> 方法，默认管道是禁止的。</p>
</div>
<div class="paragraph">
<p>当启用管道时，请求可以不等待以前的响应返回而写入到连接。</p>
</div>
<div class="paragraph">
<p>单个连接的管道请求限制数由 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setPipeliningLimit-int-">setPipeliningLimit</a></code>
方法设置，此选项定义了发送到服务器的等待响应的最大请求数。这个限制可以确保和同一个服务器的连接分发到客户端的公平性。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_2_多路复用">HTTP/2 多路复用</h3>
<div class="paragraph">
<p>HTTP/2 提倡使用服务器的单一连接，默认情况下，HTTP 客户端针对每个服务器都使用单一连接，同样服务器上的所有流都会复用到对应连接中。</p>
</div>
<div class="paragraph">
<p>当客户端需要使用连接池并使用超过一个连接时，则可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setHttp2MaxPoolSize-int-">setHttp2MaxPoolSize</a></code>
设置。</p>
</div>
<div class="paragraph">
<p>当您希望限制每个连接的多路复用流数量而使用连接池而不是单个连接时，可使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setHttp2MultiplexingLimit-int-">setHttp2MultiplexingLimit</a></code>
设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var clientOptions = HttpClientOptions(
  http2MultiplexingLimit = 10,
  http2MaxPoolSize = 3)

// Uses up to 3 connections and up to 10 streams per connection
var client = vertx.createHttpClient(clientOptions)</code></pre>
</div>
</div>
<div class="paragraph">
<p>连接的复用限制是在客户端上设置限制单个连接的流数量，如果服务器使用 <code><a href="../../apidocs/io/vertx/core/http/Http2Settings.html#setMaxConcurrentStreams-long-">SETTINGS_MAX_CONCURRENT_STREAMS</a></code> 设置了下限，则有效值可以更低。</p>
</div>
<div class="paragraph">
<p>HTTP/2 连接不会被客户端自动关闭，若要关闭它们，可以调用 <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#close--">close</a></code>
来关闭客户端实例。</p>
</div>
<div class="paragraph">
<p>或者，您可以使用 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setIdleTimeout-int-">setIdleTimeout</a></code> 设置空闲时间——这个时间内没有使用的任何连接将被关闭，注意，空闲时间以秒为单位，不是毫秒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_连接">HTTP 连接</h3>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html">HttpConnection</a></code> 接口提供了处理HTTP 连接事件、生命周期、设置的API。</p>
</div>
<div class="paragraph">
<p>HTTP/2 实现了完整的 <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html">HttpConnection</a></code> API。</p>
</div>
<div class="paragraph">
<p>HTTP/1.x 实现了 <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html">HttpConnection</a></code> 中的部分API：仅关闭操作，实现了关闭处理器和异常处理器。该协议并不提供其他操作的语义。</p>
</div>
<div class="sect3">
<h4 id="_服务端连接">服务端连接</h4>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#connection--">connection</a></code> 方法会返回服务器上的请求连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var connection = request.connection()</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在服务器上设置连接处理器，任意连接传入时可得到通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createHttpServer(http2Options)

server.connectionHandler({ connection -&gt;
  println("A client connected")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端连接">客户端连接</h4>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html#connection--">connection</a></code> 方法会返回客户端上的连接请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var connection = request.connection()</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在请求上设置连接处理器在连接发生时通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">request.connectionHandler({ connection -&gt;
  println("Connected to the server")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_连接配置">连接配置</h4>
<div class="paragraph">
<p>HTTP/2 由 <code><a href="../../apidocs/io/vertx/core/http/Http2Settings.html">Http2Settings</a></code> 数据对象来配置。</p>
</div>
<div class="paragraph">
<p>每个 Endpoint 都必须遵守连接另一端的发送设置。</p>
</div>
<div class="paragraph">
<p>当建立连接时，客户端和服务器交换初始配置，初始设置由客户端上的 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setInitialSettings-io.vertx.core.http.Http2Settings-">setInitialSettings</a></code> 和服务器上的
<code><a href="../../apidocs/io/vertx/core/http/HttpServerOptions.html#setInitialSettings-io.vertx.core.http.Http2Settings-">setInitialSettings</a></code> 方法配置。</p>
</div>
<div class="paragraph">
<p>连接建立后可随时更改设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.updateSettings(Http2Settings(
  maxConcurrentStreams = 100))</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于远程方应该确认接收者的配置更新，也有可能在回调中接收确认通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.updateSettings(Http2Settings(
  maxConcurrentStreams = 100), { ar -&gt;
  if (ar.succeeded()) {
    println("The settings update has been acknowledged ")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，在收到新的远程设置时会通知 <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#remoteSettingsHandler-io.vertx.core.Handler-">remoteSettingsHandler</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.remoteSettingsHandler({ settings -&gt;
  println("Received new settings")
})</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
此功能仅适用于 HTTP/2 协议。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_连接_ping">连接 Ping</h4>
<div class="paragraph">
<p>HTTP/2 连接 ping 对于确定连接往返时间或检查连接有效性很有用： <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#ping-io.vertx.core.buffer.Buffer-io.vertx.core.Handler-">ping</a></code> 发送 {@literal PING} 帧到远端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var data = Buffer.buffer()
for (i in 0 until 8) {
  data.appendByte(i)

}

connection.ping(data, { pong -&gt;
  println("Remote side replied")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>当接收到 {@literal PING} 帧时，Vert.x 将自动发送确认，可设置处理器当收到 ping 帧时发送通知调用处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.pingHandler({ ping -&gt;
  println("Got pinged by remote side")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>处理器只是接到通知，确认被发送，这个功能旨在基于 HTTP/2 协议之上实现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
此功能仅适用于 HTTP/2 协议。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_连接关闭_goaway">连接关闭/GOAWAY</h4>
<div class="paragraph">
<p>调用 <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#shutdown--">shutdown</a></code> 方法将发送 {@literal GOAWAY} 帧到远程的连接，要求其停止创建流：客户端将停止发送新请求，并且服务器将停止推送响应。发送 {@literal GOAWAY} 帧后，连接将等待一段时间（默认为30秒），直到所有当前流关闭和连接关闭。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.shutdown()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#shutdownHandler-io.vertx.core.Handler-">shutdownHandler</a></code> 通知何时关闭所有流，连接尚未关闭。</p>
</div>
<div class="paragraph">
<p>有可能只需发送 {@literal GOAWAY} 帧，和关闭主要的区别在于它将只是告诉远程连接停止创建新流，而没有计划关闭连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.goAway(0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，也可以在收到 {@literal GOAWAY} 时收到通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.goAwayHandler({ goAway -&gt;
  println("Received a go away frame")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>当所有当前流已经关闭并且可关闭连接时， <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#shutdownHandler-io.vertx.core.Handler-">shutdownHandler</a></code> 将被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">connection.goAway(0)
connection.shutdownHandler({ v -&gt;

  // All streams are closed, close the connection
  connection.close()
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>当接收到 {@literal GOAWAY} 时也适用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
此功能仅适用于HTTP/2协议。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_连接关闭">连接关闭</h4>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#close--">close</a></code> 方法关闭连接：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于 HTTP/1.x 来说，它会关闭底层的 Socket</p>
</li>
<li>
<p>对于 HTTP/2 来说，它将执行无延迟关闭， {@literal GOAWAY} 帧将会在连接关闭之前被发送 *</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>连接关闭时 <code><a href="../../apidocs/io/vertx/core/http/HttpConnection.html#closeHandler-io.vertx.core.Handler-">closeHandler</a></code> 将发出通知。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_httpclient_使用说明">HttpClient 使用说明</h3>
<div class="paragraph">
<p><code>HttpClient</code> 可以在一个 Verticle 中使用或者嵌入使用。</p>
</div>
<div class="paragraph">
<p>在 Verticle 中使用时，Verticle <strong>应该使用自己的客户端实例</strong>。</p>
</div>
<div class="paragraph">
<p>一般来说，不应该在不同的 Vert.x 上下文环境之间共享客户端，因为它可能导致不可预知的意外。</p>
</div>
<div class="paragraph">
<p>例如：保持活动连接将在打开连接的请求上下文环境调用客户端处理器，后续请求将使用相同上下文环境。</p>
</div>
<div class="paragraph">
<p>当这种情况发生时，Vert.x会检测到并记录下边警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Reusing a connection with a different context: an HttpClient is probably shared between different Verticles</pre>
</div>
</div>
<div class="paragraph">
<p><code>HttpClient</code> 可以嵌套在非 Vert.x 线程中，如单元测试或纯Java的 <code>main</code> 线程中：客户端处理器将被不同的Vert.x 线程和上下文调用，这样的上下文会根据需要创建。对于生产环境，不推荐这样使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务端共享">服务端共享</h3>
<div class="paragraph">
<p>当多个 HTTP 服务端在同一个端口上监听时，Vert.x 会使用轮询策略来管理请求处理。</p>
</div>
<div class="paragraph">
<p>我们用 Verticle 来创建 HTTP 服务端，如：</p>
</div>
<div class="listingblock">
<div class="title">io.vertx.examples.http.sharing.HttpServerVerticle</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.createHttpServer().requestHandler({ request -&gt;
  request.response().end("Hello from server ${this}")
}).listen(8080)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个服务正在监听 <code>8080</code> 端口。所以，当这个 Verticle 被实例化多次，如运行以下命令：
<code>vertx run io.vertx.examples.http.sharing.HttpServerVerticle -instances 2</code> ,
将会发生什么？如果两个 Verticle 都绑定到同一个端口，您将收到一个 Socket 异常。幸运的是，Vert.x 可以为您处理这种情况。在与现有服务端相同的主机和端口上部署另一个服务器时，实际上并不会尝试创建在同一主机/端口上监听的新服务端，它只绑定一次到Socket，当接收到请求时，会按照轮询策略调用服务端的请求处理函数。</p>
</div>
<div class="paragraph">
<p>我们现在想象一个客户端，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.setPeriodic(100, { l -&gt;
  vertx.createHttpClient().getNow(8080, "localhost", "/", { resp -&gt;
    resp.bodyHandler({ body -&gt;
      println(body.toString("ISO-8859-1"))
    })
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x 将请求顺序委托给其中一个服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Hello from i.v.e.h.s.HttpServerVerticle@1
Hello from i.v.e.h.s.HttpServerVerticle@2
Hello from i.v.e.h.s.HttpServerVerticle@1
Hello from i.v.e.h.s.HttpServerVerticle@2
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，服务器可直接扩展可用的核，而每个 Vert.x 中的 Verticle 实例仍然严格使用单线程，您不需要像编写负载均衡器那样使用任何特殊技巧去编写，以便在多核机器上扩展服务器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_https">使用 HTTPS</h3>
<div class="paragraph">
<p>Vert.x 的 HTTP 服务端和客户端可以配置成和网络服务器完全相同的方式使用 HTTPS。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅 <a href="#ssl">配置网络服务器以使用 SSL</a> 章节。</p>
</div>
<div class="paragraph">
<p>SSL可以通过每个请求的 <code><a href="../../apidocs/io/vertx/core/http/RequestOptions.html">RequestOptions</a></code> 来启用/禁用，或在指定模式时调用 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html#requestAbs-io.vertx.core.http.HttpMethod-java.lang.String-">requestAbs</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.getNow(RequestOptions(
  host = "localhost",
  port = 8080,
  uRI = "/",
  ssl = true), { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setSsl-boolean-">setSsl</a></code> 设置将用作客户端默认配置。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/RequestOptions.html#setSsl-boolean-">setSsl</a></code> 将覆盖默认客户端设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>即使客户端配置成使用 SSL/TLS，该值设置成 <code>false</code> 将禁用SSL/TLS。</p>
</li>
<li>
<p>即使客户端配置成不使用 SSL/TLS，该值设置成 <code>true</code> 将启用SSL/TLS，实际的客户端SSL/TLS（如受信、密钥/证书、密码、ALPN 等）将被重用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>同样， <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html#requestAbs-io.vertx.core.http.HttpMethod-java.lang.String-">requestAbs</a></code> 方法也会（在调用时）覆盖默认客户端设置。</p>
</div>
<div class="sect3">
<h4 id="_server_name_indication_sni_2">Server Name Indication (SNI)</h4>
<div class="paragraph">
<p>Vert.x http servers can be configured to use SNI in exactly the same way as {@linkplain io.vertx.core.net net servers} .</p>
</div>
<div class="paragraph">
<p>Vert.x http client will present the actual hostname as <em>server name</em> during the TLS handshake.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_websockets">WebSockets</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a> 是一种Web技术，可以在 HTTP 服务端和 HTTP 客户端（通常是浏览器）之间实现全双工 Socket 连接。</p>
</div>
<div class="paragraph">
<p>Vert.x HTTP 客户端和服务端都支持 WebSocket。</p>
</div>
<div class="sect3">
<h4 id="_服务端_websocket">服务端 WebSocket</h4>
<div class="paragraph">
<p>在服务端处理 WebSocket 有两种方法。</p>
</div>
<div class="sect4">
<h5 id="_websocket_handler">WebSocket handler</h5>
<div class="paragraph">
<p>第一种方法需要在服务端实例上提供一个 <code><a href="../../apidocs/io/vertx/core/http/HttpServer.html#websocketHandler-io.vertx.core.Handler-">websocketHandler</a></code> 。</p>
</div>
<div class="paragraph">
<p>当对服务端创建 WebSocket 连接时，Vert.x 将向 <code>Handler</code> 传入一个
<code><a href="../../apidocs/io/vertx/core/http/ServerWebSocket.html">ServerWebSocket</a></code> 实例，在其中去处理它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">server.websocketHandler({ websocket -&gt;
  println("Connected!")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以调用 <code><a href="../../apidocs/io/vertx/core/http/ServerWebSocket.html#reject--">reject</a></code> 方法来拒绝一个 WebSocket。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">server.websocketHandler({ websocket -&gt;
  if (websocket.path() == "/myapi") {
    websocket.reject()
  } else {
    // Do something
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_转换到_websocket">转换到 WebSocket</h5>
<div class="paragraph">
<p>处理 WebSocket 的第二种方法是处理从客户端发送的HTTP升级请求，调用服务器请求对象的 <code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html#upgrade--">upgrade</a></code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">server.requestHandler({ request -&gt;
  if (request.path() == "/myapi") {

    var websocket = request.upgrade()
    // Do something

  } else {
    // Reject
    request.response().setStatusCode(400).end()
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_服务端_websocket_2">服务端 WebSocket</h5>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/ServerWebSocket.html">ServerWebSocket</a></code> 实例能够让您读取在WebSocket 握手中的HTTP 请求的 <code><a href="../../apidocs/io/vertx/core/http/ServerWebSocket.html#headers--">headers</a></code> ,
<code><a href="../../apidocs/io/vertx/core/http/ServerWebSocket.html#path--">path</a></code> , <code><a href="../../apidocs/io/vertx/core/http/ServerWebSocket.html#query--">query</a></code> 和
<code><a href="../../apidocs/io/vertx/core/http/ServerWebSocket.html#uri--">URI</a></code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端_websocket">客户端 WebSocket</h4>
<div class="paragraph">
<p>Vert.x 的 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a></code> 支持 WebSocket。</p>
</div>
<div class="paragraph">
<p>您可以调用其中任意一个 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html#websocket-io.vertx.core.http.RequestOptions-io.vertx.core.Handler-">websocket</a></code> 方法创建 WebSocket 连接到服务端，并提供回调函数。</p>
</div>
<div class="paragraph">
<p>当连接建立时，处理器将被调用并且传入 <code><a href="../../apidocs/io/vertx/core/http/WebSocket.html">WebSocket</a></code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">client.websocket("/some-uri", { websocket -&gt;
  println("Connected!")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_向_websocket_写入消息">向 WebSocket 写入消息</h4>
<div class="paragraph">
<p>若您想将一个 WebSocket 消息写入 WebSocket，可使用
<code><a href="../../apidocs/io/vertx/core/http/WebSocket.html#writeBinaryMessage-io.vertx.core.buffer.Buffer-">writeBinaryMessage</a></code> 方法或
<code><a href="../../apidocs/io/vertx/core/http/WebSocket.html#writeTextMessage-java.lang.String-">writeTextMessage</a></code> 方法来执行该操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Write a simple binary message
var buffer = Buffer.buffer().appendInt(123).appendFloat(1.23f)
websocket.writeBinaryMessage(buffer)

// Write a simple text message
var message = "hello"
websocket.writeTextMessage(message)</code></pre>
</div>
</div>
<div class="paragraph">
<p>若WebSocket 消息大于使用
<code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html#setMaxWebsocketFrameSize-int-">setMaxWebsocketFrameSize</a></code>
设置的WebSocket 的帧的最大值，则Vert.x在将其发送到报文之前将其拆分为多个WebSocket 帧。</p>
</div>
</div>
<div class="sect3">
<h4 id="_向_websocket_写入帧">向 WebSocket 写入帧</h4>
<div class="paragraph">
<p>WebSocket 消息可以由多个帧组成，在这种情况下，第一帧是二进制或文本帧（text | binary），后边跟着零个或多个 <strong>连续</strong> 帧。</p>
</div>
<div class="paragraph">
<p>消息中的最后一帧标记成 <strong>final</strong>。</p>
</div>
<div class="paragraph">
<p>要发送多个帧组成的消息，请使用
<code><a href="../../apidocs/io/vertx/core/http/WebSocketFrame.html#binaryFrame-io.vertx.core.buffer.Buffer-boolean-">WebSocketFrame.binaryFrame</a></code>
, <code><a href="../../apidocs/io/vertx/core/http/WebSocketFrame.html#textFrame-java.lang.String-boolean-">WebSocketFrame.textFrame</a></code> 或
<code><a href="../../apidocs/io/vertx/core/http/WebSocketFrame.html#continuationFrame-io.vertx.core.buffer.Buffer-boolean-">WebSocketFrame.continuationFrame</a></code> 方法创建帧，并使用 <code><a href="../../apidocs/io/vertx/core/http/WebSocket.html#writeFrame-io.vertx.core.http.WebSocketFrame-">writeFrame</a></code> 方法将其写入WebSocket。</p>
</div>
<div class="paragraph">
<p>以下是二进制帧的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var frame1 = WebSocketFrame.binaryFrame(buffer1, false)
websocket.writeFrame(frame1)

var frame2 = WebSocketFrame.continuationFrame(buffer2, false)
websocket.writeFrame(frame2)

// Write the final frame
var frame3 = WebSocketFrame.continuationFrame(buffer2, true)
websocket.writeFrame(frame3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>许多情况下，您只需要发送一个包含了单个最终帧的 WebSocket 消息，因此我们提供了 <code><a href="../../apidocs/io/vertx/core/http/WebSocket.html#writeFinalBinaryFrame-io.vertx.core.buffer.Buffer-">writeFinalBinaryFrame</a></code>
和 <code><a href="../../apidocs/io/vertx/core/http/WebSocket.html#writeFinalTextFrame-java.lang.String-">writeFinalTextFrame</a></code> 这两个快捷方法。</p>
</div>
<div class="paragraph">
<p>下边是示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Send a websocket messages consisting of a single final text frame:

websocket.writeFinalTextFrame("Geronimo!")

// Send a websocket messages consisting of a single final binary frame:

var buff = Buffer.buffer().appendInt(12).appendString("foo")

websocket.writeFinalBinaryFrame(buff)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_从_websocket_读取帧">从 WebSocket 读取帧</h4>
<div class="paragraph">
<p>要 从WebSocket 读取帧，您可以使用 <code><a href="../../apidocs/io/vertx/core/http/WebSocket.html#frameHandler-io.vertx.core.Handler-">frameHandler</a></code> 方法。</p>
</div>
<div class="paragraph">
<p>当帧到达时，会传入一个 <code><a href="../../apidocs/io/vertx/core/http/WebSocketFrame.html">WebSocketFrame</a></code> 实例给帧处理器，并调用它，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">websocket.frameHandler({ frame -&gt;
  println("Received a frame of size!")
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_关闭_websocket">关闭 WebSocket</h4>
<div class="paragraph">
<p>处理完成之后，请使用 <code><a href="../../apidocs/io/vertx/core/http/WebSocketBase.html#close--">close</a></code> 方法关闭 WebSocket 连接。</p>
</div>
</div>
<div class="sect3">
<h4 id="_流式_websocket">流式 WebSocket</h4>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/http/WebSocket.html">WebSocket</a></code> 实例也是 <code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 和
<code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 的实现类，因此可以和泵(pump)一起使用。</p>
</div>
<div class="paragraph">
<p>当使用 WebSocket 作为可写流或可读流时，它只能用于不分割多个帧的二进制帧一起使用的 WebSocket 连接。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_http_https_连接代理">使用 HTTP/HTTPS 连接代理</h3>
<div class="paragraph">
<p>HTTP 客户端支持通过HTTP 代理（如Squid）或 <strong>SOCKS4a</strong> 或 <strong>SOCKS5</strong> 代理访问 HTTP/HTTPS 的 URL。CONNECT 协议使用 HTTP/1.x，但可以连接到 HTTP/1.x 和 HTTP/2 服务器。</p>
</div>
<div class="paragraph">
<p>到 <code>h2c</code> （未加密HTTP/2服务器）的连接可能不受 HTTP 代理支持，因为代理仅支持 HTTP/1.1。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/http/HttpClientOptions.html">HttpClientOptions</a></code> 中的
<code><a href="../../apidocs/io/vertx/core/net/ProxyOptions.html">ProxyOptions</a></code> 对象配置来配置代理（包括代理类型、主机名、端口和可选用户名和密码）。</p>
</div>
<div class="paragraph">
<p>以下是使用 HTTP 代理的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpClientOptions(
  proxyOptions = ProxyOptions(
    type = ProxyType.HTTP,
    host = "localhost",
    port = 3128,
    username = "username",
    password = "secret"))
var client = vertx.createHttpClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当客户端连接到HTTP URL时，它连接到代理服务器，并在HTTP请求中提供完整URL ("GET <a href="http://www.somehost.com/path/file.html" class="bare">http://www.somehost.com/path/file.html</a> HTTP/1.1").</p>
</div>
<div class="paragraph">
<p>当客户端连接到HTTPS URL时，它要求代理使用 CONNECT 方法创建到远程主机的通道。</p>
</div>
<div class="paragraph">
<p>对于 SOCKS5 代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpClientOptions(
  proxyOptions = ProxyOptions(
    type = ProxyType.SOCKS5,
    host = "localhost",
    port = 1080,
    username = "username",
    password = "secret"))
var client = vertx.createHttpClient(options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>DNS 解析会一直在代理服务器上执行。为了实现 SOCKS4 客户端的功能，需要先在本地解析 DNS 地址。</p>
</div>
<div class="sect3">
<h4 id="_handling_of_other_protocols">Handling of other protocols</h4>
<div class="paragraph">
<p>The HTTP proxy implementation supports getting ftp:// urls if the proxy supports
that, which isn&#8217;t available in non-proxy getAbs requests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = HttpClientOptions(
  proxyOptions = ProxyOptions(
    type = ProxyType.HTTP))
var client = vertx.createHttpClient(options)
client.getAbs("ftp://ftp.gnu.org/gnu/", { response -&gt;
  println("Received response with status code ${response.statusCode()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Support for other protocols is not available since java.net.URL does not
support them (gopher:// for example).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle_中自动清理">Verticle 中自动清理</h3>
<div class="paragraph">
<p>如果您是在 Verticle 内部创建的 HTTP 服务端和客户端，则在撤销该Verticle时，它们将自动关闭。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用_vert_x_共享数据">使用 Vert.x 共享数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>共享数据（Shared Data）包含的功能允许您可以安全地在应用程序的不同部分之间、同一 Vert.x 实例中的不同应用程序之间或集群中的不同 Vert.x 实例之间安全地共享数据。</p>
</div>
<div class="paragraph">
<p>共享数据包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>synchronous shared maps (local)</p>
</li>
<li>
<p>asynchronous maps (local or cluster-wide)</p>
</li>
<li>
<p>asynchronous locks (local or cluster-wide)</p>
</li>
<li>
<p>asynchronous counters (local or cluster-wide)</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
分布式数据结构的行为取决于您使用的集群管理器，网络分区面临的备份（复制）和行为由集群管理器和它的配置来定义。请参阅集群管理器文档以及底层框架手册。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_本地共享map">本地共享Map</h3>
<div class="paragraph">
<p>本地共享Map <code><a href="../../apidocs/io/vertx/core/shareddata/LocalMap.html">Local shared maps</a></code> 允许您在同一个 Vert.x 实例中的不同 Event Loop（如不同的 Verticle 中）之间安全共享数据。</p>
</div>
<div class="paragraph">
<p>本地共享Map仅允许将某些数据类型作为键值和值，这些类型必须是不可变的，或可以像 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code> 那样复制某些其他类型。在后一种情况中，键/值将被复制，然后再放到Map中。</p>
</div>
<div class="paragraph">
<p>这样，我们可以确保在Vert.x应用程序不同线程之间 <strong>没有共享访问可变状态</strong>，因此您不必担心需要通过同步访问来保护该状态。</p>
</div>
<div class="paragraph">
<p>以下是使用 <code>LocalMap</code> 的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var sd = vertx.sharedData()

var map1 = sd.getLocalMap&lt;Any, Any&gt;("mymap1")

map1.put("foo", "bar")

var map2 = sd.getLocalMap&lt;Any, Any&gt;("mymap2")

map2.put("eek", Buffer.buffer().appendInt(123))

// Then... in another part of your application:

map1 = sd.getLocalMap&lt;Any, Any&gt;("mymap1")

var val = map1.get("foo")

map2 = sd.getLocalMap&lt;Any, Any&gt;("mymap2")

var buff = map2.get("eek")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_集群范围异步map">集群范围异步Map</h3>
<div class="paragraph">
<p>集群范围异步Map(Cluster-wide asynchronous maps)允许从集群的任何节点将数据放到 Map 中，并从任何其他节点读取。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
In clustered mode, asynchronous shared maps rely on distributed data structures provided by the cluster manager.
Beware that the latency relative to asynchronous shared map operations can be much higher in clustered than in local mode.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这使得它们对于托管Vert.x Web应用程序的服务器场中的会话状态存储非常有用。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/shareddata/SharedData.html#getAsyncMap-java.lang.String-io.vertx.core.Handler-">getAsyncMap</a></code> 方法获取
<code><a href="../../apidocs/io/vertx/core/shareddata/AsyncMap.html">AsyncMap</a></code> 的实例。</p>
</div>
<div class="paragraph">
<p>获取Map的过程是异步的，返回结果可以传给您指定的处理器中。以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var sd = vertx.sharedData()

sd.getAsyncMap&lt;String, String&gt;("mymap", { res -&gt;
  if (res.succeeded()) {
    var map = res.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_将数据放入map">将数据放入Map</h4>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/shareddata/AsyncMap.html#put-java.lang.Object-java.lang.Object-io.vertx.core.Handler-">put</a></code> 方法将数据放入Map。</p>
</div>
<div class="paragraph">
<p><code>put</code> 方法是异步的，一旦完成它会通知处理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">map.put("foo", "bar", { resPut -&gt;
  if (resPut.succeeded()) {
    // Successfully put the value
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_从map读取数据">从Map读取数据</h4>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/shareddata/AsyncMap.html#get-java.lang.Object-io.vertx.core.Handler-">get</a></code> 方法从Map读取数据。</p>
</div>
<div class="paragraph">
<p><code>get</code> 方法也是异步的，一段时间过后它会通知处理器并传入结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">map.get("foo", { resGet -&gt;
  if (resGet.succeeded()) {
    // Successfully got the value
    var val = resGet.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_其他map操作">其他Map操作</h5>
<div class="paragraph">
<p>您还可以从异步Map中删除条目、清除Map、读取它的大小。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅 <code><a href="../../apidocs/io/vertx/core/shareddata/AsyncMap.html">API 文档</a></code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_集群范围锁">集群范围锁</h3>
<div class="paragraph">
<p>集群范围锁 <code><a href="../../apidocs/io/vertx/core/shareddata/Lock.html">Asynchronous locks</a></code> 允许您在集群中获取独占锁 —— 当您想要在任何时间只在集群一个节点上执行某些操作或访问资源时，这很有用。</p>
</div>
<div class="paragraph">
<p>集群范围锁具有异步API，它和大多数等待锁释放的阻塞调用线程的API锁不相同。</p>
</div>
<div class="paragraph">
<p>可使用 <code><a href="../../apidocs/io/vertx/core/shareddata/SharedData.html#getLock-java.lang.String-io.vertx.core.Handler-">getLock</a></code> 方法获取锁。</p>
</div>
<div class="paragraph">
<p>它不会阻塞，但当锁可用时，将 <code><a href="../../apidocs/io/vertx/core/shareddata/Lock.html">Lock</a></code> 的实例传入处理器并调用它，表示您现在拥有该锁。</p>
</div>
<div class="paragraph">
<p>若您拥有的锁没有其他调用者，集群上的任何地方都可以获得该锁。</p>
</div>
<div class="paragraph">
<p>当您用完锁后，您可以调用  <code><a href="../../apidocs/io/vertx/core/shareddata/Lock.html#release--">release</a></code> 方法来释放它，以便另一个调用者可获得它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">sd.getLock("mylock", { res -&gt;
  if (res.succeeded()) {
    // Got the lock!
    var lock = res.result()

    // 5 seconds later we release the lock so someone else can get it

    vertx.setTimer(5000, { tid -&gt;
      lock.release()
    })

  } else {
    // Something went wrong
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以为锁设置一个超时，若在超时时间期间无法获取锁，将会进入失败状态，处理器会去处理对应的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">sd.getLockWithTimeout("mylock", 10000, { res -&gt;
  if (res.succeeded()) {
    // Got the lock!
    var lock = res.result()

  } else {
    // Failed to get lock
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_集群范围计数器">集群范围计数器</h3>
<div class="paragraph">
<p>很多时候我们需要在集群范围内维护一个原子计数器。</p>
</div>
<div class="paragraph">
<p>您可以用 <code><a href="../../apidocs/io/vertx/core/shareddata/Counter.html">Counter</a></code> 来做到这一点。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../apidocs/io/vertx/core/shareddata/SharedData.html#getCounter-java.lang.String-io.vertx.core.Handler-">getCounter</a></code> 方法获取一个实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">sd.getCounter("mycounter", { res -&gt;
  if (res.succeeded()) {
    var counter = res.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦您有了一个实例，您可以获取当前的计数，以原子方式递增、递减，并使用各种方法添加一个值。</p>
</div>
<div class="paragraph">
<p>有更多信息，请参阅 <code><a href="../../apidocs/io/vertx/core/shareddata/Counter.html">API 文档</a></code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_访问文件系统">访问文件系统</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 中的 <code><a href="../../apidocs/io/vertx/core/file/FileSystem.html">FileSystem</a></code> 对象提供了许多操作文件系统的方法。</p>
</div>
<div class="paragraph">
<p>每个Vert.x 实例有一个文件系统对象，您可以使用  <code><a href="../../apidocs/io/vertx/core/Vertx.html#fileSystem--">fileSystem</a></code> 方法获取它。</p>
</div>
<div class="paragraph">
<p>每个操作都提供了阻塞和非阻塞版本，其中非阻塞版本接受一个处理器 <code>Handler</code> ，当操作完成或发生错误时调用该处理器。</p>
</div>
<div class="paragraph">
<p>以下是文件异步拷贝的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var fs = vertx.fileSystem()

// Copy file from foo.txt to bar.txt
fs.copy("foo.txt", "bar.txt", { res -&gt;
  if (res.succeeded()) {
    // Copied ok!
  } else {
    // Something went wrong
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>阻塞版本的方法名为 <code>xxxBlocking</code> ，它要么返回结果或直接抛出异常。
很多情况下，一些潜在的阻塞操作可以快速返回（这取决于操作系统和文件系统），这就是我们为什么提供它。
但是强烈建议您在 Event Loop 中使用它之前测试使用它们究竟需要耗费多长时间，以避免打破黄金法则。</p>
</div>
<div class="paragraph">
<p>以下是使用阻塞 API的拷贝示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var fs = vertx.fileSystem()

// Copy file from foo.txt to bar.txt synchronously
fs.copyBlocking("foo.txt", "bar.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vert.x 文件系统支持诸如 copy、move、truncate、chmod 和许多其他文件操作。我们不会在这里列出所有内容，请参考 <code><a href="../../apidocs/io/vertx/core/file/FileSystem.html">API 文档</a></code> 获取完整列表。</p>
</div>
<div class="paragraph">
<p>让我们看看使用异步方法的几个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Read a file
vertx.fileSystem().readFile("target/classes/readme.txt", { result -&gt;
  if (result.succeeded()) {
    println(result.result())
  } else {
    System.err.println("Oh oh ...${result.cause()}")
  }
})

// Copy a file
vertx.fileSystem().copy("target/classes/readme.txt", "target/classes/readme2.txt", { result -&gt;
  if (result.succeeded()) {
    println("File copied")
  } else {
    System.err.println("Oh oh ...${result.cause()}")
  }
})

// Write a file
vertx.fileSystem().writeFile("target/classes/hello.txt", Buffer.buffer("Hello"), { result -&gt;
  if (result.succeeded()) {
    println("File written")
  } else {
    System.err.println("Oh oh ...${result.cause()}")
  }
})

// Check existence and delete
vertx.fileSystem().exists("target/classes/junk.txt", { result -&gt;
  if (result.succeeded() &amp;&amp; result.result()) {
    vertx.fileSystem().delete("target/classes/junk.txt", { r -&gt;
      println("File deleted")
    })
  } else {
    System.err.println("Oh oh ... - cannot delete the file: ${result.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_异步文件访问">异步文件访问</h3>
<div class="paragraph">
<p>Vert.x提供了异步文件访问的抽象，允许您操作文件系统上的文件。</p>
</div>
<div class="paragraph">
<p>您可以像下边代码打开一个  <code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html">AsyncFile</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var options = OpenOptions()
fileSystem.open("myfile.txt", options, { res -&gt;
  if (res.succeeded()) {
    var file = res.result()
  } else {
    // Something went wrong!
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AsyncFile</code> 实现了 <code>ReadStream</code> 和 <code>WriteStream</code> 接口，因此您可以将文件和其他流对象配合 <strong>泵</strong> 工作，如 <code>NetSocket</code> 、HTTP 请求和响应和 WebSocket 等。</p>
</div>
<div class="paragraph">
<p>它们还允许您直接读写。</p>
</div>
<div class="sect3">
<h4 id="_随机访问写">随机访问写</h4>
<div class="paragraph">
<p>要使用 <code>AsyncFile</code> 进行随机访问写，请使用
<code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html#write-io.vertx.core.buffer.Buffer-long-io.vertx.core.Handler-">write</a></code> 方法。</p>
</div>
<div class="paragraph">
<p>这个方法的参数有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>buffer</code> : 要写入的缓冲</p>
</li>
<li>
<p><code>position</code> : 一个整数指定在文件中写入缓冲的位置，若位置大于或等于文件大小，文件将被扩展以适应偏移的位置</p>
</li>
<li>
<p><code>handler</code> : 结果处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是随机访问写的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.fileSystem().open("target/classes/hello.txt", OpenOptions(), { result -&gt;
  if (result.succeeded()) {
    var file = result.result()
    var buff = Buffer.buffer("foo")
    for (i in 0 until 5) {
      file.write(buff, buff.length() * i, { ar -&gt;
        if (ar.succeeded()) {
          println("Written ok!")
          // etc
        } else {
          System.err.println("Failed to write: ${ar.cause()}")
        }
      })

    }

  } else {
    System.err.println("Cannot open file ${result.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_随机访问读">随机访问读</h4>
<div class="paragraph">
<p>要使用 <code>AsyncFile</code> 进行随机访问读，请使用
<code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html#read-io.vertx.core.buffer.Buffer-int-long-int-io.vertx.core.Handler-">read</a></code>
方法。</p>
</div>
<div class="paragraph">
<p>该方法的参数有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>buffer</code> : 读取数据的 Buffer</p>
</li>
<li>
<p><code>offset</code> : 读取数据将被放到 Buffer 中的偏移量</p>
</li>
<li>
<p><code>position</code> : 从文件中读取数据的位置</p>
</li>
<li>
<p><code>length</code> : 要读取的数据的字节数</p>
</li>
<li>
<p><code>handler</code> : 结果处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下是随机访问读的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.fileSystem().open("target/classes/les_miserables.txt", OpenOptions(), { result -&gt;
  if (result.succeeded()) {
    var file = result.result()
    var buff = Buffer.buffer(1000)
    for (i in 0 until 10) {
      file.read(buff, i * 100, i * 100, 100, { ar -&gt;
        if (ar.succeeded()) {
          println("Read ok!")
        } else {
          System.err.println("Failed to write: ${ar.cause()}")
        }
      })

    }

  } else {
    System.err.println("Cannot open file ${result.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_打开选项">打开选项</h4>
<div class="paragraph">
<p>打开 <code>AsyncFile</code> 时，您可以传递一个 <code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html">OpenOptions</a></code> 实例，这些选项描述了访问文件的行为。例如：您可使用
<code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html#setRead-boolean-">setRead</a></code> , <code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html#setWrite-boolean-">setWrite</a></code>
和 <code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html#setPerms-java.lang.String-">setPerms</a></code> 方法配置文件访问权限。</p>
</div>
<div class="paragraph">
<p>若打开的文件已经存在，则可以使用
<code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html#setCreateNew-boolean-">setCreateNew</a></code> 和
<code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html#setTruncateExisting-boolean-">setTruncateExisting</a></code> 配置对应行为。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html#setDeleteOnClose-boolean-">setDeleteOnClose</a></code> 标记在关闭时或JVM停止时要删除的文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="_将数据刷新到底层存储">将数据刷新到底层存储</h4>
<div class="paragraph">
<p>在 <code>OpenOptions</code> 中，您可以使用
<code><a href="../../apidocs/io/vertx/core/file/OpenOptions.html#setDsync-boolean-">setDsync</a></code> . 方法在每次写入时启用/禁用内容的自动同步。这种情况下，您可以使用
<code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html#flush--">flush</a></code> 方法手动刷新OS缓存中的数据写入。</p>
</div>
<div class="paragraph">
<p>该方法也可使用一个处理器来调用，这个处理器在 <code>flush</code> 完成时被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_将_asyncfile_作为_readstream_和_writestream">将 AsyncFile 作为 ReadStream 和 WriteStream</h4>
<div class="paragraph">
<p><code>AsyncFile</code> 实现了 <code>ReadStream</code> 和 <code>WriteStream</code> 接口。您可以使用泵将数据与其他读取和写入流进行数据*泵*送。
例如，这会将内容复制到另外一个 <code>AsyncFile</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var output = vertx.fileSystem().openBlocking("target/classes/plagiary.txt", OpenOptions())

vertx.fileSystem().open("target/classes/les_miserables.txt", OpenOptions(), { result -&gt;
  if (result.succeeded()) {
    var file = result.result()
    Pump.pump(file, output).start()
    file.endHandler({ r -&gt;
      println("Copy done")
    })
  } else {
    System.err.println("Cannot open file ${result.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用泵将文件内容写入到HTTP 响应中，或者写入任意 <code>WriteStream</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="classpath">从 Classpath 访问文件</h4>
<div class="paragraph">
<p>当Vert.x找不到文件系统上的文件时，它尝试从类路径中解析该文件。请注意，类路径的资源路径不以 <code>/</code> 开头。</p>
</div>
<div class="paragraph">
<p>由于Java不提供对类路径资源的异步方法，所以当类路径资源第一次被访问时，该文件将复制到工作线程中的文件系统。
当第二次访问相同资源时，访问的文件直接从（工作线程的）文件系统提供。即使类路径资源发生变化（例如开发系统中），也会提供原始内容。</p>
</div>
<div class="paragraph">
<p>您可以将系统属性 <code>vertx.disableFileCaching</code> 设置为 <code>true</code> ，禁用此（文件）缓存行为。</p>
</div>
<div class="paragraph">
<p>文件缓存的路径默认为 <code>.vertx</code> ，它可以通过设置系统属性 <code>vertx.cacheDirBase</code> 进行自定义。</p>
</div>
<div class="paragraph">
<p>您还可以通过系统属性 <code>vertx.disableFileCPResolving</code> 设置为 <code>true</code> 来禁用整个类路径解析功能。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>当加载 <code>io.vertx.core.impl.FileResolver</code> 类时，这些系统属性将被评估一次，因此，在加载此类之前应该设置这些属性，或者在启动它时作为JVM系统属性来设置。</strong>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to disable classpath resolving for a particular application but keep it enabled by default system-wide,
you can do so via the <code><a href="../../apidocs/io/vertx/core/file/FileSystemOptions.html#setClassPathResolvingEnabled-boolean-">setClassPathResolvingEnabled</a></code> option.</p>
</div>
</div>
<div class="sect3">
<h4 id="_关闭_asyncfile">关闭 AsyncFile</h4>
<div class="paragraph">
<p>您可调用 <code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html#close--">close</a></code> 方法来关闭 <code>AsyncFile</code> 。关闭是异步的，如果希望在关闭过后收到通知，您可指定一个处理器作为函数（ <code>close</code> ）参数传入。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数据报套接字_udp">数据报套接字（UDP）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Vert.x中使用用户数据报协议（UDP）就是小菜一碟。</p>
</div>
<div class="paragraph">
<p>UDP是无连接的传输，这意味着您与远程客户端没有建立持续的连接。</p>
</div>
<div class="paragraph">
<p>所以，您发送和接收的数据包都要包含有远程的地址。</p>
</div>
<div class="paragraph">
<p>除此之外，UDP不像TCP的使用那样安全，这也就意味着不能保证发送的数据包一定会被对应的接收端（Endpoint）接收。</p>
</div>
<div class="paragraph">
<p>唯一的保证是，它既不会被完全接收到，也不会完全不被接收到，即只有部分会被接收到。</p>
</div>
<div class="paragraph">
<p>因为每一个数据包将会作为一个包发送，所以在通常情况下您不能发送大于网络接口的最大传输单元（MTU）的数据包。</p>
</div>
<div class="paragraph">
<p>但是要注意，即使数据包尺寸小于MTU，它仍然可能会发送失败。</p>
</div>
<div class="paragraph">
<p>它失败的尺寸取决于操作系统等（其他原因），所以按照经验法则就是尝试发送小数据包。</p>
</div>
<div class="paragraph">
<p>依照UDP的本质，它最适合一些允许丢弃数据包的应用（如监视应用程序）。</p>
</div>
<div class="paragraph">
<p>其优点是与TCP相比具有更少的开销，而且可以由 <code>NetServer</code> 和 <code>NetClient</code> 处理（参考前文）。</p>
</div>
<div class="sect2">
<h3 id="_创建_datagramsocket">创建 DatagramSocket</h3>
<div class="paragraph">
<p>要使用UDP，您首先要创建一个 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> 实例，无论您是要仅仅发送数据或者收发数据，这都是一样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var socket = vertx.createDatagramSocket(DatagramSocketOptions())</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> 实例不会绑定到特定端口，如果您只想发送数据（如作为客户端）的话，这是没问题的，但更多详细的内容在下一节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_发送数据报包">发送数据报包</h3>
<div class="paragraph">
<p>如上所述，用户数据报协议（UDP）将数据分组发送给远程对等体，但是以不持续的方式来传送到它们。</p>
</div>
<div class="paragraph">
<p>这意味着每个数据包都可以发送到不同的远程对等体。</p>
</div>
<div class="paragraph">
<p>发送数据包很容易，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var socket = vertx.createDatagramSocket(DatagramSocketOptions())
var buffer = Buffer.buffer("content")
// Send a Buffer
socket.send(buffer, 1234, "10.0.0.1", { asyncResult -&gt;
  println("Send succeeded? ${asyncResult.succeeded()}")
})
// Send a String
socket.send("A string used as content", 1234, "10.0.0.1", { asyncResult -&gt;
  println("Send succeeded? ${asyncResult.succeeded()}")
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_接收数据报包">接收数据报包</h3>
<div class="paragraph">
<p>若您想要接收数据包，则您需要调用 <code>listen(&#8230;&#8203;)</code> 方法绑定 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> 。</p>
</div>
<div class="paragraph">
<p>这样您就可以接收到被发送至 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramPacket.html">DatagramPacket</a></code> 所监听的地址和端口的 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> 。</p>
</div>
<div class="paragraph">
<p>除此之外，您还要设置一个 <code>Handler</code> ，每接收到一个 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramPacket.html">DatagramPacket</a></code> 时它都会被调用。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramPacket.html">DatagramPacket</a></code> 有以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramPacket.html#sender--">sender</a></code>: 表示数据发送方的 <code>InetSocketAddress</code> 。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramPacket.html#data--">data</a></code>: 保存接收数据的 <code>Buffer</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当您需要监听一个特定地址和端口时，您可以像下边这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var socket = vertx.createDatagramSocket(DatagramSocketOptions())
socket.listen(1234, "0.0.0.0", { asyncResult -&gt;
  if (asyncResult.succeeded()) {
    socket.handler({ packet -&gt;
      // Do something with the packet
    })
  } else {
    println("Listen failed${asyncResult.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，即使 {code AsyncResult} 成功，它只意味着它可能已经写入了网络堆栈，但不保证它已经到达或者将到达远端。</p>
</div>
<div class="paragraph">
<p>若您需要这样的保证，您可在TCP之上建立一些握手逻辑。</p>
</div>
</div>
<div class="sect2">
<h3 id="_多播">多播</h3>
<div class="sect3">
<h4 id="_发送多播数据包">发送多播数据包</h4>
<div class="paragraph">
<p>多播允许多个Socket接收相同的数据包，该目标可以通过加入到同一个可发送数据包的多播组来实现。</p>
</div>
<div class="paragraph">
<p>我们将在下一节中介绍如何加入多播组，从而接收数据包。</p>
</div>
<div class="paragraph">
<p>现在让我们专注于如何发送多播报文，发送多播报文与发送普通数据报报文没什么不同。 唯一的区别是您可以将多播组的地址传递给 <code>send</code> 方法发送出去。</p>
</div>
<div class="paragraph">
<p>如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var socket = vertx.createDatagramSocket(DatagramSocketOptions())
var buffer = Buffer.buffer("content")
// Send a Buffer to a multicast address
socket.send(buffer, 1234, "230.0.0.1", { asyncResult -&gt;
  println("Send succeeded? ${asyncResult.succeeded()}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有已经加入多播组 <code>230.0.0.1</code> 的Socket都将收到该报文。</p>
</div>
<div class="sect4">
<h5 id="_接收多播数据包">接收多播数据包</h5>
<div class="paragraph">
<p>若要接收特定多播组的数据包，您需要通过调用 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> 的 <code>listen(&#8230;&#8203;)</code> 方法来绑定一个地址并且加入多播组，并加入多播组。</p>
</div>
<div class="paragraph">
<p>这样，您将能够接收到被发送到
<code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> 所监听的地址和端口的数据报，同时也可以接收被发送到该多播组的数据报。</p>
</div>
<div class="paragraph">
<p>除此之外，您还可设置一个处理器，它在每次接收到 <code>DatagramPacket</code> 时会被调用。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramPacket.html">DatagramPacket</a></code> 有以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sender()</code> : 表示数据报发送方的 <code>InetSocketAddress</code></p>
</li>
<li>
<p><code>data()</code> : 保存接收数据的 <code>Buffer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，要监听指定的地址和端口、并且接收多播组 <code>230.0.0.1</code> 的数据报，您将执行如下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var socket = vertx.createDatagramSocket(DatagramSocketOptions())
socket.listen(1234, "0.0.0.0", { asyncResult -&gt;
  if (asyncResult.succeeded()) {
    socket.handler({ packet -&gt;
      // Do something with the packet
    })

    // join the multicast group
    socket.listenMulticastGroup("230.0.0.1", { asyncResult2 -&gt;
      println("Listen succeeded? ${asyncResult2.succeeded()}")
    })
  } else {
    println("Listen failed${asyncResult.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_取消订阅_离开多播组">取消订阅/离开多播组</h5>
<div class="paragraph">
<p>有时候您想只在特定时间内接收多播组的数据包。</p>
</div>
<div class="paragraph">
<p>这种情况下，您可以先监听他们，之后再取消监听。</p>
</div>
<div class="paragraph">
<p>如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var socket = vertx.createDatagramSocket(DatagramSocketOptions())
socket.listen(1234, "0.0.0.0", { asyncResult -&gt;
  if (asyncResult.succeeded()) {
    socket.handler({ packet -&gt;
      // Do something with the packet
    })

    // join the multicast group
    socket.listenMulticastGroup("230.0.0.1", { asyncResult2 -&gt;
      if (asyncResult2.succeeded()) {
        // will now receive packets for group

        // do some work

        socket.unlistenMulticastGroup("230.0.0.1", { asyncResult3 -&gt;
          println("Unlisten succeeded? ${asyncResult3.succeeded()}")
        })
      } else {
        println("Listen failed${asyncResult2.cause()}")
      }
    })
  } else {
    println("Listen failed${asyncResult.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_屏蔽多播">屏蔽多播</h5>
<div class="paragraph">
<p>除了取消监听一个多播地址以外，也可以做到屏蔽指定发送者地址的多播。</p>
</div>
<div class="paragraph">
<p>请注意这仅适用于某些操作系统和内核版本，所以请检查操作系统文档看是它是否支持。</p>
</div>
<div class="paragraph">
<p>这是专家级别的技巧。</p>
</div>
<div class="paragraph">
<p>要屏蔽来自特定地址的多播，您可以在 <code>DatagramSocket</code> 上调用 <code>blockMulticastGroup(&#8230;&#8203;)</code> ，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var socket = vertx.createDatagramSocket(DatagramSocketOptions())

// Some code

// This would block packets which are send from 10.0.0.2
socket.blockMulticastGroup("230.0.0.1", "10.0.0.2", { asyncResult -&gt;
  println("block succeeded? ${asyncResult.succeeded()}")
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_datagramsocket_属性">DatagramSocket 属性</h4>
<div class="paragraph">
<p>当创建 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> 时，您可以通过
<code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html">DatagramSocketOptions</a></code> 对象来设置多个属性以更改它的功能。这些（属性）列在这儿：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setSendBufferSize-int-">setSendBufferSize</a></code> 以字节为单位设置发送缓冲区的大小。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setReceiveBufferSize-int-">setReceiveBufferSize</a></code> 设置TCP接收缓冲区大小（以字节为单位）。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setReuseAddress-boolean-">setReuseAddress</a></code> 若为 <code>true</code> ，则 <code>TIME_WAIT</code> 状态中的地址在关闭后可重用。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setTrafficClass-int-">setTrafficClass</a></code></p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setBroadcast-boolean-">setBroadcast</a></code> 设置或清除 <code>SO_BROADCAST</code> 套接字选项，设置此选项时，数据报（UDP）数据包可能会发送到本地接口的广播地址。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setMulticastNetworkInterface-java.lang.String-">setMulticastNetworkInterface</a></code> 设置或清除 <code>IP_MULTICAST_LOOP</code> 套接字选项，设置此选项时，多播数据包也将在本地接口上接收。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocketOptions.html#setMulticastTimeToLive-int-">setMulticastTimeToLive</a></code> 设置 <code>IP_MULTICAST_TTL</code> 套接字选项。TTL表示“活动时间”，单这种情况下，它指定允许数据包经过的IP跳数，特别是用于多播流量。转发数据包的每个路由器或网管会递减TTL，如果路由器将TTL递减为0，则不会再转发。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_datagramsocket本地地址">DatagramSocket本地地址</h4>
<div class="paragraph">
<p>Y若您在调用 <code>listen(&#8230;&#8203;)</code> 之前已经绑定了
bound the <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> ，您可以通过调用
<code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html#localAddress--">localAddress</a></code> 来查找套接字的本地地址（即UDP Socket这边的地址，它将返回一个InetSocketAddress，否则返回null。</p>
</div>
</div>
<div class="sect3">
<h4 id="_关闭datagramsocket">关闭DatagramSocket</h4>
<div class="paragraph">
<p>您可以通过调用 <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html#close-io.vertx.core.Handler-">close</a></code> 方法来关闭Socket，它将关闭Socket并释放所有资源。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dns_客户端">DNS 客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通常情况下，您需要以异步方式来获取DNS信息。
但不幸的是，Java 虚拟机本身附带的API是不可能的，因此Vert.x提供了它自己的完全异步解析DNS的API。</p>
</div>
<div class="paragraph">
<p>若要获取 <code>DnsClient</code> 实例，您可以通过 <code>Vertx</code> 实例来创建一个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "10.0.0.1")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also create the client with options and configure the query timeout.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(DnsClientOptions(
  port = 53,
  host = "10.0.0.1",
  queryTimeout = 10000))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creating the client with no arguments or omitting the server address will use the address of the server used internally
for non blocking address resolution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client1 = vertx.createDnsClient()

// Just the same but with a different query timeout
var client2 = vertx.createDnsClient(DnsClientOptions(
  queryTimeout = 10000))</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您可以传入 <code>InetSocketAddress</code> 参数的变量，以指定多个的DNS服务器来尝试查询解析DNS。它将按照此处指定的相同顺序查询DNS服务器，若在使用上一个DNS服务器解析时出现了错误，下一个将会被继续调用。</p>
</div>
<div class="sect2">
<h3 id="_lookup">lookup</h3>
<div class="paragraph">
<p>当尝试为一个指定名称元素获取A（ipv4）或 AAAA（ipv6）记录时，第一条被返回的（记录）将会被使用。它的操作方式和操作系统上使用 <code>nslookup</code> 类似。</p>
</div>
<div class="paragraph">
<p>要为 <code>vertx.io</code> 获取 A/AAAA 记录，您需要像下面那样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.lookup("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    println(ar.result())
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lookup4">lookup4</h3>
<div class="paragraph">
<p>尝试查找给定名称的A（ipv4）记录。第一个返回的（记录）将会被使用，因此它的操作方式与操作系统上使用 <code>nslookup</code> 类似。</p>
</div>
<div class="paragraph">
<p>要查找 <code>vertx.io</code> 的A记录，您需要像下面那样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.lookup4("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    println(ar.result())
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lookup6">lookup6</h3>
<div class="paragraph">
<p>尝试查找给定名称的 AAAA（ipv6）记录。第一个返回的（记录）将会被使用，因此它的操作方式与在操作系统上使用 <code>nslookup</code> 类似。</p>
</div>
<div class="paragraph">
<p>要查找 <code>vertx.io</code> 的 AAAA记录，您需要像下面那样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.lookup6("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    println(ar.result())
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvea">resolveA</h3>
<div class="paragraph">
<p>尝试解析给定名称的所有A（ipv4）记录，这与在unix操作系统上使用 <code>dig</code> 类似。</p>
</div>
<div class="paragraph">
<p>要查找 <code>vertx.io</code> 的所有A记录，您通常会执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolveA("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    var records = ar.result()
    for (record in records) {
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolveaaaa">resolveAAAA</h3>
<div class="paragraph">
<p>尝试解析给定名称的所有AAAA（ipv6）记录，这与在Unix操作系统上使用 <code>dig</code> 类似。</p>
</div>
<div class="paragraph">
<p>要查找 <code>vertx.io</code> 的所有AAAA记录，您通常会执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolveAAAA("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    var records = ar.result()
    for (record in records) {
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvecname">resolveCNAME</h3>
<div class="paragraph">
<p>尝试解析给定名称的所有CNAME记录，这与在Unix操作系统上使用 <code>dig</code> 类似。</p>
</div>
<div class="paragraph">
<p>要查找 <code>vertx.io</code> 的所有CNAME记录，您通常会执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolveCNAME("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    var records = ar.result()
    for (record in records) {
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvemx">resolveMX</h3>
<div class="paragraph">
<p>尝试解析给定名称的所有MX记录，MX记录用于定义哪个邮件服务器接受给定域的电子邮件。</p>
</div>
<div class="paragraph">
<p>要查找您常用执行的 <code>vertx.io</code> 的所有MX记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolveMX("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    var records = ar.result()
    for (record in records) {
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，列表将包含按照它们优先级排序的 <code><a href="../../apidocs/io/vertx/core/dns/MxRecord.html">MxRecord</a></code> ，这意味着列表中优先级低的MX记录会第一个优先出现在列表中。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/dns/MxRecord.html">MxRecord</a></code> 允许您通过下边提供的方法访问MX记录的优先级和名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">record.priority()
record.name()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvetxt">resolveTXT</h3>
<div class="paragraph">
<p>尝试解析给定名称的所有TXT记录，TXT记录通常用于定义域的额外信息。</p>
</div>
<div class="paragraph">
<p>要解析 <code>vertx.io</code> 的所有TXT记录，您可以使用下边几行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolveTXT("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    var records = ar.result()
    for (record in records) {
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvens">resolveNS</h3>
<div class="paragraph">
<p>尝试解析给定名称的所有NS记录，NS记录指定哪个DNS服务器托管给定域的DNS信息。</p>
</div>
<div class="paragraph">
<p>要解析 <code>vertx.io</code> 的所有NS记录，您可以使用下边几行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolveNS("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    var records = ar.result()
    for (record in records) {
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvesrv">resolveSRV</h3>
<div class="paragraph">
<p>尝试解析给定名称的所有SRV记录，SRV记录用于定义服务端口和主机名等额外信息。一些协议需要这个额外信息。</p>
</div>
<div class="paragraph">
<p>要查找 <code>vertx.io</code> 的所有SRV记录，您通常会执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolveSRV("vertx.io", { ar -&gt;
  if (ar.succeeded()) {
    var records = ar.result()
    for (record in records) {
      println(record)
    }
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，列表将包含按照它们优先级排序的 <code><a href="../../apidocs/io/vertx/core/dns/SrvRecord.html">SrvRecord</a></code> ，这意味着优先级低的记录会第一个优先出现在列表中。</p>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/dns/SrvRecord.html">SrvRecord</a></code> 允许您访问SRV记录本身中包含的所有信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">record.priority()
record.name()
record.weight()
record.port()
record.protocol()
record.service()
record.target()</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅API文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolveptr">resolvePTR</h3>
<div class="paragraph">
<p>尝试解析给定名称的PTR记录，PTR记录将 <code>ipaddress</code> 映射到名称。</p>
</div>
<div class="paragraph">
<p>要解析IP地址 <code>10.0.0.1</code> 的PTR记录，您将使用 <code>1.0.0.10.in-addr.arpa</code> 的PTR概念。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.resolvePTR("1.0.0.10.in-addr.arpa", { ar -&gt;
  if (ar.succeeded()) {
    var record = ar.result()
    println(record)
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reverselookup">reverseLookup</h3>
<div class="paragraph">
<p>尝试对ipaddress进行反向查找，这与解析PTR记录类似，但是允许您只传递ipaddress，而不是有效的PTR查询字符串。</p>
</div>
<div class="paragraph">
<p>要做ipaddress 10.0.0.1的反向查找类似的事：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var client = vertx.createDnsClient(53, "9.9.9.9")
client.reverseLookup("10.0.0.1", { ar -&gt;
  if (ar.succeeded()) {
    var record = ar.result()
    println(record)
  } else {
    println("Failed to resolve entry${ar.cause()}")
  }
})</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="streams">流</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x有多个对象可以用于文件的读取和写入。</p>
</div>
<div class="paragraph">
<p>在以前的版本中，只能通过操作指定的 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code>
对象来实现文件读写。从现在开始，流不再与 <code>Buffer</code> 耦合，它们可以和任意类型的对象一起工作。</p>
</div>
<div class="paragraph">
<p>在 Vert.x 中，写调用是立即返回的，而写操作的实际是在内部队列中排队写入。</p>
</div>
<div class="paragraph">
<p>不难看出，若写入对象的速度比实际写入底层数据资源速度快，那么写入队列就会无限增长，最终导致内存耗尽。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，Vert.x API中的一些对象提供了简单的流程控制（回压）功能。</p>
</div>
<div class="paragraph">
<p>任何可控制的写入流对象都实现了 <code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html">WriteStream</a></code> 接口，相应的，任何可控制的读取流对象都实现了
<code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html">ReadStream</a></code> 接口。</p>
</div>
<div class="paragraph">
<p>让我们举个例子，我们要从 <code>ReadStream</code> 中读取数据，然后将数据写入 <code>WriteStream</code> 。</p>
</div>
<div class="paragraph">
<p>一个非常简单的例子是从 <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 读取然后写回到同一个 <code>NetSocket</code> - 因为 <code>NetSocket</code> 既实现了 <code>ReadStream</code> 也实现了 <code>WriteStream</code> 接口。
请注意，这些操作适用于任何实现了 <code>ReadStream</code> 和 <code>WriteStream</code> 接口的对象，包括HTTP 请求、HTTP 响应、异步文件 I/O 和 WebSocket等。</p>
</div>
<div class="paragraph">
<p>一个最简单的方法是直接获取已经读取的数据，并立即将其写入 <code>NetSocket</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer(NetServerOptions(
  port = 1234,
  host = "localhost"))
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    // Write the data straight back
    sock.write(buffer)
  })
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的例子有一个问题：如果从Socket读取数据的速度比写回Socket的速度快，那么它将在 <code>NetSocket</code> 的写队列中不断堆积，最终耗尽内存。
这是有可能会发生，例如，若Socket另一端的客户端读取速度不够快，无法快速地向连接的另一端回压。</p>
</div>
<div class="paragraph">
<p>由于 <code>NetSocket</code> 实现了 <code>WriteStream</code> 接口，我们可以在写入之前检查 <code>WriteStream</code> 是否已满：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer(NetServerOptions(
  port = 1234,
  host = "localhost"))
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    if (!sock.writeQueueFull()) {
      sock.write(buffer)
    }
  })

}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子不会耗尽内存，但如果写入队列已满，我们最终会丢失数据。我们真正想要做的是在写入队列已满时暂停读取 <code>NetSocket</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer(NetServerOptions(
  port = 1234,
  host = "localhost"))
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    sock.write(buffer)
    if (sock.writeQueueFull()) {
      sock.pause()
    }
  })
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经快达到我们的目标，但还没有完全实现。现在 <code>NetSocket</code> 在文件已满时会暂停，但是当写队列处理完成时，我们需要取消暂停：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer(NetServerOptions(
  port = 1234,
  host = "localhost"))
server.connectHandler({ sock -&gt;
  sock.handler({ buffer -&gt;
    sock.write(buffer)
    if (sock.writeQueueFull()) {
      sock.pause()
      sock.drainHandler({ done -&gt;
        sock.resume()
      })
    }
  })
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们的目标实现了。当写队列准备好接收更多的数据时， <code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#drainHandler-io.vertx.core.Handler-">drainHandler</a></code>
事件处理器将被调用，它会恢复 <code>NetSocket</code> 的状态，允许读取更多的数据。</p>
</div>
<div class="paragraph">
<p>在编写Vert.x 应用程序时，这样做是很常见的，因此我们提供了一个名为 <code><a href="../../apidocs/io/vertx/core/streams/Pump.html">Pump</a></code> 的帮助类，它为您完成所有这些艰苦的工作。
您只需要给 <code>ReadStream</code> 追加上 <code>WriteStream</code> ，然后启动它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var server = vertx.createNetServer(NetServerOptions(
  port = 1234,
  host = "localhost"))
server.connectHandler({ sock -&gt;
  Pump.pump(sock, sock).start()
}).listen()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这和更加详细的例子完全一样。</p>
</div>
<div class="paragraph">
<p>现在我们来看看 <code>ReadStream</code> 和 <code>WriteStream</code> 的方法。</p>
</div>
<div class="sect2">
<h3 id="_readstream">ReadStream</h3>
<div class="paragraph">
<p><code>ReadStream</code> （可读流） 接口的实现类包括： <code><a href="../../apidocs/io/vertx/core/http/HttpClientResponse.html">HttpClientResponse</a></code> , <code><a href="../../apidocs/io/vertx/core/datagram/DatagramSocket.html">DatagramSocket</a></code> ,
<code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html">HttpClientRequest</a></code> , <code><a href="../../apidocs/io/vertx/core/http/HttpServerFileUpload.html">HttpServerFileUpload</a></code> ,
<code><a href="../../apidocs/io/vertx/core/http/HttpServerRequest.html">HttpServerRequest</a></code> , <code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html">MessageConsumer</a></code> ,
<code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> , <code><a href="../../apidocs/io/vertx/core/http/WebSocket.html">WebSocket</a></code> , <code><a href="../../apidocs/io/vertx/core/TimeoutStream.html">TimeoutStream</a></code> ,
<code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html">AsyncFile</a></code> .</p>
</div>
<div class="paragraph">
<p>函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-">handler</a></code> : 设置一个处理器，它将从 <code>ReadStream</code> 读取项</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html#pause--">pause</a></code> : 暂停处理器，暂停时，处理器中将不会受到任何项</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html#resume--">resume</a></code> : 恢复处理器，若任何项到达则处理器将被调用</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html#exceptionHandler-io.vertx.core.Handler-">exceptionHandler</a></code> : 若ReadStream发生异常，将被调用</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/ReadStream.html#endHandler-io.vertx.core.Handler-">endHandler</a></code> : 当流到达时将被调用。这有可能是到达了描述文件的EOF、达到HTTP请求的请求结束、或TCP Socket的连接被关闭</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_writestream">WriteStream</h3>
<div class="paragraph">
<p><code>WriteStream</code> （可写流）接口的实现类包括： <code><a href="../../apidocs/io/vertx/core/http/HttpClientRequest.html">HttpClientRequest</a></code> , <code><a href="../../apidocs/io/vertx/core/http/HttpServerResponse.html">HttpServerResponse</a></code>
<code><a href="../../apidocs/io/vertx/core/http/WebSocket.html">WebSocket</a></code> , <code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> , <code><a href="../../apidocs/io/vertx/core/file/AsyncFile.html">AsyncFile</a></code> ,
and <code><a href="../../apidocs/io/vertx/core/eventbus/MessageProducer.html">MessageProducer</a></code></p>
</div>
<div class="paragraph">
<p>函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-">write</a></code> : 写入一个对象到 <code>WriteStream</code> ，该方法将永远不会阻塞，内部是排队写入并且底层资源是异步写入。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#setWriteQueueMaxSize-int-">setWriteQueueMaxSize</a></code> : 设置写入队列被认为是 <strong>full</strong> 的对象的数量——方法 <code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#writeQueueFull--">writeQueueFull</a></code> 返回 <code>true</code> 。注意，当写队列被认为已满时，若写（操作）被调用则数据依然会被接收和排队。实际数量取决于流的实现，对于 <code><a href="../../apidocs/io/vertx/core/buffer/Buffer.html">Buffer</a></code> ，尺寸代表实际写入的字节数，而并非缓冲区的数量。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#writeQueueFull--">writeQueueFull</a></code> : 若写队列被认为已满，则返回 <code>true</code> 。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#exceptionHandler-io.vertx.core.Handler-">exceptionHandler</a></code> : 若 <code>WriteStream</code> 发生异常，则被调用。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#drainHandler-io.vertx.core.Handler-">drainHandler</a></code> : 若 <code>WriteStream</code> 被认为不再满，则处理器将被调用。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_泵">泵</h3>
<div class="paragraph">
<p>泵（Pump）的实例有以下几种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/Pump.html#start--">start</a></code> : 启动泵。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/Pump.html#stop--">stop</a></code> :
停止泵，当泵启动时它要处于停止模式。</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/core/streams/Pump.html#setWriteQueueMaxSize-int-">setWriteQueueMaxSize</a></code> :
与 <code>WriteStream</code> 接口的 <code><a href="../../apidocs/io/vertx/core/streams/WriteStream.html#setWriteQueueMaxSize-int-">setWriteQueueMaxSize</a></code> 方法相同。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个泵可以启动和停止多次。</p>
</div>
<div class="paragraph">
<p>当泵首次创建时，它不会启动，您需要调用 <code>start()</code> 方法来启动它。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_记录解析器">记录解析器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>记录解析器（Record Parser）允许您轻松解析由字节序列或固定尺寸带分隔符的记录的协议。
它将输入缓冲区序列转换为已配置的缓冲区序列（固定大小或带分隔符的记录）。</p>
</div>
<div class="paragraph">
<p>例如，若您使用 <code>\n</code> 分割的简单ASCII文本协议，并输入如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>buffer1:HELLO\nHOW ARE Y
buffer2:OU?\nI AM
buffer3: DOING OK
buffer4:\n</code></pre>
</div>
</div>
<div class="paragraph">
<p>记录解析器将生成下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>buffer1:HELLO
buffer2:HOW ARE YOU?
buffer3:I AM DOING OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来看看相关代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var parser = RecordParser.newDelimited("\n", { h -&gt;
  println(h.toString())
})

parser.handle(Buffer.buffer("HELLO\nHOW ARE Y"))
parser.handle(Buffer.buffer("OU?\nI AM"))
parser.handle(Buffer.buffer("DOING OK"))
parser.handle(Buffer.buffer("\n"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以生成固定尺寸的块，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">RecordParser.newFixed(4, { h -&gt;
  println(h.toString())
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请查看 <code><a href="../../apidocs/io/vertx/core/parsetools/RecordParser.html">RecordParser</a></code> 类。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_json_parser">Json Parser</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can easily parse JSON structures but that requires to provide the JSON content at once, but it
may not be convenient when you need to parse very large structures.</p>
</div>
<div class="paragraph">
<p>The non-blocking JSON parser is an event driven parser able to deal with very large structures.
It transforms a sequence of input buffer to a sequence of JSON parse events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Code not translatable</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parser is non-blocking and emitted events are driven by the input buffers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var parser = JsonParser.newParser()

// start array event
// start object event
// "firstName":"Bob" event
parser.handle(Buffer.buffer("[{\"firstName\":\"Bob\","))

// "lastName":"Morane" event
// end object event
parser.handle(Buffer.buffer("\"lastName\":\"Morane\"},"))

// start object event
// "firstName":"Luke" event
// "lastName":"Lucky" event
// end object event
parser.handle(Buffer.buffer("{\"firstName\":\"Luke\",\"lastName\":\"Lucky\"}"))

// end array event
parser.handle(Buffer.buffer("]"))

// Always call end
parser.end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Event driven parsing provides more control but comes at the price of dealing with fine grained events, which can be
inconvenient sometimes. The JSON parser allows you to handle JSON structures as values when it is desired:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Code not translatable</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value mode can be set and unset during the parsing allowing you to switch between fine grained
events or JSON object value events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Code not translatable</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do the same with arrays as well</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Code not translatable</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also decode POJOs</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">parser.handler({ event -&gt;
  // Handle each object
  // Get the field in which this object was parsed
  var id = event.fieldName()
  var user = event.mapTo(examples.ParseToolsExamples.User.`class`)
  println("User with id ${id} : ${user.firstName} ${user.lastName}")
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whenever the parser fails to process a buffer, an exception will be thrown unless you set an exception handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var parser = JsonParser.newParser()

parser.exceptionHandler({ err -&gt;
  // Catch any parsing or decoding error
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parser also parses json streams:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>concatenated json streams: <code>{"temperature":30}{"temperature":50}</code></p>
</li>
<li>
<p>line delimited json streams: <code>{"an":"object"}\r\n3\r\n"a string"\r\nnull</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more details, check out the <code><a href="../../apidocs/io/vertx/core/parsetools/JsonParser.html">JsonParser</a></code> class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_线程安全">线程安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大多数Vert.x 对象可以从被不同的线程安全地访问，但在相同的上下文中访问它们时，性能才是最优的。</p>
</div>
<div class="paragraph">
<p>例如，若您部署了一个创建 <code><a href="../../apidocs/io/vertx/core/net/NetServer.html">NetServer</a></code> 的Verticle，该 <code>NetServer</code> 在处理器中提供了
<code><a href="../../apidocs/io/vertx/core/net/NetSocket.html">NetSocket</a></code> 实例，则最好始终从该Verticle的Event Loop中访问Socket 实例。</p>
</div>
<div class="paragraph">
<p>如您坚持使用标准的Vert.x Verticle部署模型，避免在 Verticle 之间分享对象，那这种情况您无需考虑。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_metrics_spi">Metrics SPI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>默认情况下，Vert.x不会记录任何指标。相反，它为其他人提供了一个SPI，可以将其添加到类路径中。SPI是一项高级功能，允许实施者从Vert.x捕获事件以收集指标。有关详细信息，请参阅
<code><a href="../../apidocs/io/vertx/core/spi/metrics/VertxMetrics.html">API 文档</a></code> 。</p>
</div>
<div class="paragraph">
<p>若使用 <code><a href="../../apidocs/io/vertx/core/metrics/MetricsOptions.html#setFactory-io.vertx.core.spi.VertxMetricsFactory-">setFactory</a></code> 嵌入了Vert.x实例，也可以用编程方式指定度量工厂。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_osgi">OSGi</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Core被打包成了 OSGi Bundle，因此可以在任何OSGi R4.2+环境中使用，如 <code>Apache Felix</code> 或 <code>Eclipse Equinox</code> ，（这个）Bundle导出 <code>io.vertx.core*</code> 。</p>
</div>
<div class="paragraph">
<p>但是 Bundle 对 Jackson 和 Netty 有一些依赖，若部署Vert.x Core Bundle则需要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jackson Annotation [2.6.0,3)</p>
</li>
<li>
<p>Jackson Core [2.6.2,3)</p>
</li>
<li>
<p>Jackson Databind [2.6.2,3)</p>
</li>
<li>
<p>Netty Buffer [4.0.31,5)</p>
</li>
<li>
<p>Netty Codec [4.0.31,5)</p>
</li>
<li>
<p>Netty Codec/Socks [4.0.31,5)</p>
</li>
<li>
<p>Netty Codec/Common [4.0.31,5)</p>
</li>
<li>
<p>Netty Codec/Handler [4.0.31,5)</p>
</li>
<li>
<p>Netty Codec/Transport [4.0.31,5)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下边是Apache Felix 5.2.0上的工作部署：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>14|Active     |    1|Jackson-annotations (2.6.0)
15|Active     |    1|Jackson-core (2.6.2)
16|Active     |    1|jackson-databind (2.6.2)
18|Active     |    1|Netty/Buffer (4.0.31.Final)
19|Active     |    1|Netty/Codec (4.0.31.Final)
20|Active     |    1|Netty/Codec/HTTP (4.0.31.Final)
21|Active     |    1|Netty/Codec/Socks (4.0.31.Final)
22|Active     |    1|Netty/Common (4.0.31.Final)
23|Active     |    1|Netty/Handler (4.0.31.Final)
24|Active     |    1|Netty/Transport (4.0.31.Final)
25|Active     |    1|Netty/Transport/SCTP (4.0.31.Final)
26|Active     |    1|Vert.x Core (3.1.0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Equinox上，您可能需要使用下边的框架属性禁用ContextFilter： <code>eclipse.bundle.setTCCL=false</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vertx_命令行">vertx 命令行</h2>
<div class="sectionbody">
<div class="paragraph">
<p>vertx 命令行工具用于在终端中与 Vert.x 进行交互。主要用于运行 Vert.x Verticle。
为此，您需要下载并安装Vert.x 发行版，并将安装目录中的 <code>bin</code> 添加到 <code>PATH</code> 环境变量中，还要确保您的 <code>PATH</code> 上有一个Java 8的JDK。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
JDK需要支持Java代码的快速编译。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_运行_verticle">运行 Verticle</h3>
<div class="paragraph">
<p>您可以使用 <code>vertx run</code> 从命令行直接运行Vert.x 的 Verticle，以下是 <code>run</code> 命令的几个实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-verticle.js                                 (1)
vertx run my-verticle.groovy                             (2)
vertx run my-verticle.rb                                 (3)

vertx run io.vertx.example.MyVerticle                    (4)
vertx run io.vertx.example.MVerticle -cp my-verticle.jar (5)

vertx run MyVerticle.java                                (6)</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>部署一个JavaScript的Verticle</p>
</li>
<li>
<p>部署一个Groovy的Verticle</p>
</li>
<li>
<p>部署一个Ruby的Verticle</p>
</li>
<li>
<p>部署一个已经编译好的Java的Verticle，类的根路径是当前目录</p>
</li>
<li>
<p>部署一个已经打包成jar的Verticle，这个jar需要在类路径中</p>
</li>
<li>
<p>编译Java源代码并进行部署</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>正如您在Java中可看到的，该Verticle的名称要么是Java 完全限定类名，也可以指定Java 源文件，Vert.x会为你编译它。</p>
</div>
<div class="paragraph">
<p>您可以用其他语言的前缀来指定Verticle的名称进行部署。例如：若Verticle是一个编译的Groovy 类，您可以使用语言前缀 <code>groovy:</code> ，因此Vert.x 知道它是一个Groovy 类而不是Java 类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run groovy:io.vertx.example.MyGroovyVerticle</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>vertx run</code> 命令可以使用几个可选参数，它们是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-conf &lt;config_file&gt;</code> - 提供了Verticle的一些配置， <code>config_file</code> 是包含描述Verticle配置的JSON对象的文本文件的名称，该参数是可选的。</p>
</li>
<li>
<p><code>-cp &lt;path&gt;</code> - 搜索Verticle和它使用的其他任何资源的路径，默认为 <code>.</code> （当前目录）。若您的Verticle引用了其他脚本、类或其他资源（例如jar文件），请确保这些脚本、其他资源存在此路径上。该路径可以包含由以下内容分隔的多个路径条目： <code>:</code> （冒号）或 <code>;</code> （分号）——这取决于操作系统。每个路径条目可以是包含脚本的目录的绝对路径或相对路径，也可以是 <code>jar</code> 或 <code>zip</code> 文件的绝对或相对文件名。一个示例路径可能是 <code>-cp classes:lib/otherscripts:jars/myjar.jar:jars/otherjar.jar</code> 。始终使用路径引用您的Verticle需要的任何资源，不要将它们放在系统类路径上，因为这会导致部署的Verticle之间的隔离问题。</p>
</li>
<li>
<p><code>-instances &lt;instances&gt;</code>  - 要实例化的Verticle实例的数目，每个Verticle实例都是严格单线程（运行）的，以便在可用的核上扩展应用程序，您可能需要部署多个实例。若省略，则部署单个实例。</p>
</li>
<li>
<p><code>-worker</code> - 此选项可确定一个Verticle是否为Worker Verticle。</p>
</li>
<li>
<p><code>-cluster</code> -  此选项确定Vert.x实例是否尝试与网络上的其他Vert.x实例形成集群，集群Vert.x实例允许Vert.x与其他节点形成分布式Event Bus。默认为false（非集群模式）。</p>
</li>
<li>
<p><code>-cluster-port</code> - 若指定了 <code>cluster</code> 选项，则可以确定哪个端口将用于与其他Vert.x实例进行集群通信。默认为0——这意味着“选择一个空闲的随机端口”。除非您帧需要绑定特定端口，您通常不需要指定此参数。</p>
</li>
<li>
<p><code>-cluster-host</code> - 若指定了 <code>cluster</code> 选项，则可以确定哪个主机地址将用于其他Vert.x实例进行集群通信。默认情况下，它将尝试从可用的接口中选一个。若您有多个接口而您想要使用指定的一个，就在这里指定。</p>
</li>
<li>
<p><code>-ha</code> - 若指定，该Verticle将部署为（支持）高可用性（HA）。有关详细信息，请参阅相关章节。</p>
</li>
<li>
<p><code>-quorum</code> - 该参数需要和 <code>-ha</code> 一起使用，它指定集群中所有HA部署ID处于活动状态的最小节点数，默认为0。</p>
</li>
<li>
<p><code>-hagroup</code> - 该参数需要和 <code>-ha</code> 一起使用，它指定此节点将加入的HA组。集群中可以有多个HA组，节点只会故障转移到同一组中的其他节点。默认为 __DEFAULT__ 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以使用下边方式设置系统属性： <code>-Dkey=value</code> 。</p>
</div>
<div class="paragraph">
<p>下面有更多的例子：</p>
</div>
<div class="paragraph">
<p>使用默认设置运行JavaScript的Verticle：server.js：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run server.js</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行指定类路径的预编译好的10个Java Verticle实例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run com.acme.MyVerticle -cp "classes:lib/myjar.jar" -instances 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过源文件运行10个Java Verticle的实例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run MyVerticle.java -instances 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行20个Ruby语言的Worker Verticle实例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run order_worker.rb -instances 20 -worker</code></pre>
</div>
</div>
<div class="paragraph">
<p>在同一台计算机上运行两个JavaScript Verticle，并让它们彼此在网络上的其他任何服务器上集群在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run handler.js -cluster
vertx run sender.js -cluster</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行一个Ruby Verticle并传入一些配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my_verticle.rb -conf my_verticle.conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>my_verticle.conf</code> 也许会包含以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
"name": "foo",
"num_widgets": 46
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该配置可通过Core API在Verticle内部可用。</p>
</div>
<div class="paragraph">
<p>当使用Vert.x的高可用功能时，您可能需要创建一个Vert.x的 <strong>裸</strong> 实例。此实例在启动时未部署任何Verticle，但它若接收到若集群中的另一个节点死亡，则会在此节点运行之前挂掉的实例。如需要创建一个 <strong>裸</strong> 实例，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx bare</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据您的集群配置，您可能需要添加 <code>cluster-host</code> 和 <code>cluster-port</code> 参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_执行打包成_fat_jar_的vert_x_应用">执行打包成 fat-jar 的Vert.x 应用</h3>
<div class="paragraph">
<p>fat-jar 是一个包含了所有依赖项jar的可执行的jar，这意味着您不必在执行jar的机器上预先安装Vert.x。它像任何可执行的Java jar一样可直接执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar my-application-fat.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于这点，Vert.x 没什么特别的，您可以使用任何Java应用程序。</p>
</div>
<div class="paragraph">
<p>您可以创建自己的主类并在 MANIFEST 中指定，但建议您将代码编写成Verticle，并使用Vert.x中的 <code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code> 类 ( <code>io.vertx.core.Launcher</code> ) 作为您的主类。这是在命令行中运行Vert.x使用的主类，因此允许您指定命令行参数，如 <code>-instances</code> 以便更轻松地扩展应用程序。</p>
</div>
<div class="paragraph">
<p>要将您的Verticle全部部署在这个 <code>fat-jar</code> 中时，您必须将下边信息写入MANIFEST：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Main-Class</code> 设置为 <code>io.vertx.core.Launcher</code></p>
</li>
<li>
<p><code>Main-Verticle</code> 指定要运行的Main Verticle（Java完全限定类名或脚本文件名）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以提供您将传递给 <code>vertx run</code> 的常用命令行参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar my-verticle-fat.jar -cluster -conf myconf.json
java -jar my-verticle-fat.jar -cluster -conf myconf.json -cp path/to/dir/conf/cluster_xml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
请参阅官方 Vert.x Examples 仓库中中的 Maven/Gradle 相应示例来了解如何将应用打包成 <strong>fat-jar</strong>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过 fat jar 运行应用时，默认会执行 <code>run</code> 命令。</p>
</div>
</div>
<div class="sect2">
<h3 id="_显示vert_x的版本">显示Vert.x的版本</h3>
<div class="paragraph">
<p>若想显示Vert.x的版本，只需执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx version</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_其他命令">其他命令</h3>
<div class="paragraph">
<p>除了 <code>run</code> 和 <code>version</code> 以外， <code>vertx</code> 命令行和 <code>Launcher</code> 还提供了其他命令：</p>
</div>
<div class="paragraph">
<p>您可以使用下边命令创建一个 <code>bare</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx bare
# or
java -jar my-verticle-fat.jar bare</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以在后台启动应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar my-verticle-fat.jar start --vertx-id=my-app-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>若 <code>my-app-name</code> 未设置，将生成一个随机的id，并在命令提示符中打印。您可以将 <code>run</code> 选项传递给 <code>start</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar my-verticle-fat.jar start —-vertx-id=my-app-name -cluster</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦在后台启动，可以使用 <code>stop</code> 命令停止它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar my-verticle-fat.jar stop my-app-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用一下方式列出后台启动的Vert.x应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar my-verticle-fat.jar list</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>vertx</code> 工具也可以使用 <code>start</code> 、 <code>stop</code> 和 <code>list</code> 命令， <code>start</code> 命令支持几个选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>vertx-id</code> : 应用程序ID，若未设置，则使用随机UUID</p>
</li>
<li>
<p><code>java-opts</code> : Java虚拟机选项，若未设置，则使用 <code>JAVA_OPTS</code> 环境变量</p>
</li>
<li>
<p><code>redirect-output</code> : 重定向生成的进程输出和错误流到父进程流</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>若选项值包含空白，请不要忘记在 <code>""</code> （双引号）之间包装值。</p>
</div>
<div class="paragraph">
<p>由于 <code>start</code> 命令产生一个新的进程，传递给JVM的java选项不会被传播，所以您必须使用 <code>java-opts</code> 来配置JVM（ <code>-X</code> ， <code>-D</code> &#8230;&#8203;）。若您使用 <code>CLASSPATH</code> 环境变量，请确保路径下包含所有需要的jar（vertx-core、您的jar和所有依赖项）。</p>
</div>
<div class="paragraph">
<p>该命令集是可扩展的，请参考 <a href="#Extending_the_vert_x_Launcher">扩展 Vert.x 启动器</a> 部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_实时重部署">实时重部署</h3>
<div class="paragraph">
<p>在开发时，可以方便在文件更改时实时重新部署应用程序。 <code>vertx</code> 命令行工具和更普遍的 <code>Launcher</code> 类提供了这个功能。这里有些例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run MyVerticle.groovy --redeploy="**&amp;#47;*.groovy" --launcher-class=io.vertx.core.Launcher
vertx run MyVerticle.groovy --redeploy="**&amp;#47;*.groovy,**&amp;#47;*.rb"  --launcher-class=io.vertx.core.Launcher
java io.vertx.core.Launcher run org.acme.MyVerticle --redeploy="**&amp;#47;*.class"  --launcher-class=io.vertx.core
.Launcher -cp ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>重新部署过程如下执行。首先，您的应用程序作为后台应用程序启动（使用 <code>start</code> 命令）。当发现文件更改时，该进程将停止并重新启动该应用。这样可避免泄露。</p>
</div>
<div class="paragraph">
<p>要启用实时重新部署，请将 <code>--redeploy</code> 选项传递给 <code>run</code> 命令。 <code>--redeploy</code> 表示要监视的文件集，这个集合可使用 <code>Ant</code> 样式模式（使用 <code><strong>*</code> ， <code></strong></code> 和 <code>?</code> ），您也可以使用逗号（ <code>,</code> ）分隔它们来指定多个集合。模式相当于当前工作目录。</p>
</div>
<div class="paragraph">
<p>传递给 <code>run</code> 命令的参数最终会传递给应用程序，可使用 <code>--java-opts</code> 配置JVM虚拟机选项。例如，如果想传入一个 <code>conf</code> 参数或是系统属性，您可以使用 <code>--java-opts="-conf=my-conf.json -Dkey=value"</code> 。</p>
</div>
<div class="paragraph">
<p><code>--launcher-class</code> 选项确定应用程序的主类启动器。它通常是一个
<code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code> ，单您已使用了您自己的主类。</p>
</div>
<div class="paragraph">
<p>也可以在IDE中使用重部署功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eclipse - 创建一个运行配置，使用 <code>io.vertx.core.Launcher</code> 类作为主类。在 <strong>Program Arguments</strong> 区域（参数选项卡中），写入 <code>run your-verticle-fully-qualified-name --redeploy=<strong>*/</strong>.java --launcher-class=io.vertx.core.Launcher</code> ，您还可以添加其他参数。随着 Eclipse 在保存时会增量编译您的文件，重部署工作会顺利进行。</p>
</li>
<li>
<p>IntelliJ - 创建一个运行配置（应用）,将主类设置为 <code>io.vertx.core.Launcher</code> 。在程序参数中写： <code>run your-verticle-fully-qualified-name --redeploy=<strong>*/</strong>.class --launcher-class=io.vertx.core.Launcher</code> 。要触发重新部署，您需要显示构造项目或模块（Build &#8594; Make project）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要调试应用程序，请将运行配置创建为远程应用程序，并使用 <code>--java-opts</code> 配置调试器。每次重新部署后，请勿忘记重新插入(re-plug)调试器，因为它每次都会创建一个新进程。</p>
</div>
<div class="paragraph">
<p>您还可以在重新部署周期中挂接（hook）构建过程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar target/my-fat-jar.jar --redeploy="**&amp;#47;*.java" --on-redeploy="mvn package"
java -jar build/libs/my-fat-jar.jar --redeploy="src&amp;#47;**&amp;#47;*.java" --on-redeploy='./gradlew shadowJar'</code></pre>
</div>
</div>
<div class="paragraph">
<p>"on-redeploy"选项指定在应用程序关闭后和重新启动之前调用的命令。因此，如果更新某些运行时工作，则可以钩住构建工具。例如，您可以启动 <code>gulp</code> 或 <code>grunt</code> 来更新您的资源。如果您的应用需要 <code>--java-opts</code> ，不要忘记将它添加到命令参数里：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar target/my-fat-jar.jar --redeploy="**&amp;#47;*.java" --on-redeploy="mvn package" --java-opts="-Dkey=val"
java -jar build/libs/my-fat-jar.jar --redeploy="src&amp;#47;**&amp;#47;*.java" --on-redeploy='./gradlew shadowJar' --java-opts="-Dkey=val"</code></pre>
</div>
</div>
<div class="paragraph">
<p>重新部署功能还支持以下设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>redeploy-scan-period</code> : 文件系统检查周期（以毫秒为单位），默认为250ms</p>
</li>
<li>
<p><code>redeploy-grace-period</code> : 在2次重新部署之间等待的时间（以毫秒为单位），默认为1000ms</p>
</li>
<li>
<p><code>redeploy-termination-period</code> : 停止应用程序后等待的时间（在启动用户命令之前）。这个在Windows上非常有用，因为这个进程并没立即被杀死。时间以毫秒为单位，默认20ms</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_集群管理器">集群管理器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Vert.x 中，集群管理器可用于各种功能，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对集群中 Vert.x 节点发现和分组</p>
</li>
<li>
<p>维护集群范围中的主题订阅者列表（所以我们可知道哪些节点对哪个Event Bus地址感兴趣）</p>
</li>
<li>
<p>分布式Map的支持</p>
</li>
<li>
<p>分布式锁</p>
</li>
<li>
<p>分布式计数器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>集群管理器不处理Event Bus节点之间的传输，这是由 Vert.x 直接通过TCP连接完成。</p>
</div>
<div class="paragraph">
<p>Vert.x发行版中使用的默认集群管理器是使用的 <a href="http://hazelcast.com">Hazelcast</a> 集群管理器，但是它可以轻松被替换成实现了Vert.x集群管理器接口的不同实现，因为Vert.x集群管理器可替换的。</p>
</div>
<div class="paragraph">
<p>集群管理器必须实现 <code><a href="../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html">ClusterManager</a></code> 接口，Vert.x在运行时使用Java的服务加载器
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">Service Loader</a> 功能查找集群管理器，以便在类路径中查找
<code><a href="../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html">ClusterManager</a></code> 的实例。</p>
</div>
<div class="paragraph">
<p>若您在命令行中使用Vert.x并要使用集群，则应确保Vert.x安装的 <code>lib</code> 目录包含您的集群管理器jar。</p>
</div>
<div class="paragraph">
<p>若您在 Maven/Gradle 项目使用Vert.x，则只需将集群管理器jar作为项目依赖添加。</p>
</div>
<div class="paragraph">
<p>您也可以以编程的方式在嵌入Vert.x 时使用
<code><a href="../../apidocs/io/vertx/core/VertxOptions.html#setClusterManager-io.vertx.core.spi.cluster.ClusterManager-">setClusterManager</a></code> 指定集群管理器。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_日志记录">日志记录</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x使用内置的日志API进行记录日志，默认实现使用JDK（JUL）日志，不需要额外的依赖项。</p>
</div>
<div class="sect2">
<h3 id="_配置jul日志记录">配置JUL日志记录</h3>
<div class="paragraph">
<p>一个JUL日志记录配置文件可以使用普通的JUL方式指定——通过提供一个名为 <code>java.util.logging.config.file</code> 的系统属性值为您的配置文件。更多关于此部分以及JUL配置文件结构的内容，请参阅JUL日志记录文档。</p>
</div>
<div class="paragraph">
<p>Vert.x还提供了一种更方便的方式指定配置文件，无需设置系统属性。您只需在您的类路径中提供名为 <code>vertx-default-jul-logging.properties</code> 的JUL配置文件（例如在您的fatjar中），Vert.x将使用该配置文件配置JUL。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用另一个日志框架">使用另一个日志框架</h3>
<div class="paragraph">
<p>如果您不希望Vert.x使用JUL记录日志，您可以为其配置另一个日志记录框架，例如Log4J或SLF4J。</p>
</div>
<div class="paragraph">
<p>为此，您应该设置一个名为 <code>vertx.logger-delegate-factory-class-name</code> 的系统属性，该属性的值是一个实现了 <code><a href="../../apidocs/io/vertx/core/spi/logging/LogDelegateFactory.html">LogDelegateFactory</a></code> 接口的Java 类名。
我们为Log4J（版本1）、Log4J 2和SLF4J提供了预设的实现，类名为： <code>io.vertx.core.logging.Log4jLogDelegateFactory</code> ， <code>io.vertx.core.logging.Log4j2LogDelegateFactory</code> 和 <code>io.vertx.core.logging.SLF4JLogDelegateFactory</code> 。
如您要使用这些实现，还应确保相关的Log4J或SLF4J的jar在您的类路径上。</p>
</div>
<div class="paragraph">
<p>请注意，提供的Log4J 1代理不支持参数化消息。Log4J 2的代理使用了像SLF4J代理这样的 <code>{}</code> 语法，JUL代理使用如 <code>{x}</code> 语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_应用中记录日志">应用中记录日志</h3>
<div class="paragraph">
<p>Vert.x本身只是一个库，您可以在自己的应用程序使用任何日志库的API来记录日志。</p>
</div>
<div class="paragraph">
<p>但是，若您愿意，也可以使用上述的Vert.x日志记录工具为应用程序记录日志。</p>
</div>
<div class="paragraph">
<p>为此，您需要使用 <code><a href="../../apidocs/io/vertx/core/logging/LoggerFactory.html">LoggerFactory</a></code> 获取一个 <code><a href="../../apidocs/io/vertx/core/logging/Logger.html">Logger</a></code>
对象以记录日志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Note -these classes are Java only

// You would normally maintain one static instance of Logger per Java class:

var logger = io.vertx.core.logging.LoggerFactory.getLogger(className)

logger.info("something happened")
logger.error("oops!", exception)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
不同的日志实现会使用不同的占位符。这意味着，如果你使用了 Vert.x 的参数化的日志记录方法，当你切换日志的实现时，你可能需要修改你的代码。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="netty-logging">Netty日志记录</h3>
<div class="paragraph">
<p>配置日志记录时，您也应该关心配置Netty日志记录。</p>
</div>
<div class="paragraph">
<p>Netty不依赖于外部日志配置（例如系统属性），而是根据Netty类可见的日志记录库来实现日志记录：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如 <code>SLF4J</code> 可见，则优先使用该库</p>
</li>
<li>
<p>否则若 <code>Log4j</code> 可见，再使用该库</p>
</li>
<li>
<p>否则退回使用 <code>java.util.logging</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可通过设置 <code>io.netty.util.internal.logging.InternalLoggerFactory</code> 强制Netty使用某个特定实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// 强制使用Log4j日志记录
InternalLoggerFactory.setDefaultFactory(Log4JLoggerFactory.INSTANCE);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_故障排除">故障排除</h3>
<div class="sect3">
<h4 id="_slf4j启动警告">SLF4J启动警告</h4>
<div class="paragraph">
<p>若您在启动应用程序时看到以下信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</pre>
</div>
</div>
<div class="paragraph">
<p>I这意味着您的类路径中有 <code>SLF4J-API</code> 却没绑定。 <code>SLF4J</code> 记录的消息将会丢失。您应该将绑定加入您的类路径。参考 <a href="https://www.slf4j.org/manual.html">SLF4J user manual - Binding with a logging framework at deployment time</a> 选择绑定并配置。</p>
</div>
<div class="paragraph">
<p>请注意，Netty会寻找 <code>SLF4-API</code> 的jar，并在缺省情况下使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_对等连接重置">对等连接重置</h4>
<div class="paragraph">
<p>若您的日志显示一堆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>io.vertx.core.net.impl.ConnectionBase
SEVERE: java.io.IOException: Connection reset by peer</pre>
</div>
</div>
<div class="paragraph">
<p>这意味着客户端正在重置HTTP连接，而不是关闭它。此消息还可能表示您没有读取完整的有效负荷（连接在读取完全之前被切断）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
译者注：<strong>通常情况下，这是正常的，无需担心，如果您打开浏览器，按快捷键不停滴刷新页面，就能看到该SEVERE日志。</strong>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_主机名解析">主机名解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x使用地址解析器将主机名解析为IP地址，而不是JVM内置的阻塞解析器。</p>
</div>
<div class="paragraph">
<p>主机名使用以下方式解析为IP地址：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>操作系统的hosts文件</p>
</li>
<li>
<p>DNS查询服务器列表</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，它将使用环境中系统DNS服务器地址的列表，若该列表无法检索，将使用Google的公共DNS服务器 <code>8.8.8.8</code> 和 <code>8.8.4.4</code> 。</p>
</div>
<div class="paragraph">
<p>创建 <code><a href="../../apidocs/io/vertx/core/Vertx.html">Vertx</a></code> 实例时也可配置DNS 服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var vertx = Vertx.vertx(VertxOptions(
  addressResolverOptions = AddressResolverOptions(
    servers = listOf("192.168.0.1", "192.168.0.2:40000"))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>DNS 服务器的默认端口为 <code>53</code> ，当服务器使用不同的端口时，可以使用冒号分隔符设置该端口： <code>192.168.0.2:40000</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
有时可能需要使用JVM内置解析器。可以在启动的时候加上JVM系统属性 <code>-Dvertx.disableDnsResolver=true</code> 激活该行为。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_故障转移">故障转移</h3>
<div class="paragraph">
<p>当服务器没有及时回应时，尝试从列表中选择下一个解析器，搜索（数量）的限制由 <code><a href="../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#setMaxQueries-int-">setMaxQueries</a></code> 设置（默认值是4个查询）</p>
</div>
<div class="paragraph">
<p>若解析器在
<code><a href="../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#getQueryTimeout--">getQueryTimeout</a></code> 毫秒内没有收到正确答案（默认为5秒），DNS查询被视为失败。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务器列表轮询">服务器列表轮询</h3>
<div class="paragraph">
<p>默认情况下，DNS服务器选择使用第一个，其余的服务器用于故障转移。</p>
</div>
<div class="paragraph">
<p>您可以配置 <code><a href="../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#setRotateServers-boolean-">setRotateServers</a></code> 为 <code>true</code> ，让解析器使用轮询选择。它会在服务器之间传播查询负载，并避免所有的查找都找到列表中的第一个服务器。</p>
</div>
<div class="paragraph">
<p>故障转移仍然适用，并将使用列表中的下一个服务器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_主机映射">主机映射</h3>
<div class="paragraph">
<p>操作系统的hosts文件用于对ipaddress执行主机名查找。</p>
</div>
<div class="paragraph">
<p>可替换主机文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var vertx = Vertx.vertx(VertxOptions(
  addressResolverOptions = AddressResolverOptions(
    hostsPath = "/path/to/hosts")))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_搜索域名">搜索域名</h3>
<div class="paragraph">
<p>默认情况下，解析器将使用环境中的系统DNS搜索域，或者，可提供明确的显示搜索域列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var vertx = Vertx.vertx(VertxOptions(
  addressResolverOptions = AddressResolverOptions(
    searchDomains = listOf("foo.com", "bar.com"))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用搜索域列表时，点数的阈值为 <code>1</code> ，或从Linux上的 <code>/etc/resolv.conf</code> 加载，也可使用  <code><a href="../../apidocs/io/vertx/core/dns/AddressResolverOptions.html#setNdots-int-">setNdots</a></code> 方法配置特定值。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="high_Availability_and_Fail_Over">高可用和故障转移</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x允许您运行支持高可用（HA，High Availability）的Verticle。这种情况下，当运行Verticle的Vert.x实例突然挂掉时，该Veritlce将迁移到另一个Vert.x 实例。这个Vert.x 实例必须在同一个集群中。</p>
</div>
<div class="sect2">
<h3 id="_自动故障转移">自动故障转移</h3>
<div class="paragraph">
<p>当Vert.x启用HA运行时，若一个运行了Verticle的Vert.x 实例失败或挂掉，则此Verticle将自动重新部署到集群中的另一个Vert.x 实例中。我们称这个为 Verticle 故障转移（failover）。</p>
</div>
<div class="paragraph">
<p>若要启用HA模式，在启动 Vert.x 应用的时候需要添加 <code>-ha</code> 参数到命令行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-verticle.js -ha</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在开启了HA环境，在集群中需要多添加一个Vert.x 实例，所以假设您已经有另一个已经启动的Vert.x 实例，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-other-verticle.js -ha</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果运行了 <code>my-verticle.js</code> 的Vert.x 实例现在死了（您可以通过执行 <code>kill -9</code> 杀死进程来测试），
运行 <code>my-other-verticle.js</code> 的Vert.x 实例将自动重新部署 <code>my-verticle.js</code> ，所以现在这个Vert.x 实例正在运行两个Verticle。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
只有当第二个Vert.x 实例可访问对应的 verticle 文件（这里是 <code>my-verticle.js</code> ）时，迁移才是可能的。
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
干净地关闭Vert.x实例不会导致故障转移发生，例如：<strong>CTRL-C</strong> 或 <strong>kill -SIGNINT</strong>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您也可以启动裸的Vert.x 实例 —— 即最初不运行任何Verticle的实例，它们也将为集群中的节点进行故障转移。要启动一个裸实例，您只需做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run -ha</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>-ha</code> 开关时，您不需要提供 <code>-cluster</code> 开关，因为若要使用HA就假定是集群。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
根据您的集群配置，可能需要自定义集群管理器配置（默认为Hazelcast）和/或添加集群主机 <code>cluster-host</code> 和集群端口 <code>cluster-port</code> 参数。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ha组">HA组</h3>
<div class="paragraph">
<p>当使用Vert.x运行实例时，还可以选择指定的HA组。HA组表示集群中的逻辑节点组。只有具有相同HA组的节点能执行故障转移。若不指定HA组，则使用默认组 <code><em>DEFAULT</em></code> 。</p>
</div>
<div class="paragraph">
<p>要指定一个HA组，您可以在运行该Verticle时使用 <code>-hagroup</code> 开关。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-verticle.js -ha -hagroup my-group</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来看一个例子：</p>
</div>
<div class="paragraph">
<p>在第一个终端运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-verticle.js -ha -hagroup g1</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二个终端中，让我们使用相同组运行另一个Verticle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-other-verticle.js -ha -hagroup g1</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，在第三个终端中，使用不同组启动另一个Verticle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run yet-another-verticle.js -ha -hagroup g2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果终端1中的实例被杀掉，则它将故障转移到终端2中的实例，而不是具有不同组的终端3中的实例。</p>
</div>
<div class="paragraph">
<p>若终端3中的实例被杀掉，因为这个组中没有其他Vert.x实例，则它不会故障转移。</p>
</div>
</div>
<div class="sect2">
<h3 id="_处理网络分区_quora">处理网络分区 - Quora</h3>
<div class="paragraph">
<p>高可用HA实现同样支持 Quora（多数派机制）。Quorum 是分布式事务必须获得的最小票数才能被允许在分布式系统中执行操作的一个参数。</p>
</div>
<div class="paragraph">
<p>在启动 Vert.x 实例时，您可以指示它在部署任何HA部署之前需要一个 <code>quorum</code> 。该上下文环境中，一个 quorum 是集群中特定组的最小节点数。通常您选择 quorum 大小为 <code>Q = 1 + N / 2</code> ，其中N是组中节点数。若集群中的Q节点少于HA节点，HA部署将被撤销。如果/当 quorum 重新获取时，他们将重新部署。通过这样做您可以防止网络分区，也就是脑裂（split brain）。</p>
</div>
<div class="paragraph">
<p>更多关于Quorum（多数派机制）的信息，请参考 <a href="http://en.wikipedia.org/wiki/Quorum_(distributed_computing)">这里</a> 。</p>
</div>
<div class="paragraph">
<p>若要使用 quorum 运行Vert.x实例，您可以在命令行中指定 <code>-quorum</code> ，例如：</p>
</div>
<div class="paragraph">
<p>在第一个终端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-verticle.js -ha -quorum 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时，Vert.x实例将启动但不部署模块（尚未）因为目前集群中只有1个节点，而不是3个。</p>
</div>
<div class="paragraph">
<p>在第二个终端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my-other-verticle.js -ha -quorum 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时，Vert.x实例将启动但不部署模块（尚未）因为目前集群中只有2个节点，而不是3个。</p>
</div>
<div class="paragraph">
<p>在第三个控制台，您可以启动另一个Vert.x的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run yet-another-verticle.js -ha -quorum 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>妙极！—— 我们有三个节点，这是 quorum 设置的值，此时，模块将自动部署在所有实例上。</p>
</div>
<div class="paragraph">
<p>若我们现在关闭或杀死其中一个节点，那么这些模块将在其他节点上自动撤销，因为不再满足 quorum（法定人数）。</p>
</div>
<div class="paragraph">
<p>Quora 也可以与HA组合使用，在这种情况下，每个特定组会解决 Quora。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_native_transports">Native transports</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x can run with <a href="http://netty.io/wiki/native-transports.html">native transports</a> (when available) on BSD (OSX) and Linux:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var vertx = Vertx.vertx(VertxOptions(
  preferNativeTransport = true))

// True when native is available
var usingNative = vertx.isNativeTransportEnabled()
println("Running with native: ${usingNative}")</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
preferring native transport will not prevent the application to execute, if your application requires native
transport, you need to check <code><a href="../../apidocs/io/vertx/core/Vertx.html#isNativeTransportEnabled--">isNativeTransportEnabled</a></code> .
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_native_linux_transport">Native Linux Transport</h3>
<div class="paragraph">
<p>You need to add the following dependency in your classpath:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
 &lt;groupId&gt;io.netty&lt;/groupId&gt;
 &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;
 &lt;version&gt;4.1.15.Final&lt;/version&gt;
 &lt;classifier&gt;linux-x86_64&lt;/classifier&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Native on Linux gives you extra networking options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SO_REUSEPORT</p>
</li>
<li>
<p>TCP_QUICKACK</p>
</li>
<li>
<p>TCP_CORK</p>
</li>
<li>
<p>TCP_FASTOPEN</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Available on Linux
vertx.createHttpServer(HttpServerOptions(
  tcpFastOpen = fastOpen,
  tcpCork = cork,
  tcpQuickAck = quickAck,
  reusePort = reusePort))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_native_bsd_transport">Native BSD Transport</h3>
<div class="paragraph">
<p>You need to add the following dependency in your classpath:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
 &lt;groupId&gt;io.netty&lt;/groupId&gt;
 &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;
 &lt;version&gt;4.1.15.Final&lt;/version&gt;
 &lt;classifier&gt;osx-x86_64&lt;/classifier&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>MacOS Sierra and above are supported.</p>
</div>
<div class="paragraph">
<p>Native on BSD gives you extra networking options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SO_REUSEPORT</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Available on BSD
vertx.createHttpServer(HttpServerOptions(
  reusePort = reusePort))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_domain_sockets">Domain sockets</h3>
<div class="paragraph">
<p>Natives provide domain sockets support for <code>NetServer</code> and <code>HttpServer</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Only available on BSD and Linux
vertx.createNetServer().connectHandler({ so -&gt;
  // Handle application
}).listen(SocketAddress.domainSocketAddress("/var/tmp/myservice.sock"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or for http:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">vertx.createHttpServer().requestHandler({ req -&gt;
  // Handle application
}).listen(SocketAddress.domainSocketAddress("/var/tmp/myservice.sock"), { ar -&gt;
  if (ar.succeeded()) {
    // Bound to socket
  } else {
    ar.cause().printStackTrace()
  }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>As well as <code>NetClient</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var netClient = vertx.createNetClient()

// Only available on BSD and Linux
netClient.connect(SocketAddress.domainSocketAddress("/var/tmp/myservice.sock"), { ar -&gt;
  if (ar.succeeded()) {
    // Connected
  } else {
    ar.cause().printStackTrace()
  }
})</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
support for <code>HttpClient</code> can be expected in later versions of Vert.x
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_安全注意事项">安全注意事项</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 是一个工具包，而不是来强迫您以某种方式做事情的框架。这赋予了开发人员以更强大的能力，同时也伴随着更大的责任（译者注：能力越大，责任越大，小蜘蛛他叔叔说的）。</p>
</div>
<div class="paragraph">
<p>搭配其它工具包，使得编写不安全的应用程序成为可能，因此在开发时需谨慎，尤其是当您将其对公众发布的时候（如在互联网上发布）。</p>
</div>
<div class="sect2">
<h3 id="_web_应用">Web 应用</h3>
<div class="paragraph">
<p>如果编写Web 应用程序，强烈建议您直接使用Vert.x Web而非直接使用Vert.x Core以提供资源或处理文件上传。</p>
</div>
<div class="paragraph">
<p>Vert.x Web对请求中的路径进行了规范，以防止恶意客户端通过伪造URL来访问Web根目录以外的资源。</p>
</div>
<div class="paragraph">
<p>类似地，对于文件上传Vert.x Web提供上传到磁盘上已知位置的功能，且不依赖客户端提供的文件名，客户端提供的文件名可被恶意伪装成上传到硬盘上的不同位置。</p>
</div>
<div class="paragraph">
<p>Vert.x Core 本身不提供这样的检查，所以这取决于开发者您自身如何实现了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_集群模式_event_bus_流量">集群模式 Event Bus 流量</h3>
<div class="paragraph">
<p>当在网络上的不同Vert.x 节点之间创建集群模式下的 Event Bus 时，流量将通过未加密报文发送，因此若您有要发送的机密数据，而您的Vert.x 节点不在授信的网络上，请勿使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_标准安全最佳实践">标准安全最佳实践</h3>
<div class="paragraph">
<p>任何服务都可能存在潜在的漏洞，无论是使用Vert.x还是任何其他工具包，因此始终遵循安全最佳实践，特别是当您的服务面向公众。</p>
</div>
<div class="paragraph">
<p>例如，您应该始终在DMZ中运行它们，并使用具有受限权限的用户账户，以限制服务受到损害的程度。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vert_x_命令行接口api">Vert.x 命令行接口API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Core提供了一个用于解析传递给程序的命令行参数API。它还可以打印帮助信息——详细说明命令行工具可用的选项。
即使这些功能远离Vert.x Core主题，该API也可在 <code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code>  类中使用，可以在 fat-jar 和 <code>vertx</code> 命令行工具中使用。
另外，它支持多语言（可用于任何支持的语言），并可在Vert.x Shell中使用。</p>
</div>
<div class="paragraph">
<p>Vert.x CLI提供了一个描述命令行界面的模型，同时也是一个解析器，这个解析器可支持不同的语法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类似POSIX选项（即 <code>tar -zxvf foo.tar.gz</code> ）</p>
</li>
<li>
<p>类似GNU选项（即 <code>du --human-readable --max-depth=1</code> ）</p>
</li>
<li>
<p>类似Java属性（即 <code>java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo</code> ）</p>
</li>
<li>
<p>具有附加值的短选项（即 <code>gcc -O2 foo.c</code> ）</p>
</li>
<li>
<p>单个连字符的长选项（即 <code>ant -projecthelp</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用CLI API的三个步骤如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>定义命令行接口</p>
</li>
<li>
<p>解析用户命令行</p>
</li>
<li>
<p>查询/审问</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_定义阶段">定义阶段</h3>
<div class="paragraph">
<p>每个命令行界面必须定义将要使用的选项和参数集合。它也需要一个名字。CLI API使用 <code><a href="../../apidocs/io/vertx/core/cli/Option.html">Option</a></code> 和 <code><a href="../../apidocs/io/vertx/core/cli/Argument.html">Argument</a></code> 类来描述选项和参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("copy").setSummary("A command line interface to copy files.").addOption(Option(
  longName = "directory",
  shortName = "R",
  description = "enables directory support",
  flag = true)).addArgument(Argument(
  index = 0,
  description = "The source",
  argName = "source")).addArgument(Argument(
  index = 1,
  description = "The destination",
  argName = "target"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到，您可以使用 <code><a href="../../apidocs/io/vertx/core/cli/CLI.html#create-java.lang.String-">CLI.create</a></code> 创建一个新的 <code><a href="../../apidocs/io/vertx/core/cli/CLI.html">CLI</a></code> 。
传递的字符串是 <code>CLI</code> 的名称。创建后，您可以设置摘要和描述，摘要的目的是简短（一行），而描述可以包含更多细节。每个选项和参数也使用
<code><a href="../../apidocs/io/vertx/core/cli/CLI.html#addArgument-io.vertx.core.cli.Argument-">addArgument</a></code> 和
<code><a href="../../apidocs/io/vertx/core/cli/CLI.html#addOption-io.vertx.core.cli.Option-">addOption</a></code> 方法添加到 <code>CLI</code> 对象上。</p>
</div>
<div class="sect3">
<h4 id="_选项">选项</h4>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/cli/Option.html">Option</a></code> 是由用户命令行中存在的 <strong>键</strong> 标识的命令行参数。选项至少必须有一个长名或一个短名。
长名称通常使用 <code>--</code> 前缀，而短名称与单个 <code>-</code> 一起使用。选项可以获取用法中显示的描述（见下文）。选项可以接受0、1或几个值。
接受0值的选项是一个标志( <code>flag</code> )，必须使用
<code><a href="../../apidocs/io/vertx/core/cli/Option.html#setFlag-boolean-">setFlag</a></code> 声明。默认情况下，选项会接受一个值，但是您可以使用
<code><a href="../../apidocs/io/vertx/core/cli/Option.html#setMultiValued-boolean-">setMultiValued</a></code> 方法配置该选项接收多个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("some-name").setSummary("A command line interface illustrating the options valuation.").addOption(Option(
  longName = "flag",
  shortName = "f",
  flag = true,
  description = "a flag")).addOption(Option(
  longName = "single",
  shortName = "s",
  description = "a single-valued option")).addOption(Option(
  longName = "multiple",
  shortName = "m",
  multiValued = true,
  description = "a multi-valued option"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>选项可以标记为必填项，在用户命令行中未设置必填选项在解析阶段会引发异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("some-name").addOption(Option(
  longName = "mandatory",
  required = true,
  description = "a mandatory option"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>非必填选项可以具有默认值，如果用户没有在命令行中设置该选项，即将使用该值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("some-name").addOption(Option(
  longName = "optional",
  defaultValue = "hello",
  description = "an optional option with a default value"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code><a href="../../apidocs/io/vertx/core/cli/Option.html#setHidden-boolean-">setHidden</a></code> 方法隐藏选项，隐藏选项不在用法中列出，但仍可在用户命令行中使用（针对高级用户）。</p>
</div>
<div class="paragraph">
<p>如果选项值被限制为一个固定集合，您可以设置不同的可接受选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("some-name").addOption(Option(
  longName = "color",
  defaultValue = "green",
  choices = listOf("blue", "red", "green"),
  description = "a color"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以从JSON表单中实例化选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="_参数">参数</h4>
<div class="paragraph">
<p>和选项不同，参数不具有 <strong>键</strong> 并由其索引标识。例如，在 <code>java com.acme.Foo</code> 中， <code>com.acme.Foo</code> 是一个参数。</p>
</div>
<div class="paragraph">
<p>参数没有名称，使用基于 0 的索引进行标识。第一个参数的索引为 0：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("some-name").addArgument(Argument(
  index = 0,
  description = "the first argument",
  argName = "arg1")).addArgument(Argument(
  index = 1,
  description = "the second argument",
  argName = "arg2"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不设置参数索引，则基于声明顺序会自动计算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("some-name").addArgument(Argument(
  description = "the first argument",
  argName = "arg1")).addArgument(Argument(
  description = "the second argument",
  argName = "arg2"))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>argName</code> 是可选的，并在消息中使用。</p>
</div>
<div class="paragraph">
<p>相比选项， <code><a href="../../apidocs/io/vertx/core/cli/Argument.html">Argument</a></code> 可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code><a href="../../apidocs/io/vertx/core/cli/Argument.html#setHidden-boolean-">setHidden</a></code> 隐藏</p>
</li>
<li>
<p>使用 <code><a href="../../apidocs/io/vertx/core/cli/Argument.html#setRequired-boolean-">setRequired</a></code> 设置必填</p>
</li>
<li>
<p>使用 <code><a href="../../apidocs/io/vertx/core/cli/Argument.html#setDefaultValue-java.lang.String-">setDefaultValue</a></code> 设置默认值</p>
</li>
<li>
<p>使用 <code><a href="../../apidocs/io/vertx/core/cli/Argument.html#setMultiValued-boolean-">setMultiValued</a></code> 设置接收多个值——只有最后一个参数可以是多值的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>参数也可以从JSON表单中实例化。</p>
</div>
</div>
<div class="sect3">
<h4 id="_生成_usage_信息">生成 usage 信息</h4>
<div class="paragraph">
<p>一旦您的 <code><a href="../../apidocs/io/vertx/core/cli/CLI.html">CLI</a></code> 实例配置好后，您可以生成 <strong>usage</strong> 信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("copy").setSummary("A command line interface to copy files.").addOption(Option(
  longName = "directory",
  shortName = "R",
  description = "enables directory support",
  flag = true)).addArgument(Argument(
  index = 0,
  description = "The source",
  argName = "source")).addArgument(Argument(
  index = 0,
  description = "The destination",
  argName = "target"))

var builder = java.lang.StringBuilder()
cli.usage(builder)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上边生成的 <strong>usage</strong> 信息如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Usage: copy [-R] source target

A command line interface to copy files.

 -R,--directory   enables directory support</code></pre>
</div>
</div>
<div class="paragraph">
<p>若需要调整 usage 信息，请查阅 <code><a href="../../apidocs/io/vertx/core/cli/UsageMessageFormatter.html">UsageMessageFormatter</a></code> 类的文档。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解析阶段">解析阶段</h3>
<div class="paragraph">
<p>一旦您的 <code><a href="../../apidocs/io/vertx/core/cli/CLI.html">CLI</a></code> 实例配置好后，您可以解析用户命令行来解析每个选项和参数：实例配置好后，您可以解析用户命令行来解析每个选项和参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var commandLine = cli.parse(userCommandLineArguments)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../apidocs/io/vertx/core/cli/CLI.html#parse-java.util.List-">parse</a></code> 解析方法返回包含值的 <code><a href="../../apidocs/io/vertx/core/cli/CommandLine.html">CommandLine</a></code>
对象。默认情况下，它验证用户命令行，并检查每个必填选项和参数的设置以及每个选项接收的值的数量。
您可以通过传递 <code>false</code> 作为 <code><a href="../../apidocs/io/vertx/core/cli/CLI.html#parse-java.util.List-boolean-">parse</a></code> 的第二个参数来禁用验证。
如果要检查参数或选项，即使解析的命令行无效，这也是有用的。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code><a href="../../apidocs/io/vertx/core/cli/CommandLine.html#isValid--">isValid</a></code>
来检查 <code><a href="../../apidocs/io/vertx/core/cli/CommandLine.html">CommandLine</a></code> 是否有效。</p>
</div>
</div>
<div class="sect2">
<h3 id="_查询_审问阶段">查询/审问阶段</h3>
<div class="paragraph">
<p>解析后，您可以从 <code><a href="../../apidocs/io/vertx/core/cli/CLI.html#parse-java.util.List-">parse</a></code> 方法返回的
<code><a href="../../apidocs/io/vertx/core/cli/CommandLine.html">CommandLine</a></code> 对象中读取选项和参数的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var commandLine = cli.parse(userCommandLineArguments)
var opt = commandLine.getOptionValue&lt;Any&gt;("my-option")
var flag = commandLine.isFlagEnabled("my-flag")
var arg0 = commandLine.getArgumentValue&lt;Any&gt;(0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的一个选项可以被标记为“帮助”。如果用户命令行启用“帮助”选项，验证将不会失败，但是可以让您有机会检查用户是否需要帮助：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">var cli = CLI.create("test").addOption(Option(
  longName = "help",
  shortName = "h",
  flag = true,
  help = true)).addOption(Option(
  longName = "mandatory",
  required = true))

var line = cli.parse(java.util.Collections.singletonList("-h"))

// The parsing does not fail and let you do:
if (!line.isValid() &amp;&amp; line.isAskingForHelp()) {
  var builder = java.lang.StringBuilder()
  cli.usage(builder)
  stream.print(builder.toString())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_vert_x_launcher">The vert.x Launcher</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x <code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code> 在 fat-jar 中作为主类，由 <code>vertx</code> 命令行实用程序调用。它可执行一组命令，如 <code>run</code> 、 <code>bare</code> 和 <code>start</code> 等</p>
</div>
<div class="sect2">
<h3 id="Extending_the_vert_x_Launcher">扩展 Vert.x 启动器</h3>
<div class="paragraph">
<p>您可以通过实现自己的 <code><a href="../../apidocs/io/vertx/core/spi/launcher/Command.html">Command</a></code> 类来扩展命令集（仅限于Java）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">&amp;#64;Name("my-command")
&amp;#64;Summary("A simple hello command.")
public class MyCommand extends DefaultCommand {

 private String name;

 &amp;#64;Option(longName = "name", required = true)
 public void setName(String n) {
   this.name = n;
 }

 &amp;#64;Override
 public void run() throws CLIException {
   System.out.println("Hello " + name);
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y您还需要实现一个 <code><a href="../../apidocs/io/vertx/core/spi/launcher/CommandFactory.html">CommandFactory</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class HelloCommandFactory extends DefaultCommandFactory&lt;HelloCommand&gt; {
 public HelloCommandFactory() {
  super(HelloCommand.class);
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后创建 <code>src/main/resources/META-INF/services/io.vertx.core.spi.launcher.CommandFactory</code> 并且添加一行表示工厂类的完全限定名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>io.vertx.core.launcher.example.HelloCommandFactory</pre>
</div>
</div>
<div class="paragraph">
<p>构建包含命令的jar。确保包含了SPI文件（ <code>META-INF/services/io.vertx.core.spi.launcher.CommandFactory</code> ）。</p>
</div>
<div class="paragraph">
<p>然后，将包含该命令的jar放入fat-jar（或包含在其中）的类路径中，或放在Vert.x发行版的 <code>lib</code> 目录中，您将可以执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx hello vert.x
java -jar my-fat-jar.jar hello vert.x</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_在_fat_jar_中使用启动器">在 fat-jar 中使用启动器</h3>
<div class="paragraph">
<p>要在 fat-jar 中使用 <code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code>  类，只需要将 <strong>MANIFEST</strong> 的 <code>Main-Class</code> 设置为 <code>io.vertx.core.Launcher</code> 。
另外，将 <strong>MANIFEST</strong> 中 <code>Main-Verticle</code> 条目设置为您的Main Verticle的名称。</p>
</div>
<div class="paragraph">
<p>默认情况下，它会执行 <code>run</code> 命令。但是，您可以通过设置 <strong>MANIFEST</strong> 的 <code>Main-Command</code> 条目来配置默认命令。若在没有命令的情况下启动 fat-jar，则使用默认命令。</p>
</div>
</div>
<div class="sect2">
<h3 id="_启动器子类">启动器子类</h3>
<div class="paragraph">
<p>您还可以创建 <code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code> 的子类来启动您的应用程序。这个类被设计成易于扩展的。</p>
</div>
<div class="paragraph">
<p>一个 <code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code> 子类可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code><a href="../../apidocs/io/vertx/core/Launcher.html#beforeStartingVertx-io.vertx.core.VertxOptions-">beforeStartingVertx</a></code> 中自定义 Vert.x 配置</p>
</li>
<li>
<p>通过覆盖 <code><a href="../../apidocs/io/vertx/core/Launcher.html#afterStartingVertx-io.vertx.core.Vertx-">afterStartingVertx</a></code> 来读取由“run”或“bare”命令创建的Vert.x实例</p>
</li>
<li>
<p>使用
<code><a href="../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getMainVerticle--">getMainVerticle</a></code> 和
<code><a href="../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getDefaultCommand--">getDefaultCommand</a></code></p>
</li>
<li>
<p>使用 <code><a href="../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#register-java.lang.Class-">register</a></code> 方法配置默认的Verticle和命令
和 <code><a href="../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#unregister-java.lang.String-">unregister</a></code> 方法添加/删除命令</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_启动器和退出代码">启动器和退出代码</h3>
<div class="paragraph">
<p>当您使用 <code><a href="../../apidocs/io/vertx/core/Launcher.html">Launcher</a></code> 类作为主类时，它使用以下退出代码：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>若进程顺利结束，或抛出未捕获的错误：<code>0</code></p>
</li>
<li>
<p>用于通用错误： <code>1</code></p>
</li>
<li>
<p>若Vert.x无法初始化： <code>11</code></p>
</li>
<li>
<p>若生成的进程无法启动、发现或停止： <code>12</code> ，该错误代码一般由 <code>start</code> 和 <code>stop</code> 命令使用</p>
</li>
<li>
<p>若系统配置不符合系统要求（如找不到 <code>java</code> 命令）： <code>14</code></p>
</li>
<li>
<p>若主Verticle不能被部署： <code>15</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置_vert_x_缓存">配置 Vert.x 缓存</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当 Vert.x 需要从类路径中读取文件（嵌入在 fat-jar 中，类路径中jar文件或其他文件）时，它会把文件复制到缓存目录。背后原因很简单：从 jar 或从输入流读取文件是阻塞的。
所以为了避免每次都付出代价，Vert.x 会将文件复制到其缓存目录中，并随后读取该文件。这个行为也可配置。</p>
</div>
<div class="paragraph">
<p>首先，默认情况下，Vert.x 使用 <code>$CWD/.vertx</code> 作为缓存目录，它在此之间创建一个唯一的目录，以避免冲突。
可以使用 <code>vertx.cacheDirBase</code> 系统属性配置该位置。如，若当前工作目录不可写（例如在不可变容器上下文环境中），请使用以下命令启动应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>vertx run my.Verticle -Dvertx.cacheDirBase=/tmp/vertx-cache
# or
java -jar my-fat.jar vertx.cacheDirBase=/tmp/vertx-cache</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<strong>该目录必须是可写的。</strong>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当您编辑资源（如HTML、CSS或JavaScript）时，这种缓存机制可能令人讨厌，因为它仅仅提供文件的第一个版本（因此，若您想重新加载页面，则不会看到您的编辑改变）。
要避免此行为，请使用 <code>-Dvertx.disableFileCaching=true</code> 启动应用程序。使用此设置，Vert.x 仍然使用缓存，但始终使用原始源刷新存储在缓存中的版本。
因此，如果您编辑从类路径提供的文件并刷新浏览器，Vert.x 会从类路径读取它，将其复制到缓存目录并从中提供。不要在生产环境使用这个设置，它很有可能影响性能。</p>
</div>
<div class="paragraph">
<p>最后，您可以使用 <code>-Dvertx.disableFileCPResolving=true</code> 完全禁用高速缓存。这个设置不是没有后果的。Vert.x将无法从类路径中读取任何文件（仅从文件系统）。
使用此设置时要非常小心。</p>
</div>
</div>
</div>
        

        
          <div id="footer">
            <div id="footer-text">
              
                上次更新时间 2018-12-04 09:02:27 CST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//">主页</a></li>
          <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//download/">下载</a></li>
          <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//docs/">文档</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
          <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//blog/">博客</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//community/">帮助 &amp; 贡献者</a></li>
          <li><a href="https://okou19900722.gitee.io/cn.vertx.tk//materials/">学习资料</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
          <li><a href="//shang.qq.com/wpa/qunwpa?idkey=587f58cacb9557e3291b46098e0fe09427b98a1c0f866da23c04c2762bc7e2ad">QQ群</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual-licensed under the <a href="http://www.eclipse.org/legal/epl-v20.html">Eclipse Public License 2.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="https://okou19900722.gitee.io/cn.vertx.tk//assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="https://okou19900722.gitee.io/cn.vertx.tk//assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="https://okou19900722.gitee.io/cn.vertx.tk//assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://okou19900722.gitee.io/cn.vertx.tk//javascripts/bootstrap.min.js"></script>
<script src="https://okou19900722.gitee.io/cn.vertx.tk//javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="https://okou19900722.gitee.io/cn.vertx.tk//javascripts/sidebar.js"></script>


<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});
</script>
</body>
</html>

