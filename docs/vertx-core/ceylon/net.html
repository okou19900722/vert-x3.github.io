<!DOCTYPE html>
<html lang="en">
<head>
  <title>编写 TCP 服务端和客户端 - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="https://vertx.tk/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://vertx.tk/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="https://vertx.tk/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="https://vertx.tk/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="https://vertx.tk/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
  <style>
    .page-link-to-github {
      position: relative;
      z-index: 1;
      display: inline-block;
      border: 1px solid #782B90;
      border-radius: 5px;
      color: #782B90;
      font-size: 12px;
      padding: 4px 10px;
      text-decoration: none;
      background-color: #ffffff;
    }
    .page-link-to-github:hover {
      color: #ffffff;
      border-color: #ffffff;
      background-color: #782B90;
    }

    .page-link-to-github .github-icon {
      position: absolute;
      display: inline-block;
      width: 20px;
      height: 20px;
      /*background-position: -50px 0*/
      background: url('https://vertx.tk/assets/github.png') no-repeat 0 0;
    }

    @media (-webkit-min-device-pixel-ratio: 2),(min-resolution:192dpi) {
      .page-link-to-github .github-icon {
        background-image:url('https://vertx.tk/assets/github@2x.png');
        background-size: 150px auto
      }
    }

    .page-link-to-github:hover .github-icon {
      /*background-position: 0 0*/
      background-position: -100px 0
    }
    .text {
      text-decoration: underline
    }
    .page-link-to-github .text {
      padding-left: 27px
    }
    .text {
      padding-right: 8px
    }
    .page-link-to-github {
      float: right;
      top: 4px
    }

  </style>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://vertx.tk/" class="navbar-brand"><img alt="Brand" src="https://vertx.tk/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="https://vertx.tk/download/">下载</a></li>
        <li><a href="https://vertx.tk/docs/">文档</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
        <li><a href="https://vertx.tk/community/">社区</a></li>
        <li><a href="https://vertx.tk/materials/">资料</a></li>
        <li><a href="https://vertx.tk/blog/">博客</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>编写 TCP 服务端和客户端</h1>
          
        </div>
      </div>
    </div>
  </div>




<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_tcp_服务端">创建 TCP 服务端</a></li>
<li><a href="#_配置_tcp_服务端">配置 TCP 服务端</a></li>
<li><a href="#_启动服务端监听">启动服务端监听</a></li>
<li><a href="#_监听随机端口">监听随机端口</a></li>
<li><a href="#_接收传入连接的通知">接收传入连接的通知</a></li>
<li><a href="#_从socket读取数据">从Socket读取数据</a></li>
<li><a href="#_向socket中写入数据">向Socket中写入数据</a></li>
<li><a href="#_关闭处理器">关闭处理器</a></li>
<li><a href="#_处理异常">处理异常</a></li>
<li><a href="#_event_bus_写处理器">Event Bus 写处理器</a></li>
<li><a href="#_本地和远程地址">本地和远程地址</a></li>
<li><a href="#_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</a></li>
<li><a href="#_流式的socket">流式的Socket</a></li>
<li><a href="#_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</a></li>
<li><a href="#_关闭_tcp_服务端">关闭 TCP 服务端</a></li>
<li><a href="#_verticle中的自动清理">Verticle中的自动清理</a></li>
<li><a href="#_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</a></li>
<li><a href="#_创建_tcp_客户端">创建 TCP 客户端</a></li>
<li><a href="#_配置_tcp_客户端">配置 TCP 客户端</a></li>
<li><a href="#_创建连接">创建连接</a></li>
<li><a href="#_配置连接重试">配置连接重试</a></li>
<li><a href="#logging_network_activity">记录网络活动</a></li>
<li><a href="#ssl">配置服务端和客户端以使用SSL/TLS</a></li>
<li><a href="#_客户端连接使用代理">客户端连接使用代理</a></li>
</ul>
</li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</a>
<ul class="sectlevel2">
<li><a href="#_创建_tcp_服务端">创建 TCP 服务端</a></li>
<li><a href="#_配置_tcp_服务端">配置 TCP 服务端</a></li>
<li><a href="#_启动服务端监听">启动服务端监听</a></li>
<li><a href="#_监听随机端口">监听随机端口</a></li>
<li><a href="#_接收传入连接的通知">接收传入连接的通知</a></li>
<li><a href="#_从socket读取数据">从Socket读取数据</a></li>
<li><a href="#_向socket中写入数据">向Socket中写入数据</a></li>
<li><a href="#_关闭处理器">关闭处理器</a></li>
<li><a href="#_处理异常">处理异常</a></li>
<li><a href="#_event_bus_写处理器">Event Bus 写处理器</a></li>
<li><a href="#_本地和远程地址">本地和远程地址</a></li>
<li><a href="#_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</a></li>
<li><a href="#_流式的socket">流式的Socket</a></li>
<li><a href="#_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</a></li>
<li><a href="#_关闭_tcp_服务端">关闭 TCP 服务端</a></li>
<li><a href="#_verticle中的自动清理">Verticle中的自动清理</a></li>
<li><a href="#_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</a></li>
<li><a href="#_创建_tcp_客户端">创建 TCP 客户端</a></li>
<li><a href="#_配置_tcp_客户端">配置 TCP 客户端</a></li>
<li><a href="#_创建连接">创建连接</a></li>
<li><a href="#_配置连接重试">配置连接重试</a></li>
<li><a href="#logging_network_activity">记录网络活动</a></li>
<li><a href="#ssl">配置服务端和客户端以使用SSL/TLS</a></li>
<li><a href="#_客户端连接使用代理">客户端连接使用代理</a></li>
</ul>
</li>
</ul>
        </div>

  <a href="https://github.com/okou19900722/vertx-web-site-translation-chinese/tree/master/vertx-translation-stack/vertx-core-translation"
     class="page-link-to-github"
     target="_blank"
     title="Edit this page on GitHub">
    <i class="github-icon"></i>
    <span class="text">编辑本页</span>
  </a>

        <div class="sect1">
<h2 id="_编写_tcp_服务端和客户端">编写 TCP 服务端和客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x允许您很容易编写非阻塞的TCP客户端和服务器。</p>
</div>
<div class="sect2">
<h3 id="_创建_tcp_服务端">创建 TCP 服务端</h3>
<div class="paragraph">
<p>最简单地使用所有默认配置项创建 TCP 服务端的方式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value server = vertx.createNetServer();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_tcp_服务端">配置 TCP 服务端</h3>
<div class="paragraph">
<p>若您不想使用默认配置，可以在创建时通过传入一个 <code><a href="../../ceylondoc/vertx-core//net/NetServerOptions.type.html">NetServerOptions</a></code>
实例来配置服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetServerOptions {
  port = 4321;
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_启动服务端监听">启动服务端监听</h3>
<div class="paragraph">
<p>要告诉服务端监听传入的请求，您可以使用其中一个 <code><a href="../../ceylondoc/vertx-core//net/NetServer.type.html#listen()">listen</a></code>
方法。</p>
</div>
<div class="paragraph">
<p>让服务器监听配置项指定的主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value server = vertx.createNetServer();
server.listen();</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在调用 <code>listen</code> 方法时指定主机和端口号，忽略配置项中的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value server = vertx.createNetServer();
server.listen(1234, "localhost");</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认主机名是 <code>0.0.0.0</code> ，它表示：监听所有可用地址。默认端口号是 <code>0</code> ，这也是一个特殊值，它告诉服务器随机选择并监听一个本地没有被占用的端口。</p>
</div>
<div class="paragraph">
<p>实际的绑定也是异步的，因此服务器在调用了 <code>listen</code> 方法的一段时间之后才会实际开始监听。</p>
</div>
<div class="paragraph">
<p>若您希望在服务器实际监听时收到通知，您可以在调用 <code>listen</code> 方法时提供一个处理器。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value server = vertx.createNetServer();
server.listen(1234, "localhost", (NetServer|Throwable res) {
  if (is NetServer res) {
    print("Server is now listening!");
  } else {
    print("Failed to bind!");
  };
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_监听随机端口">监听随机端口</h3>
<div class="paragraph">
<p>若设置监听端口为 <code>0</code> ，服务器将随机寻找一个没有使用的端口来监听。</p>
</div>
<div class="paragraph">
<p>可以调用 <code><a href="../../ceylondoc/vertx-core//net/NetServer.type.html#actualPort()">actualPort</a></code> 方法来获得服务器实际监听的端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value server = vertx.createNetServer();
server.listen(0, "localhost", (NetServer|Throwable res) {
  if (is NetServer res) {
    print("Server is now listening on actual port: ``server.actualPort()``");
  } else {
    print("Failed to bind!");
  };
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_接收传入连接的通知">接收传入连接的通知</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">若您想要在连接创建完时收到通知，则需要设置一个 `link:../../ceylondoc/vertx-core//net/NetServer.type.html#connectHandler((@io.vertx.codegen.annotations.Nullable </dt>
<dd>
<p>io.vertx.core.Handler))[connectHandler]` :</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value server = vertx.createNetServer();
server.connectHandler((NetSocket socket) {
  // Handle the connection in here
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当连接成功时，您可以在回调函数中处理得到的 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html">NetSocket</a></code> 实例。</p>
</div>
<div class="paragraph">
<p>这是一个代表了实际连接的套接字接口，它允许您读取和写入数据、以及执行各种其他操作，如关闭 Socket。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从socket读取数据">从Socket读取数据</h3>
<div class="paragraph">
<p>您可以在Socket上调用 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#handler(io.vertx.core.Handler)">handler</a></code> 方法来设置用于读取数据的处理器。</p>
</div>
<div class="paragraph">
<p>每次 Socket 接收到数据时，会以 <code><a href="../../ceylondoc/vertx-core//buffer/Buffer.type.html">Buffer</a></code> 对象为参数调用处理器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value server = vertx.createNetServer();
server.connectHandler((NetSocket socket) {
  socket.handler((Buffer buffer) {
    print("I received some bytes: ``buffer.length()``");
  });
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_向socket中写入数据">向Socket中写入数据</h3>
<div class="paragraph">
<p>您可使用 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#write(io.vertx.core.buffer.Buffer)">write</a></code> 方法写入数据到Socket：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.buffer { buffer_ = buffer }

...


// Write a buffer
value buffer = buffer_.buffer().appendFloat(12.34).appendInt(123);
socket.write(buffer);

// Write a string in UTF-8 encoding
socket.write("some data");

// Write a string using the specified encoding
socket.write("some data", "UTF-16");</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入操作是异步的，可能调用 <code>write</code> 方法返回过后一段时间才会发生。</p>
</div>
</div>
<div class="sect2">
<h3 id="_关闭处理器">关闭处理器</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">若您想要在 Socket 关闭时收到通知，可以设置一个 `link:../../ceylondoc/vertx-core//net/NetSocket.type.html#closeHandler((@io.vertx.codegen.annotations.Nullable </dt>
<dd>
<p>io.vertx.core.Handler))[closeHandler]` :</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">socket.closeHandler(() {
  print("The socket has been closed");
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理异常">处理异常</h3>
<div class="paragraph">
<p>您可以设置一个 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code> 用以在发生任何异常的时候接收异常信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_写处理器">Event Bus 写处理器</h3>
<div class="paragraph">
<p>每个 Socket 会自动在Event Bus中注册一个处理器，当这个处理器中收到任意 <code>Buffer</code> 时，它会将数据写入到 Socket。</p>
</div>
<div class="paragraph">
<p>这意味着您可以通过向这个地址发送 <code>Buffer</code> 的方式，从不同的 Verticle 甚至是不同的 Vert.x 实例中向指定的 Socket 发送数据。</p>
</div>
<div class="paragraph">
<p>处理器的地址由 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#writeHandlerID()">writeHandlerID</a></code> 方法提供。</p>
</div>
</div>
<div class="sect2">
<h3 id="_本地和远程地址">本地和远程地址</h3>
<div class="paragraph">
<p>您可以通过 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#localAddress()">localAddress</a></code> 方法获取 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html">NetSocket</a></code> 的本地地址，</p>
</div>
<div class="paragraph">
<p>通过 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#remoteAddress()">remoteAddress</a></code> 方法获取 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html">NetSocket</a></code> 的远程地址（即连接的另一端的地址）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_发送文件或_classpath_中的资源">发送文件或 Classpath 中的资源</h3>
<div class="paragraph">
<p>您可以直接通过 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#sendFile(java.lang.String)">sendFile</a></code> 方法将文件和 classpath 中的资源写入Socket。
这种做法是非常高效的，它可以被操作系统内核直接处理。</p>
</div>
<div class="paragraph">
<p>请阅读 <a href="#classpath">从 Classpath 访问文件</a> 章节了解类路径的限制或禁用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">socket.sendFile("myfile.dat");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_流式的socket">流式的Socket</h3>
<div class="paragraph">
<p><code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html">NetSocket</a></code> 接口继承了 <code><a href="../../ceylondoc/vertx-core//streams/ReadStream.type.html">ReadStream</a></code> 和
<code><a href="../../ceylondoc/vertx-core//streams/WriteStream.type.html">WriteStream</a></code> 接口，因此您可以将它套用（pump）到其他的读写流上。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅 <a href="#streams">流和管道</a>  章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_升级到_ssl_tls_连接">升级到 SSL/TLS 连接</h3>
<div class="paragraph">
<p>一个非SSL/TLS连接可以通过 <code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html#upgradeToSsl(io.vertx.core.Handler)">upgradeToSsl</a></code> 方法升级到SSL/TLS连接。</p>
</div>
<div class="paragraph">
<p>必须为服务器或客户端配置SSL/TLS才能正常工作。请参阅 <a href="#ssl">SSL/TLS</a> 章节来获取详细信息。
for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_关闭_tcp_服务端">关闭 TCP 服务端</h3>
<div class="paragraph">
<p>您可以调用 <code><a href="../../ceylondoc/vertx-core//net/NetServer.type.html#close()">close</a></code> 方法关闭服务端。关闭操作将关闭所有打开的连接并释放所有服务端资源。</p>
</div>
<div class="paragraph">
<p>关闭操作也是异步的，可能直到方法调用返回过后一段时间才会实际关闭。若您想在实际关闭完成时收到通知，那么您可以传递一个处理器。</p>
</div>
<div class="paragraph">
<p>当关闭操作完成后，绑定的处理器将被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">server.close((Throwable? res) {
  if (!exists res) {
    print("Server is now closed");
  } else {
    print("close failed");
  };
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verticle中的自动清理">Verticle中的自动清理</h3>
<div class="paragraph">
<p>若您在 Verticle 内创建了 TCP 服务端和客户端，它们将会在Verticle 撤销时自动被关闭。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩展_共享_tcp_服务端">扩展 - 共享 TCP 服务端</h3>
<div class="paragraph">
<p>任意一个 TCP 服务端中的处理器总是在相同的 Event Loop 线程上执行。</p>
</div>
<div class="paragraph">
<p>这意味着如果您在多核的服务器上运行，并且只部署了一个实例，那么您的服务器上最多只能使用一个核。</p>
</div>
<div class="paragraph">
<p>为了利用更多的服务器核，您将需要部署更多的服务器实例。</p>
</div>
<div class="paragraph">
<p>您可以在代码中以编程方式实例化更多（Server的）实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">// Create a few instances so we can utilise cores

for (i in 0:10) {
  value server = vertx.createNetServer();
  server.connectHandler((NetSocket socket) {
    socket.handler((Buffer buffer) {
      // Just echo back the data
      socket.write(buffer);
    });
  });
  server.listen(1234, "localhost");
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用的是 Verticle，您可以通过在命令行上使用 <code>-instances</code> 选项来简单部署更多的服务器实例：</p>
</div>
<div class="paragraph">
<p>vertx run com.mycompany.MyVerticle -instances 10</p>
</div>
<div class="paragraph">
<p>或者使用编程方式部署您的 Verticle 时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = DeploymentOptions {
  instances = 10;
};
vertx.deployVerticle("com.mycompany.MyVerticle", options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦您这样做，您将发现echo服务器在功能上与之前相同，但是服务器上的所有核都可以被利用，并且可以处理更多的工作。</p>
</div>
<div class="paragraph">
<p>在这一点上，您可能会问自己：<strong>如何让多台服务器在同一主机和端口上侦听？尝试部署一个以上的实例时真的不会遇到端口冲突吗？</strong></p>
</div>
<div class="paragraph">
<p><strong>Vert.x在这里有一点魔法。</strong></p>
</div>
<div class="paragraph">
<p>当您在与现有服务器相同的主机和端口上部署另一个服务器实例时，实际上它并不会尝试创建在同一主机/端口上侦听的新服务器实例。</p>
</div>
<div class="paragraph">
<p>相反，它内部仅仅维护一个服务器实例。当传入新的连接时，它以轮询的方式将其分发给任意一个连接处理器处理。</p>
</div>
<div class="paragraph">
<p>因此，Vert.x TCP 服务端可以水平扩展到多个核，并且每个实例保持单线程环境不变。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建_tcp_客户端">创建 TCP 客户端</h3>
<div class="paragraph">
<p>使用所有默认选项创建 TCP 客户端的最简单方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value client = vertx.createNetClient();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_tcp_客户端">配置 TCP 客户端</h3>
<div class="paragraph">
<p>如果您不想使用默认值，则可以在创建实例时传入 <code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html">NetClientOptions</a></code>
给客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  connectTimeout = 10000;
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建连接">创建连接</h3>
<div class="paragraph">
<p>您可以使用 <code><a href="../../ceylondoc/vertx-core//net/NetClient.type.html#connect(int,%20java.lang.String,%20io.vertx.core.Handler)">connect</a></code> ,
方法创建到服务器的连接。请指定服务器的端口和主机，以及用于处理
<code><a href="../../ceylondoc/vertx-core//net/NetSocket.type.html">NetSocket</a></code> 的处理器。当连接成功或失败时处理器会被调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  connectTimeout = 10000;
};
value client = vertx.createNetClient(options);
client.connect(4321, "localhost", (NetSocket|Throwable res) {
  if (is NetSocket res) {
    print("Connected!");
    value socket = res;
  } else {
    print("Failed to connect: ``res.getMessage()``");
  };
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置连接重试">配置连接重试</h3>
<div class="paragraph">
<p>可以将客户端配置为在无法连接的情况下自动重试。
这是通过 <code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html#setReconnectInterval(long)">reconnectInterval</a></code> 和
<code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html#setReconnectAttempts(int)">reconnectAttempts</a></code> 方法配置的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong>注意：目前如果连接失效，Vert.x将不尝试重新连接。重新连接尝试和时间间隔仅适用于创建初始连接。</strong>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  reconnectAttempts = 10;
  reconnectInterval = 500;
};

value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，多个连接尝试是被禁用的。</p>
</div>
</div>
<div class="sect2">
<h3 id="logging_network_activity">记录网络活动</h3>
<div class="paragraph">
<p>网络活动可以被记录下来，用于调试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetServerOptions {
  logActivity = true;
};

value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  logActivity = true;
};

value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Netty 使用 <code>DEBUG</code> 级别和 <code>io.netty.handler.logging.LoggingHandler</code> 名称来记录网络活动。使用网络活动记录时，需要注意以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日志的记录是由Netty而不是Vert.x的日志来执行</p>
</li>
<li>
<p>这个功能不能用于生产环境</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您应该阅读 <a href="#netty-logging">Netty 日志记录</a> 章节来了解详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="ssl">配置服务端和客户端以使用SSL/TLS</h3>
<div class="paragraph">
<p>TCP 客户端和服务端可以通过配置来使用 <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">TLS（传输层安全性协议）</a>
。早期版本的TLS被称为SSL。</p>
</div>
<div class="paragraph">
<p>无论是否使用SSL/TLS，服务器和客户端的API都是相同的。通过创建客户端/服务器时使用的 <code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html">NetClientOptions</a></code> 或 <code><a href="../../ceylondoc/vertx-core//net/NetServerOptions.type.html">NetServerOptions</a></code> 来启用TLS/SSL。</p>
</div>
<div class="sect3">
<h4 id="_在服务端启用ssl_tls">在服务端启用SSL/TLS</h4>
<div class="paragraph">
<p>您需要设置 <code><a href="../../ceylondoc/vertx-core//net/NetServerOptions.type.html#setSsl(boolean)">ssl</a></code> 配置项来启用 SSL/TLS。</p>
</div>
<div class="paragraph">
<p>默认是禁用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_指定服务端的密钥_证书">指定服务端的密钥/证书</h4>
<div class="paragraph">
<p>SSL/TLS 服务端通常向客户端提供证书，以便验证服务端的身份。</p>
</div>
<div class="paragraph">
<p>可以通过以下几种方式为服务端配置证书/密钥：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含证书和私钥的Java密钥库位置。</p>
</div>
<div class="paragraph">
<p>可以使用 JDK 附带的 <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
实用程序来管理Java密钥存储。</p>
</div>
<div class="paragraph">
<p>还应提供密钥存储的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetServerOptions {
  ssl = true;
  keyStoreOptions = JksOptions {
    path = "/path/to/your/server-keystore.jks";
    password = "password-of-your-keystore";
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以自己读取密钥库到一个 <code>Buffer</code> ，并将它直接提供给 <code>JksOptions</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.jks");
value jksOptions = JksOptions {
  value = myKeyStoreAsABuffer;
  password = "password-of-your-keystore";
};
value options = NetServerOptions {
  ssl = true;
  keyStoreOptions = jksOptions;
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetServerOptions {
  ssl = true;
  pfxKeyCertOptions = PfxOptions {
    path = "/path/to/your/server-keystore.pfx";
    password = "password-of-your-keystore";
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.pfx");
value pfxOptions = PfxOptions {
  value = myKeyStoreAsABuffer;
  password = "password-of-your-keystore";
};
value options = NetServerOptions {
  ssl = true;
  pfxKeyCertOptions = pfxOptions;
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外一种分别提供服务器私钥和证书的方法是使用 <code>.pem</code> 文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetServerOptions {
  ssl = true;
  pemKeyCertOptions = PemKeyCertOptions {
    keyPath = "/path/to/your/server-key.pem";
    certPath = "/path/to/your/server-cert.pem";
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-key.pem");
value myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-cert.pem");
value pemOptions = PemKeyCertOptions {
  keyValue = myKeyAsABuffer;
  certValue = myCertAsABuffer;
};
value options = NetServerOptions {
  ssl = true;
  pemKeyCertOptions = pemOptions;
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS8, PKCS1 and X.509 certificates wrapped in a PEM block formats are supported.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
请记住pem的配置和私钥是不加密的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_指定服务器信任">指定服务器信任</h4>
<div class="paragraph">
<p>SSL/TLS 服务端可以使用证书颁发机构来验证客户端的身份。</p>
</div>
<div class="paragraph">
<p>证书颁发机构可通过多种方式为服务端配置。</p>
</div>
<div class="paragraph">
<p>可使用JDK随附的 <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
实用程序来管理Java 受信存储。</p>
</div>
<div class="paragraph">
<p>还应提供受信存储的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.http { required }

...

value options = NetServerOptions {
  ssl = true;
  clientAuth = "REQUIRED";
  trustStoreOptions = JksOptions {
    path = "/path/to/your/truststore.jks";
    password = "password-of-your-truststore";
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您可以自己读取受信存储到 <code>Buffer</code> ，并将它直接提供：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.http { required }

...

value myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks");
value options = NetServerOptions {
  ssl = true;
  clientAuth = "REQUIRED";
  trustStoreOptions = JksOptions {
    value = myTrustStoreAsABuffer;
    password = "password-of-your-truststore";
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.http { required }

...

value options = NetServerOptions {
  ssl = true;
  clientAuth = "REQUIRED";
  pfxTrustOptions = PfxOptions {
    path = "/path/to/your/truststore.pfx";
    password = "password-of-your-truststore";
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.http { required }

...

value myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx");
value options = NetServerOptions {
  ssl = true;
  clientAuth = "REQUIRED";
  pfxTrustOptions = PfxOptions {
    value = myTrustStoreAsABuffer;
    password = "password-of-your-truststore";
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种提供服务器证书颁发机构的方法是使用一个 <code>.pem</code> 文件列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.http { required }

...

value options = NetServerOptions {
  ssl = true;
  clientAuth = "REQUIRED";
  pemTrustOptions = PemTrustOptions {
    certPaths = {"/path/to/your/server-ca.pem" };
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.http { required }

...

value myCaAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-ca.pfx");
value options = NetServerOptions {
  ssl = true;
  clientAuth = "REQUIRED";
  pemTrustOptions = PemTrustOptions {
    certValues = {myCaAsABuffer };
  };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_客户端启用ssl_tls">客户端启用SSL/TLS</h4>
<div class="paragraph">
<p>客户端也可以轻松地配置为SSL。使用SSL和使用标准套接字具有完全相同的API。</p>
</div>
<div class="paragraph">
<p>若要启用 <code>NetClient</code> 上的SSL，可调用函数 <code>setSSL(true)</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_客户端受信配置">客户端受信配置</h4>
<div class="paragraph">
<p>若客户端将 <code><a href="../../ceylondoc/vertx-core//net/ClientOptionsBase.type.html#setTrustAll(boolean)">trustALl</a></code> 设置为 <code>true</code> ，则客户端将信任所有服务端证书。
连接仍然会被加密，但这种模式很容易受到中间人攻击。即您无法确定您正连接到谁，请谨慎使用。默认值为 <code>false</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  trustAll = true;
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>若客户端没有设置 <code><a href="../../ceylondoc/vertx-core//net/ClientOptionsBase.type.html#setTrustAll(boolean)">trustAll</a></code> ，则必须配置客户端受信存储，并且受信客户端应该包含服务器的证书。</p>
</div>
<div class="paragraph">
<p>默认情况下，客户端禁用主机验证。要启用主机验证，请在客户端上设置使用的算法（目前仅支持HTTPS和LDAPS）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  hostnameVerificationAlgorithm = "HTTPS";
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>和服务器配置相同，也可通过以下几种方式配置受信客户端：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含证书颁发机构的Java受信库的位置。</p>
</div>
<div class="paragraph">
<p>它只是一个标准的Java密钥存储，与服务器端的密钥存储相同。通过在
<code><a href="../../ceylondoc/vertx-core//net/JksOptions.type.html">jks options</a></code> 上使用 <code><a href="../../ceylondoc/vertx-core//net/JksOptions.type.html#setPath(java.lang.String)">path</a></code>
设置客户端受信存储位置。如果服务器在连接期间提供不在客户端受信存储中的证书，则尝试连接将不会成功。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  trustStoreOptions = JksOptions {
    path = "/path/to/your/truststore.jks";
    password = "password-of-your-truststore";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它也支持 <code>Buffer</code> 的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks");
value options = NetClientOptions {
  ssl = true;
  trustStoreOptions = JksOptions {
    value = myTrustStoreAsABuffer;
    password = "password-of-your-truststore";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  pfxTrustOptions = PfxOptions {
    path = "/path/to/your/truststore.pfx";
    password = "password-of-your-truststore";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx");
value options = NetClientOptions {
  ssl = true;
  pfxTrustOptions = PfxOptions {
    value = myTrustStoreAsABuffer;
    password = "password-of-your-truststore";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种提供服务器证书颁发机构的方法是使用一个 <code>.pem</code> 文件列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  pemTrustOptions = PemTrustOptions {
    certPaths = {"/path/to/your/ca-cert.pem" };
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/ca-cert.pem");
value options = NetClientOptions {
  ssl = true;
  pemTrustOptions = PemTrustOptions {
    certValues = {myTrustStoreAsABuffer };
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_指定客户端的密钥_证书">指定客户端的密钥/证书</h4>
<div class="paragraph">
<p>如果服务器需要客户端认证，那么当连接时，客户端必须向服务器提供自己的证书。可通过以下几种方式配置客户端：</p>
</div>
<div class="paragraph">
<p>第一种方法是指定包含密钥和证书的Java 密钥库的位置，它只是一个常规的Java 密钥存储。使用 <code><a href="../../ceylondoc/vertx-core//net/JksOptions.type.html">jks options</a></code> 上的功能路径设置客户端密钥库位置 <code><a href="../../ceylondoc/vertx-core//net/JksOptions.type.html#setPath(java.lang.String)">path</a></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  keyStoreOptions = JksOptions {
    path = "/path/to/your/client-keystore.jks";
    password = "password-of-your-keystore";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.jks");
value jksOptions = JksOptions {
  value = myKeyStoreAsABuffer;
  password = "password-of-your-keystore";
};
value options = NetClientOptions {
  ssl = true;
  keyStoreOptions = jksOptions;
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>PKCS＃12格式的密钥/证书 (<a href="http://en.wikipedia.org/wiki/PKCS_12" class="bare">http://en.wikipedia.org/wiki/PKCS_12</a>) ，通常为 <code>.pfx</code> 或 <code>.p12</code> 扩展名）也可以用与JKS密钥存储相似的方式加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  pfxKeyCertOptions = PfxOptions {
    path = "/path/to/your/client-keystore.pfx";
    password = "password-of-your-keystore";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.pfx");
value pfxOptions = PfxOptions {
  value = myKeyStoreAsABuffer;
  password = "password-of-your-keystore";
};
value options = NetClientOptions {
  ssl = true;
  pfxKeyCertOptions = pfxOptions;
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种单独提供服务器私钥和证书的方法是使用 <code>.pem</code> 文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  pemKeyCertOptions = PemKeyCertOptions {
    keyPath = "/path/to/your/client-key.pem";
    certPath = "/path/to/your/client-cert.pem";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-key.pem");
value myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-cert.pem");
value pemOptions = PemKeyCertOptions {
  keyValue = myKeyAsABuffer;
  certValue = myCertAsABuffer;
};
value options = NetClientOptions {
  ssl = true;
  pemKeyCertOptions = pemOptions;
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住 <code>pem</code> 的配置和私钥是不加密的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_用于测试和开发目的的自签名证书">用于测试和开发目的的自签名证书</h4>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
不要在生产设置中使用，这里生成的密钥非常不安全。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在运行单元/集成测试或是运行开发版的应用程序时都经常需要自签名证书。</p>
</div>
<div class="paragraph">
<p><code><a href="../../ceylondoc/vertx-core//net/SelfSignedCertificate.type.html">SelfSignedCertificate</a></code> 可用于提供自签名PEM证书，并可以提供
give <code>KeyCertOptions</code> 和 <code>TrustOptions</code> configurations 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.net { selfSignedCertificate }

...

value certificate = selfSignedCertificate.create();

value serverOptions = NetServerOptions {
  ssl = true;
  keyCertOptions = certificate.keyCertOptions();
  trustOptions = certificate.trustOptions();
};

value server = vertx.createNetServer(serverOptions).connectHandler((NetSocket socket) =&gt; socket.write("Hello!").end()).listen(1234, "localhost");

value clientOptions = NetClientOptions {
  ssl = true;
  keyCertOptions = certificate.keyCertOptions();
  trustOptions = certificate.trustOptions();
};

value client = vertx.createNetClient(clientOptions);
client.connect(1234, "localhost", (NetSocket|Throwable ar) {
  if (is NetSocket ar) {
    ar.handler((Buffer buffer) =&gt; print(buffer));
  } else {
    print("Woops: ``ar.getMessage()``");
  };
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户端也可配置为信任所有证书：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value clientOptions = NetClientOptions {
  ssl = true;
  trustAll = true;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>自签名证书也适用于其他基于TCP的协议，如HTTPS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.net { selfSignedCertificate }

...

value certificate = selfSignedCertificate.create();

vertx.createHttpServer(HttpServerOptions {
  ssl = true;
  keyCertOptions = certificate.keyCertOptions();
  trustOptions = certificate.trustOptions();
}).requestHandler((HttpServerRequest req) =&gt; req.response().end("Hello!")).listen(8080);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_待撤销证书颁发机构">待撤销证书颁发机构</h4>
<div class="paragraph">
<p>可以通过配置证书吊销列表（CRL）来吊销不再被信任的证书机构。 <code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html#addCrlPath(java.lang.String)">crlPath</a></code> 配置了使用的CRL：
the crl list to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetClientOptions {
  ssl = true;
  trustStoreOptions = trustOptions;
  crlPaths = {"/path/to/your/crl.pem" };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也支持通过 <code>Buffer</code> 来配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value myCrlAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/crl.pem");
value options = NetClientOptions {
  ssl = true;
  trustStoreOptions = trustOptions;
  crlValues = {myCrlAsABuffer };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置密码套件">配置密码套件</h4>
<div class="paragraph">
<p>默认情况下，TLS配置将使用运行Vert.x的JVM 密码套件，该密码套件可以配置一套启用的密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value options = NetServerOptions {
  ssl = true;
  keyStoreOptions = keyStoreOptions;
  enabledCipherSuites = {"ECDHE-RSA-AES128-GCM-SHA256" , "ECDHE-ECDSA-AES128-GCM-SHA256" , "ECDHE-RSA-AES256-GCM-SHA384" , "CDHE-ECDSA-AES256-GCM-SHA384" };
};
value server = vertx.createNetServer(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>密码套件可在 <code><a href="../../ceylondoc/vertx-core//net/NetServerOptions.type.html">NetServerOptions</a></code> 或 <code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html">NetClientOptions</a></code> 配置项中指定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置tls协议版本">配置TLS协议版本</h4>
<div class="paragraph">
<p>默认情况下，TLS配置将使用以下协议版本：SSLv2Hello、TLSv1、TLSv1.1 和 TLSv1.2。 协议版本可以通过显式添加启用协议进行配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">Code not translatable : io.vertx.codetrans.expression.DataObjectLiteralModel has not implemented: Method MethodSignature[name=removeEnabledSecureTransportProtocol,parameters=[java.lang.String],varargs=false]</code></pre>
</div>
</div>
<div class="paragraph">
<p>协议版本可在 <code><a href="../../ceylondoc/vertx-core//net/NetServerOptions.type.html">NetServerOptions</a></code> 或 <code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html">NetClientOptions</a></code> 配置项中指定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ssl引擎">SSL引擎</h4>
<div class="paragraph">
<p>引擎实现可以配置为使用 <a href="https://www.openssl.org">OpenSSL</a> 而不是JDK实现（来支持SSL）。 OpenSSL提供比JDK引擎更好的性能和CPU使用率、以及JDK版本独立性。</p>
</div>
<div class="paragraph">
<p>引擎选项可使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当 <code><a href="../../ceylondoc/vertx-core//net/TCPSSLOptions.type.html#getSslEngineOptions()">getSslEngineOptions</a></code> 被设置时，使用该选项</p>
</li>
<li>
<p>否则使用 <code><a href="../../ceylondoc/vertx-core//net/JdkSSLEngineOptions.type.html">JdkSSLEngineOptions</a></code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">// Use JDK SSL engine
value options = NetServerOptions {
  ssl = true;
  keyStoreOptions = keyStoreOptions;
};

// Use JDK SSL engine explicitly
options = NetServerOptions {
  ssl = true;
  keyStoreOptions = keyStoreOptions;
  jdkSslEngineOptions = JdkSSLEngineOptions();
};

// Use OpenSSL engine
options = NetServerOptions {
  ssl = true;
  keyStoreOptions = keyStoreOptions;
  openSslEngineOptions = OpenSSLEngineOptions();
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_server_name_indication_sni">Server Name Indication (SNI)</h4>
<div class="paragraph">
<p>Server Name Indication (SNI) is a TLS extension by which a client specifies a hostname attempting to connect: during
the TLS handshake the client gives a server name and the server can use it to respond with a specific certificate
for this server name instead of the default deployed certificate.
If the server requires client authentication the server can use a specific trusted CA certificate depending on the
indicated server name.</p>
</div>
<div class="paragraph">
<p>When SNI is active the server uses</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the certificate CN or SAN DNS (Subject Alternative Name with DNS) to do an exact match, e.g <code>www.example.com</code></p>
</li>
<li>
<p>the certificate CN or SAN DNS certificate to match a wildcard name, e.g <code>*.example.com</code></p>
</li>
<li>
<p>otherwise the first certificate when the client does not present a server name or the presented server name cannot be matched</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the server additionally requires client authentication:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if <code><a href="../../ceylondoc/vertx-core//net/JksOptions.type.html">JksOptions</a></code> were used to set the trust options
( <code><a href="../../ceylondoc/vertx-core//net/NetServerOptions.type.html#setTrustOptions(io.vertx.core.net.TrustOptions)">options</a></code> ) then an exact match with the trust store
alias is done</p>
</li>
<li>
<p>otherwise the available CA certificates are used in the same way as if no SNI is in place</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can enable SNI on the server by setting <code><a href="../../ceylondoc/vertx-core//net/NetServerOptions.type.html#setSni(boolean)">sni</a></code> to <code>true</code> and
configured the server with multiple key/certificate pairs.</p>
</div>
<div class="paragraph">
<p>Java KeyStore files or PKCS12 files can store multiple key/cert pairs out of the box.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value keyCertOptions = JksOptions {
  path = "keystore.jks";
  password = "wibble";
};

value netServer = vertx.createNetServer(NetServerOptions {
  keyStoreOptions = keyCertOptions;
  ssl = true;
  sni = true;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../../ceylondoc/vertx-core//net/PemKeyCertOptions.type.html">PemKeyCertOptions</a></code> can be configured to hold multiple entries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value keyCertOptions = PemKeyCertOptions {
  keyPaths = ArrayList { "default-key.pem",  "host1-key.pem",  "etc..." };
  certPaths = ArrayList { "default-cert.pem",  "host2-key.pem",  "etc..." };
};

value netServer = vertx.createNetServer(NetServerOptions {
  pemKeyCertOptions = keyCertOptions;
  ssl = true;
  sni = true;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The client implicitly sends the connecting host as an SNI server name for Fully Qualified Domain Name (FQDN).</p>
</div>
<div class="paragraph">
<p>You can provide an explicit server name when connecting a socket</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">value client = vertx.createNetClient(NetClientOptions {
  trustStoreOptions = trustOptions;
  ssl = true;
});

// Connect to 'localhost' and present 'server.name' server name
client.connect(1234, "localhost", "server.name", (NetSocket|Throwable res) {
  if (is NetSocket res) {
    print("Connected!");
    value socket = res;
  } else {
    print("Failed to connect: ``res.getMessage()``");
  };
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can be used for different purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>present a server name different than the server host</p>
</li>
<li>
<p>present a server name while connecting to an IP</p>
</li>
<li>
<p>force to present a server name when using shortname</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_应用层协议协商_alpn">应用层协议协商 (ALPN)</h4>
<div class="paragraph">
<p>ALPN(Application-Layer Protocol Negotiation)是应用层协议协商的TLS扩展，它被HTTP/2使用：在TLS握手期时，客户端给出其接受的应用协议列表，之后服务器使用它所支持的协议响应。</p>
</div>
<div class="paragraph">
<p>If you are using Java 9, you are fine and you can use HTTP/2 out of the box without extra steps.</p>
</div>
<div class="paragraph">
<p>标准的Java 8不支持ALPN，所以ALPN应该通过其他方式启用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OpenSSL支持</p>
</li>
<li>
<p>Jetty-ALPN支持</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>引擎选项可使用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当 <code><a href="../../ceylondoc/vertx-core//net/TCPSSLOptions.type.html#getSslEngineOptions()">getSslEngineOptions</a></code> 被设置时，使用该选项</p>
</li>
<li>
<p>JDK中ALPN可用时使用 <code><a href="../../ceylondoc/vertx-core//net/JdkSSLEngineOptions.type.html">JdkSSLEngineOptions</a></code></p>
</li>
<li>
<p>OpenSSL中ALPN可用时使用 <code><a href="../../ceylondoc/vertx-core//net/OpenSSLEngineOptions.type.html">OpenSSLEngineOptions</a></code></p>
</li>
<li>
<p>否则失败</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_openssl_alpn支持">OpenSSL ALPN支持</h5>
<div class="paragraph">
<p>OpenSSL提供了原生的ALPN支持。</p>
</div>
<div class="paragraph">
<p>OpenSSL需要配置 <code><a href="../../ceylondoc/vertx-core//net/TCPSSLOptions.type.html#setOpenSslEngineOptions(io.vertx.core.net.OpenSSLEngineOptions)">openSslEngineOptions</a></code>
并在类路径上使用 <a href="http://netty.io/wiki/forked-tomcat-native.html">netty-tcnative</a> 的jar库。依赖于tcnative的实现它需要OpenSSL安装在您的操作系统中。</p>
</div>
</div>
<div class="sect4">
<h5 id="_jetty_alpn支持">Jetty-ALPN支持</h5>
<div class="paragraph">
<p>Jetty-ALPN是一个小型的jar，它覆盖了几种Java 8发行版用以支持ALPN。</p>
</div>
<div class="paragraph">
<p>JVM必须将 <code>alpn-boot-${version}.jar</code> 放在它的 <code>boot classpath</code> 中启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-Xbootclasspath/p:/path/to/alpn-boot${version}.jar</pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>${version}</code> 取决于JVM的版本，如 <strong>OpenJDK 1.8.0u74</strong> 中的 <strong>8.1.7.v20160121</strong>。这个完整列表可以在 <a href="http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html">Jetty-ALPN page</a>
页面上找到。</p>
</div>
<div class="paragraph">
<p>这种方法主要缺点是ALPN的实现版本依赖于JVM的版本。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，可以使用 <em><a href="https://github.com/jetty-project/jetty-alpn-agent">Jetty ALPN agent</a></em> 。agent是一个JVM代理，它会为运行它的JVM选择正确的ALPN版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-javaagent:/path/to/alpn/agent</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_客户端连接使用代理">客户端连接使用代理</h3>
<div class="paragraph">
<p><code><a href="../../ceylondoc/vertx-core//net/NetClient.type.html">NetClient</a></code> 支持HTTP/1.x <strong>CONNECT</strong>、<strong>SOCKS4a</strong> 或 <strong>SOCKS5</strong> 代理。</p>
</div>
<div class="paragraph">
<p>代理可以在 <code><a href="../../ceylondoc/vertx-core//net/NetClientOptions.type.html">NetClientOptions</a></code> 内设置
<code><a href="../../ceylondoc/vertx-core//net/ProxyOptions.type.html">ProxyOptions</a></code> 来配置代理类型、主机名、端口、可选的用户名和密码。</p>
</div>
<div class="paragraph">
<p>以下是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ceylon" data-lang="ceylon">import io.vertx.ceylon.core.net { socks5 }

...

value options = NetClientOptions {
  proxyOptions = ProxyOptions {
    type = "SOCKS5";
    host = "localhost";
    port = 1080;
    username = "username";
    password = "secret";
  };
};
value client = vertx.createNetClient(options);</code></pre>
</div>
</div>
<div class="paragraph">
<p>DNS 解析总是在代理服务器上完成解析，为了实现 SOCKS4 客户端的功能，需要先在本地解析 DNS 地址。</p>
</div>
</div>
</div>
</div>
        

        
          <div id="footer">
            <div id="footer-text">
              
                上次更新时间 2018-09-12 21:16:16 CST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/">主页</a></li>
          <li><a href="https://vertx.tk/download/">下载</a></li>
          <li><a href="https://vertx.tk/docs/">文档</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
          <li><a href="https://vertx.tk/blog/">博客</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/community/">Help &amp; Contributors</a></li>
          <li><a href="https://vertx.tk/materials/">Learning materials</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual-licensed under the <a href="http://www.eclipse.org/legal/epl-v20.html">Eclipse Public License 2.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="https://vertx.tk/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="https://vertx.tk/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="https://vertx.tk/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://vertx.tk/javascripts/bootstrap.min.js"></script>
<script src="https://vertx.tk/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="https://vertx.tk/javascripts/sidebar.js"></script>


<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});
</script>
</body>
</html>

