<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vert.x Service Proxy - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="https://vertx.tk/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://vertx.tk/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="https://vertx.tk/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="https://vertx.tk/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="https://vertx.tk/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
  <style>
    .page-link-to-github {
      position: relative;
      z-index: 1;
      display: inline-block;
      border: 1px solid #782B90;
      border-radius: 5px;
      color: #782B90;
      font-size: 12px;
      padding: 4px 10px;
      text-decoration: none;
      background-color: #ffffff;
    }
    .page-link-to-github:hover {
      color: #ffffff;
      border-color: #ffffff;
      background-color: #782B90;
    }

    .page-link-to-github .github-icon {
      position: absolute;
      display: inline-block;
      width: 20px;
      height: 20px;
      /*background-position: -50px 0*/
      background: url('https://vertx.tk/assets/github.png') no-repeat 0 0;
    }

    @media (-webkit-min-device-pixel-ratio: 2),(min-resolution:192dpi) {
      .page-link-to-github .github-icon {
        background-image:url('https://vertx.tk/assets/github@2x.png');
        background-size: 150px auto
      }
    }

    .page-link-to-github:hover .github-icon {
      /*background-position: 0 0*/
      background-position: -100px 0
    }
    .text {
      text-decoration: underline
    }
    .page-link-to-github .text {
      padding-left: 27px
    }
    .text {
      padding-right: 8px
    }
    .page-link-to-github {
      float: right;
      top: 4px
    }

  </style>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://vertx.tk/" class="navbar-brand"><img alt="Brand" src="https://vertx.tk/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="https://vertx.tk/download/">下载</a></li>
        <li><a href="https://vertx.tk/docs/">文档</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
        <li><a href="https://vertx.tk/community/">社区</a></li>
        <li><a href="https://vertx.tk/materials/">资料</a></li>
        <li><a href="https://vertx.tk/blog/">博客</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>Vert.x Service Proxy</h1>
          
        </div>
      </div>
    </div>
  </div>




<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_使用vert_x_服务代理组件">使用Vert.x 服务代理组件</a></li>
<li><a href="#_服务代理介绍">服务代理介绍</a></li>
<li><a href="#_异步接口">异步接口</a></li>
<li><a href="#_代码生成">代码生成</a></li>
<li><a href="#_暴露你的服务">暴露你的服务</a></li>
<li><a href="#_代理的创建">代理的创建</a></li>
<li><a href="#_错误处理">错误处理</a></li>
<li><a href="#_服务接口的约束">服务接口的约束</a>
<ul class="sectlevel2">
<li><a href="#_方法返回类型">方法返回类型</a></li>
<li><a href="#_参数类型和异步返回类型">参数类型和异步返回类型</a></li>
<li><a href="#_重载的方法">重载的方法</a></li>
</ul>
</li>
<li><a href="#_通过event_bus调用服务的约定_不使用服务代理的情况下">通过Event Bus调用服务的约定（不使用服务代理的情况下）</a></li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_使用vert_x_服务代理组件">使用Vert.x 服务代理组件</a></li>
<li><a href="#_服务代理介绍">服务代理介绍</a></li>
<li><a href="#_异步接口">异步接口</a></li>
<li><a href="#_代码生成">代码生成</a></li>
<li><a href="#_暴露你的服务">暴露你的服务</a></li>
<li><a href="#_代理的创建">代理的创建</a></li>
<li><a href="#_错误处理">错误处理</a></li>
<li><a href="#_服务接口的约束">服务接口的约束</a>
<ul class="sectlevel2">
<li><a href="#_方法返回类型">方法返回类型</a></li>
<li><a href="#_参数类型和异步返回类型">参数类型和异步返回类型</a></li>
<li><a href="#_重载的方法">重载的方法</a></li>
</ul>
</li>
<li><a href="#_通过event_bus调用服务的约定_不使用服务代理的情况下">通过Event Bus调用服务的约定（不使用服务代理的情况下）</a></li>
</ul>
        </div>

  <a href="https://github.com/okou19900722/vertx-web-site-translation-chinese/tree/master/vertx-translation-stack/vertx-service-proxy-translation"
     class="page-link-to-github"
     target="_blank"
     title="Edit this page on GitHub">
    <i class="github-icon"></i>
    <span class="text">编辑本页</span>
  </a>

        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>当编写一个Vert.x应用时，你可能想将某个功能在某处隔离开来，并对应用的其它部分提供服务。</p>
</div>
<div class="paragraph">
<p>这就是服务代理（service proxy）的目的。它允许你在Event Bus上暴露（expose）一个服务，所以，只要它们在服务发布时清楚服务的地址（address），其他任意的Vert.x组件都可以去调用它。</p>
</div>
<div class="paragraph">
<p>Vert.x用一个Java接口来描述一个 服务，这个接口包含的方法遵循异步模式。在底层，服务调用是通过调用端向Event Bus发送消息，被调用端收到消息调用服务并且返回结果来实现的。
为了使其更容易使用，服务代理组件可以生成一个代理类，你可以直接调用这个代理（通过服务接口中的API）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用vert_x_服务代理组件">使用Vert.x 服务代理组件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要 <strong>使用</strong> Vert.x Service Proxy组件，请先加入以下依赖：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在 <code>pom.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.vertx&lt;/groupId&gt;
  &lt;artifactId&gt;vertx-service-proxy&lt;/artifactId&gt;
  &lt;version&gt;3.6.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在 <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile 'io.vertx:vertx-service-proxy:3.6.0-SNAPSHOT'</code></pre>
</div>
</div>
<div class="paragraph">
<p>要 <strong>实现</strong> 服务代理（译者注：即生成服务代理类），还需要加入以下依赖：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在 <code>pom.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.vertx&lt;/groupId&gt;
  &lt;artifactId&gt;vertx-codegen&lt;/artifactId&gt;
  &lt;version&gt;3.6.0-SNAPSHOT&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在 <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compileOnly 'io.vertx:vertx-codegen:3.6.0-SNAPSHOT'</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意服务代理机制依赖于代码生成，所以每次修改服务接口以后都需重新执行构建过程来重新生成代码。</p>
</div>
<div class="paragraph">
<p>如果需要生成不同语言的服务代理代码，你需要添加对应的语言支持依赖，比如 Groovy 对应 <code>vertx-lang-groovy</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_服务代理介绍">服务代理介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>让我们先看看服务代理并了解一下为什么它们有用。假设有一个数据库服务暴露在Event Bus上，你需要做以下的事情来调用服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JsonObject message = new JsonObject();
message.put("collection", "mycollection")
    .put("document", new JsonObject().put("name", "tim"));
DeliveryOptions options = new DeliveryOptions().addHeader("action", "save");
vertx.eventBus().send("database-service-address", message, options, res2 -&gt; {
  if (res2.succeeded()) {
    // 调用成功
  } else {
    // 调用失败
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们用这种方式写服务模块的时候，需要写很多重复的模板代码来监听Event Bus中的消息、将其分派到合适的方法并将结果返回到Event Bus。</p>
</div>
<div class="paragraph">
<p>而有了Vert.x 服务代理组件，你就不必再写这么多的模板代码了，只需要专注服务的实现即可。</p>
</div>
<div class="paragraph">
<p>你需要将服务接口抽象成一个Java接口，并且加上 <code>@ProxyGen</code> 注解，比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ProxyGen
public interface SomeDatabaseService {

  // 一些用于创建服务实例和服务代理实例的工厂方法
  static SomeDatabaseService create(Vertx vertx) {
    return new SomeDatabaseServiceImpl(vertx);
  }

  static SomeDatabaseService createProxy(Vertx vertx,
    String address) {
    return new SomeDatabaseServiceVertxEBProxy(vertx, address);
  }

 // 实际的服务方法
 void save(String collection, JsonObject document,
   Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个接口，Vert.x会生成所有需要的用于在Event Bus上访问你的服务的模板代码，
同时也会生成对应的 <strong>调用端代理类</strong>（client side proxy），这样你的服务调用端就可以使用一个相当符合习惯的API（译者注：即相同的服务接口）进行服务调用，而不是去手动地向Event Bus发送消息。
不管你的服务实际在哪个Event Bus上（可能是在不同的机器上），调用端代理类都能正常工作。</p>
</div>
<div class="paragraph">
<p>也就是说，你可以通过以下方式进行服务调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SomeDatabaseService service = SomeDatabaseService.createProxy(vertx,
    "database-service-address");

// 使用代理类进行服务调用 —— 向数据库中存储一些数据
service.save("mycollection", new JsonObject().put("name", "tim"), res2 -&gt; {
  if (res2.succeeded()) {
    // 调用完毕
  }
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
译者注：Vert.x 服务代理组件提供的功能其实就是一种 <strong>异步RPC</strong> 的功能，其底层实现依赖于Event Bus。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你也可以将多语言API生成功能（ <code>@VertxGen</code> 注解）与 <code>@ProxyGen</code> 注解相结合，
用于生成其它Vert.x支持的JVM语言对应的服务代理 —— 这意味着你可以只用Java编写你的服务一次，
就可以在其他语言中以一种习惯的API风格进行服务调用，而不必管服务是在本地还是在Event Bus的别处。
想要利用多语言代码生成功能，不要忘记添加对应支持语言的依赖。以下是使用示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ProxyGen // Generate service proxies
@VertxGen // Generate the clients
public interface SomeDatabaseService {
  // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异步接口">异步接口</h2>
<div class="sectionbody">
<div class="paragraph">
<p>想要正确地生成服务代理类，服务接口的设计必须遵循一些规则。
首先是需要遵循异步模式。如果需要返回结果，对应的方法需要包含一个 <code>Handler&lt;AsyncResult&lt;ResultType&gt;&gt;</code> 类型的参数，
其中 <code>ResultType</code> 可以是另一种代理类型（所以一个代理类可以作为另一个代理类的工厂）。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ProxyGen
public interface SomeDatabaseService {

 // 一些用于创建服务实例和服务代理实例的工厂方法

 static SomeDatabaseService create(Vertx vertx) {
   return new SomeDatabaseServiceImpl(vertx);
 }

 static SomeDatabaseService createProxy(Vertx vertx, String address) {
   return new SomeDatabaseServiceVertxEBProxy(vertx, address);
 }

 // 异步方法，仅通知调用是否完成，不返回结果
 void save(String collection, JsonObject document,
   Handler&lt;AsyncResult&lt;Void&gt;&gt; result);

 // 异步方法，包含JsonObject类型的返回结果
 void findOne(String collection, JsonObject query,
   Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; result);

 // 创建连接
 void createConnection(String shoeSize,
   Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ProxyGen
@VertxGen
public interface MyDatabaseConnection {

 void insert(JsonObject someData);

 void commit(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler);

 @ProxyClose
 void close();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过声明一个特殊方法，并给其加上 <code>@ProxyClose</code> 注解来注销代理。当此方法被调用时，代理实例被清除。</p>
</div>
<div class="paragraph">
<p>更多服务接口的限制会在下面详解。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_代码生成">代码生成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>被 <code>@ProxyGen</code> 注解的服务接口会触发生成对应的服务辅助类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务代理类（service proxy）：一个编译时产生的代理类，用 <code>EventBus</code> 通过消息与服务交互。</p>
</li>
<li>
<p>服务处理器类（service handler）： 一个编译时产生的 <code>EventBus</code> 处理器类，用于响应由服务代理发送的事件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>产生的服务代理和处理器的命名是在类名的后面加相关的字段，例如，如果一个服务接口名为 <code>MyService</code>，则对应的处理器类命名为 <code>MyServiceProxyHandler</code> ，对应的服务代理类命名为 <code>MyServiceVertxEBProxy</code>。</p>
</div>
<div class="paragraph">
<p>同时Vert.x Codegen也提供数据对象转换器（data object converter）的生成，这使得在服务代理中处理数据实体更加容易。生成的转换器提供了一个接受 <code>JsonObject</code> 的构造函数（译者注：用于将 <code>JsonObject</code> 转换为数据实体类）以及一个 <code>toJson</code> 函数（译者注：用于将数据实体类转换为 <code>JsonObject</code>），这些函数对于在服务代理中处理数据实体来说都是必要的。</p>
</div>
<div class="paragraph">
<p><strong>Codegen</strong> 注解处理器（annotation processor）会在编译期生成这些类。这是Java编译器的一个特性，所以不需要额外的步骤，只需要去配置一下对应的构建配置：</p>
</div>
<div class="paragraph">
<p>只需要在构建配置中加上 <code>io.vertx:vertx-service-proxy:processor</code> 依赖。</p>
</div>
<div class="paragraph">
<p>这是一个针对Maven的配置示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.vertx&lt;/groupId&gt;
  &lt;artifactId&gt;vertx-service-proxy&lt;/artifactId&gt;
  &lt;version&gt;3.6.0-SNAPSHOT&lt;/version&gt;
  &lt;classifier&gt;processor&lt;/classifier&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gradle中也可以进行配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>compile "io.vertx:vertx-service-proxy:3.6.0-SNAPSHOT:processor"</code></pre>
</div>
</div>
<div class="paragraph">
<p>IDE通常会支持注解处理器。</p>
</div>
<div class="paragraph">
<p><code>processor</code> classifier会自动通过 <code>META-INF/services</code> 插件机制向jar包中添加服务代理注解处理器的配置。</p>
</div>
<div class="paragraph">
<p>如果想要的话，你也可以通过正常的jar来使用注解处理器，但是你需要显式地声明注解处理器。比如在 Maven 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
  &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;annotationProcessors&gt;
      &lt;annotationProcessor&gt;io.vertx.serviceproxy.generator.ServiceProxyProcessor&lt;/annotationProcessor&gt;
    &lt;/annotationProcessors&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_暴露你的服务">暴露你的服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你写好服务接口以后，执行构建操作以生成代码。然后你需要将你的服务“注册”到Event Bus上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SomeDatabaseService service = new SomeDatabaseServiceImpl();
// 注册服务
new ServiceBinder(vertx)
  .setAddress("database-service-address")
  .register(SomeDatabaseService.class, service);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个过程既可以在 Verticle 中完成，也可以在你的代码的任何其它位置完成。</p>
</div>
<div class="paragraph">
<p>一旦注册了，这个服务就可用了。如果你的应用运行在集群上，则集群中节点都可访问。</p>
</div>
<div class="paragraph">
<p>如果想注销这个服务，可使用 <code><a href="../../apidocs/io/vertx/serviceproxy/ServiceBinder.html#unregister-io.vertx.core.eventbus.MessageConsumer-">unregister</a></code>
方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceBinder binder = new ServiceBinder(vertx);

// Create an instance of your service implementation
SomeDatabaseService service = new SomeDatabaseServiceImpl();
// 注册服务
MessageConsumer&lt;JsonObject&gt; consumer = binder
  .setAddress("database-service-address")
  .register(SomeDatabaseService.class, service);

// ....

// 注销服务
binder.unregister(consumer);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_代理的创建">代理的创建</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你的服务发布（expose）以后，你可能想要去调用它。这时，你需要创建一个服务代理，而代理的创建可以利用 <code>ProxyHelper</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceProxyBuilder builder = new ServiceProxyBuilder(vertx).setAddress("database-service-address");

SomeDatabaseService service = builder.build(SomeDatabaseService.class);
// 也可以指定消息传递的配置
SomeDatabaseService service2 = builder.setOptions(options).build(SomeDatabaseService.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中第二个方法会接受一个 <code><a href="../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html">DeliveryOptions</a></code> 实例，你可以在这里配置消息传递的相关参数（如 <code>timeout</code>）。</p>
</div>
<div class="paragraph">
<p>你也可以使用生成的代理类，代理类名是服务接口类名加上 <code>VertxEBProxy</code>。比如你的服务接口类名是 <code>SomeDatabaseService</code>，则代理名就是 <code>SomeDatabaseServiceVertxEBProxy</code>。</p>
</div>
<div class="paragraph">
<p>通常情况下，服务接口中会包含一个 <code>createProxy</code> 静态方法用来创建服务代理实例，但这不是必须的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ProxyGen
public interface SomeDatabaseService {

 // 用于创建服务代理实例的方法
 static SomeDatabaseService createProxy(Vertx vertx, String address) {
   return new SomeDatabaseServiceVertxEBProxy(vertx, address);
 }

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_错误处理">错误处理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>服务方法可能会通过向方法的处理器（<code>Handler</code>）传递一个失败状态的 <code>Future</code> （包含一个 <code><a href="../../apidocs/io/vertx/serviceproxy/ServiceException.html">ServiceException</a></code>
实例）来返回错误。一个 <code>ServiceException</code> 包含一个整形（<code>int</code>）的错误状态码、一条消息和一个可选的 <code>JsonObject</code> 对象（用于包含额外的重要信息）。为了方便起见，我们可以使用
<code><a href="../../apidocs/io/vertx/serviceproxy/ServiceException.html#fail-int-java.lang.String-">ServiceException.fail</a></code> 工厂方法来创建一个已经是失败状态并且包装着
<code>ServiceException</code> 实例的 <code>Future</code>。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SomeDatabaseServiceImpl implements SomeDatabaseService {
private static final BAD_SHOE_SIZE = 42;
private static final CONNECTION_FAILED = 43;

  // 创建连接
  void createConnection(String shoeSize, Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler) {
    if (!shoeSize.equals("9")) {
      resultHandler.handle(ServiceException.fail(BAD_SHOE_SIZE, "The shoe size must be 9!",
        new JsonObject().put("shoeSize", shoeSize));
     } else {
        doDbConnection(result -&gt; {
          if (result.succeeded()) {
            resultHandler.handle(Future.succeededFuture(result.result()));
          } else {
            resultHandler.handle(ServiceException.fail(CONNECTION_FAILED, result.cause().getMessage()));
          }
        });
     }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>服务调用端（client side）可以检查它接收到的失败状态的 <code>AsyncResult</code> 包含的 <code>Throwable</code> 对象是否为 <code>ServiceException</code> 实例。如果是的话，继续检查内部的特定的错误状态码。调用端可以通过这些信息来将业务逻辑错误与系统错误（如服务没有被注册到Event Bus上）区分开，以便确定到底发生了哪一种业务逻辑错误。下面是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public void foo(String shoeSize, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; handler) {
  SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);
  service.createConnection("8", result -&gt; {
    if (result.succeeded()) {
      // 正常调用
    } else {
      if (result.cause() instanceof ServiceException) {
        ServiceException exc = (ServiceException) result.cause();
        if (exc.failureCode() == SomeDatabaseServiceImpl.BAD_SHOE_SIZE) {
          handler.handle(Future.failedFuture(
            new InvalidInputError("You provided a bad shoe size: " +
              exc.getDebugInfo().getString("shoeSize"))
          ));
        } else if (exc.failureCode() == SomeDatabaseServiceImpl.CONNECTION) {
          handler.handle(Future.failedFuture(
            new ConnectionError("Failed to connect to the DB")));
        }
      } else {
        // 可能是一个系统错误(system error)，如服务代理没有对应的已注册的服务
        handler.handle(Future.failedFuture(
          new SystemError("An unexpected error occurred: + " result.cause().getMessage())
        ));
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要的话，服务实现的时候也可以返回 <code>ServiceException</code> 的子类，只要向Event Bus注册了对应的默认 <code>MessageCodec</code> 就可以。比如给定下面的 <code>ServiceException</code> 子类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class ShoeSizeException extends ServiceException {
  public static final BAD_SHOE_SIZE_ERROR = 42;

  private final String shoeSize;

  public ShoeSizeException(String shoeSize) {
    super(BAD_SHOE_SIZE_ERROR, "In invalid shoe size was received: " + shoeSize);
    this.shoeSize = shoeSize;
  }

  public String getShoeSize() {
    return extra;
  }

  public static &lt;T&gt; AsyncResult&lt;T&gt; fail(int failureCode, String message, String shoeSize) {
    return Future.failedFuture(new MyServiceException(failureCode, message, shoeSize));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要向Event Bus注册了对应的 <code>MessageCodec</code> ，服务就可以直接向调用者返回自定义的异常类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SomeDatabaseServiceImpl implements SomeDatabaseService {
  public SomeDataBaseServiceImpl(Vertx vertx) {
    // 在服务端（被调用端）注册MessageCodec。如果运行在单机模式下这就足够了
    // 因为服务代理会共享同一个Vertx实例
  SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);
    vertx.eventBus().registerDefaultCodec(ShoeSizeException.class,
      new ShoeSizeExceptionMessageCodec());
  }

  // 创建连接
  void createConnection(String shoeSize, Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler) {
    if (!shoeSize.equals("9")) {
      resultHandler.handle(ShoeSizeException.fail(shoeSize));
    } else {
      // Create the connection here
      resultHandler.Handle(Future.succeededFuture(myDbConnection));
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后调用端可以检查自定义的异常类型了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public void foo(String shoeSize, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; handler) {
  // 如果运行在集群模式下，那么需要将ShoeSizeExceptionMessageCodec注册到当前节点的Event Bus下
  SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);
  service.createConnection("8", result -&gt; {
    if (result.succeeded()) {
      // 进行方法调用
    } else {
      if (result.cause() instanceof ShoeSizeException) {
        ShoeSizeException exc = (ShoeSizeException) result.cause();
        handler.handle(Future.failedFuture(
          new InvalidInputError("You provided a bad shoe size: " + exc.getShoeSize())));
      } else {
        // 可能是一个系统错误(system error)，如服务代理没有对应的已注册的服务
        handler.handle(Future.failedFuture(
          new SystemError("An unexpected error occurred: + " result.cause().getMessage())
        ));
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在Vert.x 集群模式下，你需要向集群中每个节点的Event Bus注册对应的自定义异常类型的 <code>MessageCodec</code> 实例。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_服务接口的约束">服务接口的约束</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在服务方法中可用的参数类型和返回值类型是有限制的，这样使得转化为Event Bus消息更加容易。下面我们就来看一下：</p>
</div>
<div class="sect2">
<h3 id="_方法返回类型">方法返回类型</h3>
<div class="paragraph">
<p>返回类型必须是以下其中之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void</code></p>
</li>
<li>
<p>返回此服务实例的引用（<code>this</code>）并标注 <code>@Fluent</code> 注解：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Fluent
SomeDatabaseService doSomething();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是因为方法不能阻塞，并且如果服务是远程的，不可能立即返回结果而不阻塞。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数类型和异步返回类型">参数类型和异步返回类型</h3>
<div class="paragraph">
<p>下文表述的</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JSON</code> 包括 <code>JsonObject</code> 和 <code>JsonArray</code></p>
</li>
<li>
<p><code>PRIMITIVE</code> 包括 任意原生类型或包装的原生类型。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>参数类型可以是以下类型中任意一个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JSON</code></p>
</li>
<li>
<p><code>PRIMITIVE</code></p>
</li>
<li>
<p><code>List&lt;JSON&gt;</code></p>
</li>
<li>
<p><code>List&lt;PRIMITIVE&gt;</code></p>
</li>
<li>
<p><code>Set&lt;JSON&gt;</code></p>
</li>
<li>
<p><code>Set&lt;PRIMITIVE&gt;</code></p>
</li>
<li>
<p><code>Map&lt;String, JSON&gt;</code></p>
</li>
<li>
<p><code>Map&lt;String, PRIMITIVE&gt;</code></p>
</li>
<li>
<p>任何枚举类型</p>
</li>
<li>
<p>任何被 <code>@DataObject</code> 注解的类</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果需要返回异步结果，可以提供一个 <code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code> 类型的参数放到最后。</p>
</div>
<div class="paragraph">
<p>其中类型 <code>R</code> 可以是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JSON</code></p>
</li>
<li>
<p><code>PRIMITIVE</code></p>
</li>
<li>
<p><code>List&lt;JSON&gt;</code></p>
</li>
<li>
<p><code>List&lt;PRIMITIVE&gt;</code></p>
</li>
<li>
<p><code>Set&lt;JSON&gt;</code></p>
</li>
<li>
<p><code>Set&lt;PRIMITIVE&gt;</code></p>
</li>
<li>
<p>任何枚举类型</p>
</li>
<li>
<p>任何被 <code>@DataObject</code> 注解的类</p>
</li>
<li>
<p>另一个代理类</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_重载的方法">重载的方法</h3>
<div class="paragraph">
<p>服务接口中不允许有重载的服务方法（即方法名相同，参数列表不同）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_通过event_bus调用服务的约定_不使用服务代理的情况下">通过Event Bus调用服务的约定（不使用服务代理的情况下）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>服务代理假定Event Bus中的消息遵循一定的格式，因此能被用于服务的调用。</p>
</div>
<div class="paragraph">
<p>当然，如果不愿意的话，你也可以不用服务代理类来访问远程服务。被广泛接受的与服务交互的方式就是直接在Event Bus发送消息。</p>
</div>
<div class="paragraph">
<p>为了使服务访问的方式一致，所有的服务都必须遵循以下的消息格式。</p>
</div>
<div class="paragraph">
<p>格式非常简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>需要有一个名为 <code>action</code> 的 消息头(header)，作为要执行操作的名称</p>
</li>
<li>
<p>消息体（message body）应该是一个 <code>JsonObject</code> 对象，里面需要包含操作需要的所有参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>举个例子，假如我们要去执行一个名为 <code>save</code> 的操作，此操作接受一个字符串类型的 <code>collection</code> 参数和一个 <code>JsonObject</code> 类型的 <code>document</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Headers:
    "action": "save"
Body:
    {
        "collection", "mycollection",
        "document", {
            "name": "tim"
        }
    }</pre>
</div>
</div>
<div class="paragraph">
<p>无论有没有用到服务代理，都应该用上面这种方式编写服务，因为这样允许服务交互时保持一致性。</p>
</div>
<div class="paragraph">
<p>在上面的例子中，<code>action</code> 对应的值应该与服务接口的某个方法名称相对应，而消息体中每个 <code>[key, value]</code> 都要与服务方法中的某个 <code>[arg_name, arg_value]</code> 相对应（译者注：<code>key</code> 对应参数名，<code>value</code> 对应参数值）。</p>
</div>
<div class="paragraph">
<p>对于返回值，服务需使用 <code>message.reply(…​)</code> 方法去向调用端发送回一个返回值 —— 这个值可以是Event Bus支持的任何类型。如果需要表示调用失败，可以使用 <code>message.fail(…​)</code> 方法。</p>
</div>
<div class="paragraph">
<p>如果你使用Vert.x 服务代理组件的话，生成的代码会自动帮你处理这些问题。</p>
</div>
</div>
</div>
        

        
          <div id="footer">
            <div id="footer-text">
              
                上次更新时间 2018-11-05 19:56:57 CST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/">主页</a></li>
          <li><a href="https://vertx.tk/download/">下载</a></li>
          <li><a href="https://vertx.tk/docs/">文档</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
          <li><a href="https://vertx.tk/blog/">博客</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/community/">Help &amp; Contributors</a></li>
          <li><a href="https://vertx.tk/materials/">Learning materials</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
          <li><a href="//shang.qq.com/wpa/qunwpa?idkey=587f58cacb9557e3291b46098e0fe09427b98a1c0f866da23c04c2762bc7e2ad">QQ群</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual-licensed under the <a href="http://www.eclipse.org/legal/epl-v20.html">Eclipse Public License 2.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="https://vertx.tk/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="https://vertx.tk/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="https://vertx.tk/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://vertx.tk/javascripts/bootstrap.min.js"></script>
<script src="https://vertx.tk/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="https://vertx.tk/javascripts/sidebar.js"></script>


<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});
</script>
</body>
</html>

