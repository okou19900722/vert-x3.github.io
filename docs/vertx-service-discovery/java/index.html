<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vert.x Service Discovery - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="https://vertx.tk/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://vertx.tk/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="https://vertx.tk/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="https://vertx.tk/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="https://vertx.tk/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
  <style>
    .page-link-to-github {
      position: relative;
      z-index: 1;
      display: inline-block;
      border: 1px solid #782B90;
      border-radius: 5px;
      color: #782B90;
      font-size: 12px;
      padding: 4px 10px;
      text-decoration: none;
      background-color: #ffffff;
    }
    .page-link-to-github:hover {
      color: #ffffff;
      border-color: #ffffff;
      background-color: #782B90;
    }

    .page-link-to-github .github-icon {
      position: absolute;
      display: inline-block;
      width: 20px;
      height: 20px;
      /*background-position: -50px 0*/
      background: url('https://vertx.tk/assets/github.png') no-repeat 0 0;
    }

    @media (-webkit-min-device-pixel-ratio: 2),(min-resolution:192dpi) {
      .page-link-to-github .github-icon {
        background-image:url('https://vertx.tk/assets/github@2x.png');
        background-size: 150px auto
      }
    }

    .page-link-to-github:hover .github-icon {
      /*background-position: 0 0*/
      background-position: -100px 0
    }
    .text {
      text-decoration: underline
    }
    .page-link-to-github .text {
      padding-left: 27px
    }
    .text {
      padding-right: 8px
    }
    .page-link-to-github {
      float: right;
      top: 4px
    }

  </style>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://vertx.tk/" class="navbar-brand"><img alt="Brand" src="https://vertx.tk/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="https://vertx.tk/download/">下载</a></li>
        <li><a href="https://vertx.tk/docs/">文档</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
        <li><a href="https://vertx.tk/community/">社区</a></li>
        <li><a href="https://vertx.tk/materials/">资料</a></li>
        <li><a href="https://vertx.tk/blog/">博客</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>Vert.x Service Discovery</h1>
          
        </div>
      </div>
    </div>
  </div>



<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_使用service_discovery">使用Service Discovery</a></li>
<li><a href="#_基本概念">基本概念</a>
<ul class="sectlevel2">
<li><a href="#_服务记录">服务记录</a></li>
<li><a href="#_服务提供者和发布者">服务提供者和发布者</a></li>
<li><a href="#_服务消费者">服务消费者</a></li>
<li><a href="#_服务对象">服务对象</a></li>
<li><a href="#_服务类型">服务类型</a></li>
<li><a href="#_服务事件">服务事件</a></li>
<li><a href="#_服务存储后端">服务存储后端</a></li>
</ul>
</li>
<li><a href="#_创建service_discovery实例">创建Service Discovery实例</a></li>
<li><a href="#_发布服务">发布服务</a></li>
<li><a href="#_取消发布的服务">取消发布的服务</a></li>
<li><a href="#_查找服务">查找服务</a></li>
<li><a href="#_获取服务引用">获取服务引用</a></li>
<li><a href="#_服务类型_2">服务类型</a>
<ul class="sectlevel2">
<li><a href="#_无类型的服务">无类型的服务</a></li>
<li><a href="#_自定义的服务类型">自定义的服务类型</a></li>
<li><a href="#_http_endpoints">HTTP endpoints</a></li>
<li><a href="#_event_bus_服务">Event Bus 服务</a></li>
<li><a href="#_消息源服务">消息源服务</a></li>
<li><a href="#_jdbc_数据源">JDBC 数据源</a></li>
<li><a href="#_redis_数据源">Redis 数据源</a></li>
<li><a href="#_mongo_数据源">Mongo 数据源</a></li>
</ul>
</li>
<li><a href="#_监听服务的上线与下线">监听服务的上线与下线</a></li>
<li><a href="#_监听服务的使用">监听服务的使用</a></li>
<li><a href="#_服务发现桥接器">服务发现桥接器</a></li>
<li><a href="#_其他服务发现桥接器">其他服务发现桥接器</a>
<ul class="sectlevel2">
<li><a href="#_consul_桥接器">Consul 桥接器</a></li>
<li><a href="#_kubernetes_桥接器">Kubernetes 桥接器</a></li>
<li><a href="#_docker_links_桥接器">Docker Links 桥接器</a></li>
</ul>
</li>
<li><a href="#_其他存储后端">其他存储后端</a>
<ul class="sectlevel2">
<li><a href="#_redis_存储后端">Redis 存储后端</a></li>
</ul>
</li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_使用service_discovery">使用Service Discovery</a></li>
<li><a href="#_基本概念">基本概念</a>
<ul class="sectlevel2">
<li><a href="#_服务记录">服务记录</a></li>
<li><a href="#_服务提供者和发布者">服务提供者和发布者</a></li>
<li><a href="#_服务消费者">服务消费者</a></li>
<li><a href="#_服务对象">服务对象</a></li>
<li><a href="#_服务类型">服务类型</a></li>
<li><a href="#_服务事件">服务事件</a></li>
<li><a href="#_服务存储后端">服务存储后端</a></li>
</ul>
</li>
<li><a href="#_创建service_discovery实例">创建Service Discovery实例</a></li>
<li><a href="#_发布服务">发布服务</a></li>
<li><a href="#_取消发布的服务">取消发布的服务</a></li>
<li><a href="#_查找服务">查找服务</a></li>
<li><a href="#_获取服务引用">获取服务引用</a></li>
<li><a href="#_服务类型_2">服务类型</a>
<ul class="sectlevel2">
<li><a href="#_无类型的服务">无类型的服务</a></li>
<li><a href="#_自定义的服务类型">自定义的服务类型</a></li>
<li><a href="#_http_endpoints">HTTP endpoints</a></li>
<li><a href="#_event_bus_服务">Event Bus 服务</a></li>
<li><a href="#_消息源服务">消息源服务</a></li>
<li><a href="#_jdbc_数据源">JDBC 数据源</a></li>
<li><a href="#_redis_数据源">Redis 数据源</a></li>
<li><a href="#_mongo_数据源">Mongo 数据源</a></li>
</ul>
</li>
<li><a href="#_监听服务的上线与下线">监听服务的上线与下线</a></li>
<li><a href="#_监听服务的使用">监听服务的使用</a></li>
<li><a href="#_服务发现桥接器">服务发现桥接器</a></li>
<li><a href="#_其他服务发现桥接器">其他服务发现桥接器</a>
<ul class="sectlevel2">
<li><a href="#_consul_桥接器">Consul 桥接器</a></li>
<li><a href="#_kubernetes_桥接器">Kubernetes 桥接器</a></li>
<li><a href="#_docker_links_桥接器">Docker Links 桥接器</a></li>
</ul>
</li>
<li><a href="#_其他存储后端">其他存储后端</a>
<ul class="sectlevel2">
<li><a href="#_redis_存储后端">Redis 存储后端</a></li>
</ul>
</li>
</ul>
        </div>

  <a href="https://github.com/okou19900722/vertx-web-site-translation-chinese/tree/master/vertx-translation-stack/vertx-service-discovery-translation"
     class="page-link-to-github"
     target="_blank"
     title="Edit this page on GitHub">
    <i class="github-icon"></i>
    <span class="text">编辑本页</span>
  </a>

        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 提供了一个服务发现的基础组件，用来发布和发现各种类型的资源，比如服务代理、HTTP端点（endpoint）、数据源（data source）等等。
这些资源都可以称为<strong>服务</strong>。服务就是一个可以被发现和访问的功能，可以通过它的类型、元数据和位置来进行描述。
所以，服务可以是一个数据库、一个服务代理、一个HTTP应用，以及任何你能想到的可描述、可发现、可交互的资源。
它不一定是Vert.x实体，它可以是任何组件。在Vert.x 服务发现组件中，我们通过
<code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 来描述每个服务。</p>
</div>
<div class="paragraph">
<p>服务发现组件实现了面向服务计算中定义的服务交互。此外，在某种程度上，还提供了动态的面向服务计算交互，这样应用程序可以对各种服务的上线、下线作出反应。</p>
</div>
<div class="paragraph">
<p>一个服务提供者可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>发布一个服务记录</p>
</li>
<li>
<p>将已经发布的服务记录注销</p>
</li>
<li>
<p>更新已发布服务记录的状态（下线、服务暂停等等）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个服务消费者可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>查找各种服务</p>
</li>
<li>
<p>绑定到某个服务（它所获取到的 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code>) ）并且使用这个服务</p>
</li>
<li>
<p>当使用完后，释放绑定的服务</p>
</li>
<li>
<p>监听服务的上线、下线和状态变更的消息</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consumer would 1) lookup a service record matching their need, 2) retrieve the
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> that give access to the service, 3) get a service object to access
the service, 4) release the service object once done.</p>
</div>
<div class="paragraph">
<p>如果知道服务的类型（JDBC客户端、HTTP客户端），整个过程就可以简化为通过服务类型直接获取服务对象。</p>
</div>
<div class="paragraph">
<p>从上面可以看出，服务提供者和服务消费者，通过服务记录 （ <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 对象） 来共享关键的信息。</p>
</div>
<div class="paragraph">
<p>服务提供者和消费者，必须创建他们自己的 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html">ServiceDiscovery</a></code> 实例。这些实例通过底层的分布式数据结构来协同保持服务集合的同步。</p>
</div>
<div class="paragraph">
<p>服务发现组件支持桥接的方式，来从其他服务发现技术中导入和导出服务。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用service_discovery">使用Service Discovery</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要使用Vert.x 服务发现组件，需要将下列依赖加入到依赖配置中文件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven ( <code>pom.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
&lt;groupId&gt;io.vertx&lt;/groupId&gt;
&lt;artifactId&gt;vertx-service-discovery&lt;/artifactId&gt;
&lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle ( <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile 'io.vertx:vertx-service-discovery:3.6.0'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_基本概念">基本概念</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节将解释服务发现机制所涉及到的一些概念。</p>
</div>
<div class="sect2">
<h3 id="_服务记录">服务记录</h3>
<div class="paragraph">
<p>我们用服务记录（ <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 对象）来描述服务提供者提供的服务，它包含了服务名称、一些元数据和一个描述服务所在位置的位置对象。</p>
</div>
<div class="paragraph">
<p>服务记录的元数据、甚至位置的格式，都有赖于 <code>服务的类型</code> （详见后续章节）。</p>
</div>
<div class="paragraph">
<p>当服务提供者准备好可以提供服务时，会发布一条服务记录，在服务停止的时候，会收回这条服务记录。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务提供者和发布者">服务提供者和发布者</h3>
<div class="paragraph">
<p>服务提供者是提供服务的实体，而发布者的职责是发布服务记录，通过该服务记录来描述服务提供者的信息。服务提供者和发布者可以是同一个实体，也可以是不同的实体。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务消费者">服务消费者</h3>
<div class="paragraph">
<p>服务消费者在Service Discovery中搜索服务，每次搜索得到的结果是0..n条服务记录（
<code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ）。通过这些服务记录，消费者可以获得服务引用（
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> ）。服务引用的作用是绑定服务消费者和服务提供者。通过服务引用，消费者可以得到服务对象来使用服务，也可以通过服务引用释放服务对象。</p>
</div>
<div class="paragraph">
<p>在使用完服务后，必须释放服务引用，才能清理服务对象和更新服务使用状态。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务对象">服务对象</h3>
<div class="paragraph">
<p>服务对象为服务消费者提供了一条获取服务的通道，它有各种实现方式，比如一个代理对象、一个客户端对象、甚至某些类型的服务可能不存在这样一个服务对象。服务对象的表现有赖于服务的类型。</p>
</div>
<div class="paragraph">
<p>由于Vert.x的多语言特性，当你从Java、Groovy或其他语言中获取服务对象的时候，可能会有差异。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务类型">服务类型</h3>
<div class="paragraph">
<p>服务就是资源。有很多各种各样的服务，比如功能性的服务组件、数据库、REST API等等。Vert.x 服务发现组件通过服务类型的概念来处理这种差异。每种服务类型都需要定义：</p>
</div>
<div class="paragraph">
<p>+ 如何定位服务（URI、Event Bus地址、IP/DNS 等） - <strong>location</strong>
+ 提供服务的对象的性质（服务代理、HTTP Client、消息消费者 等） - <strong>client</strong></p>
</div>
<div class="paragraph">
<p>服务发现组件提供了一些现成的服务类型，但你也可以添加自己的服务类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务事件">服务事件</h3>
<div class="paragraph">
<p>每当发布或回收服务时，`Event Bus`中都会触发一个事件，这个事件包含着被修改的服务记录。</p>
</div>
<div class="paragraph">
<p>每当通过
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getReference-io.vertx.servicediscovery.Record-">getReference</a></code> 方法获取一个服务引用或者通过
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html#release--">release</a></code> 方法释放一个服务引用时，都会有事件发送到 Event Bus 中，用来跟踪服务的使用情况。</p>
</div>
<div class="paragraph">
<p>关于服务事件的更详细内容参考后续章节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_服务存储后端">服务存储后端</h3>
<div class="paragraph">
<p>服务发现组件使用Vert.x的分布式数据结构来存储服务记录。所以，集群中所有的成员都可以访问到所有的服务记录，这是服务后端的默认实现。
你也可以实现自己的服务记录存储后端，只要实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html">ServiceDiscoveryBackend</a></code> 接口就可以了。
比如，Vert.x还通过实现该接口提供了基于Redis的存储后端。</p>
</div>
<div class="paragraph">
<p>注意服务发现模块并不需要运行在Vert.x 集群模式下。在单机模式下，服务记录存储于本地，并且可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html">ServiceImporter</a></code> 来导入。
从 3.5.0 版本开始，你甚至可以在集群模式下采用本地结构储存，通过设置 <code>vertx-service-discovery-backend-local</code>
为 <code>true</code>(或者设置环境变量 <code>VERTX-SERVICE-DISCOVERY-BACKEND-LOCAL</code> 为 <code>true</code>)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_创建service_discovery实例">创建Service Discovery实例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>服务发布者和服务消费者都必须通过单独创建自己的 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html">ServiceDiscovery</a></code>
实例来使用服务发现模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery discovery = ServiceDiscovery.create(vertx);

// Customize the configuration
discovery = ServiceDiscovery.create(vertx,
    new ServiceDiscoveryOptions()
        .setAnnounceAddress("service-announce")
        .setName("my-name"));

// Do something...

discovery.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在默认情况下，服务事件发送到Event Bus中的地址是 <code>vertx.discovery.announce</code>，你可以自己配置一个（查看服务使用章节）。</p>
</div>
<div class="paragraph">
<p>当你不再需要 <code>ServiceDiscovery</code> 对象时，不要忘记关掉它（通过 <code>close</code> 方法）。它会把你配置的不同的服务导入/导出模块都关掉，并且释放服务引用。</p>
</div>
<div class="paragraph">
<p>你应该禁止在实例中共享 <code>ServiceDiscovery</code> 对象。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_发布服务">发布服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有了 <code>ServiceDiscovery</code> 实例，就可以发布服务了。发布的流程如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>为服务提供者创建一个服务记录</p>
</li>
<li>
<p>发布这个服务记录</p>
</li>
<li>
<p>保存这个发布记录的引用，后面可以用来取消发布或者修改发布</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>你可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 类或者各种服务类型类提供的快捷方法来创建服务记录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = new Record()
    .setType("eventbus-service-proxy")
    .setLocation(new JsonObject().put("endpoint", "the-service-address"))
    .setName("my-service")
    .setMetadata(new JsonObject().put("some-label", "some-value"));

discovery.publish(record, ar -&gt; {
  if (ar.succeeded()) {
    // publication succeeded
    Record publishedRecord = ar.result();
  } else {
    // publication failed
  }
});

// Record creation from a type
record = HttpEndpoint.createRecord("some-rest-api", "localhost", 8080, "/api");
discovery.publish(record, ar -&gt; {
  if (ar.succeeded()) {
    // publication succeeded
    Record publishedRecord = ar.result();
  } else {
    // publication failed
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>一定要保持一个指向服务记录对象的引用，因为这个返回的服务记录会带有一个 <strong>注册ID</strong>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_取消发布的服务">取消发布的服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要取消一个已发布的服务，可以用如下方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.unpublish(record.getRegistration(), ar -&gt; {
  if (ar.succeeded()) {
    // Ok
  } else {
    // cannot un-publish the service, may have already been removed, or the record is not published
  }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_查找服务">查找服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>本节讲述的是最基本的获取服务的方法。每种服务类型接口，都提供了快捷的方法，来简化获取服务的步骤。</strong></p>
</div>
<div class="paragraph">
<p>在服务消费端，第一步要做的事情就是查找服务记录。你可以查找并获取一条服务记录，也可以获取一批满足条件的记录。如果是获取一条记录，那么将返回第一条满足条件的服务记录。</p>
</div>
<div class="paragraph">
<p>服务消费者通过传递一个过滤器来选择服务，有两种形式的过滤器：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一个接收 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 对象的函数，这个函数返回一个布尔值（就是一个 <code>predicate</code>，即判断函数）</p>
</li>
<li>
<p>过滤器是一个JSON对象。对象中的每个条目，将会用来过滤服务记录。服务记录必须满足所有的条目要求。这些条目可以使用 <code>*</code> 号来代表必须存在某个key值，而不管value值</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>让我们看一些JSON过滤器的例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{ "name" = "a" } =&gt; 匹配所有名称为"a"的记录
{ "color" = "*" } =&gt; 匹配所有设置了 "color" 的记录
{ "color" = "red" } =&gt; 匹配所有"color" 值为 "red"的记录
{ "color" = "red", "name" = "a"} =&gt; 匹配所有名称为 "a", 并且"color"值为"red"的记录</pre>
</div>
</div>
<div class="paragraph">
<p>如果JSON过滤器未设置（为空或 <code>null</code> ），获取时将获取到所有的服务记录。当使用函数形式时，要获取所有的服务记录，你只需要返回 <code>true</code> 而不需要管服务记录的内容。</p>
</div>
<div class="paragraph">
<p>下面是一些例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(r -&gt; true, ar -&gt; {
  if (ar.succeeded()) {
    if (ar.result() != null) {
      // we have a record
    } else {
      // the lookup succeeded, but no matching service
    }
  } else {
    // lookup failed
  }
});

discovery.getRecord((JsonObject) null, ar -&gt; {
  if (ar.succeeded()) {
    if (ar.result() != null) {
      // we have a record
    } else {
      // the lookup succeeded, but no matching service
    }
  } else {
    // lookup failed
  }
});


// Get a record by name
discovery.getRecord(r -&gt; r.getName().equals("some-name"), ar -&gt; {
  if (ar.succeeded()) {
    if (ar.result() != null) {
      // we have a record
    } else {
      // the lookup succeeded, but no matching service
    }
  } else {
    // lookup failed
  }
});

discovery.getRecord(new JsonObject().put("name", "some-service"), ar -&gt; {
  if (ar.succeeded()) {
    if (ar.result() != null) {
      // we have a record
    } else {
      // the lookup succeeded, but no matching service
    }
  } else {
    // lookup failed
  }
});

// Get all records matching the filter
discovery.getRecords(r -&gt; "some-value".equals(r.getMetadata().getString("some-label")), ar -&gt; {
  if (ar.succeeded()) {
    List&lt;Record&gt; results = ar.result();
    // If the list is not empty, we have matching record
    // Else, the lookup succeeded, but no matching service
  } else {
    // lookup failed
  }
});


discovery.getRecords(new JsonObject().put("some-label", "some-value"), ar -&gt; {
  if (ar.succeeded()) {
    List&lt;Record&gt; results = ar.result();
    // If the list is not empty, we have matching record
    // Else, the lookup succeeded, but no matching service
  } else {
    // lookup failed
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以获取一条服务记录，也可以通过
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-io.vertx.core.json.JsonObject-io.vertx.core.Handler-">getRecords</a></code>
方法获取所有匹配到的服务记录。默认情况下，服务查找只会包含状态为`UP`的服务，可以通过如下方式覆盖默认设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当使用JSON过滤器，设置`status`属性为你想要的值（或者 <code>*</code> 来接收所有的状态）</p>
</li>
<li>
<p>当使用函数过滤器，将 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#getRecords-java.util.function.Function-boolean-io.vertx.core.Handler-">getRecords</a></code> 方法的参数`includeOutOfService`设置为`true`</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_获取服务引用">获取服务引用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你选择好了服务记录( <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 对象)后，你就可以获得到一个
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> ，然后得到服务对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceReference reference1 = discovery.getReference(record1);
ServiceReference reference2 = discovery.getReference(record2);

// Then, gets the service object, the returned type depends on the service type:
// For http endpoint:
HttpClient client = reference1.getAs(HttpClient.class);
// For message source
MessageConsumer consumer = reference2.getAs(MessageConsumer.class);

// When done with the service
reference1.release();
reference2.release();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>使用完后，不要忘记释放服务引用。</strong></p>
</div>
<div class="paragraph">
<p>服务引用代表了一个绑定的服务提供者。</p>
</div>
<div class="paragraph">
<p>获取服务引用的时候，可以传递一个 <code><a href="../../apidocs/io/vertx/core/json/JsonObject.html">JsonObject</a></code> 对象来配置服务对象，可以包括用来配置服务对象的各种参数。某些服务类型不需要额外的配置，有些需要（比如数据库对象）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceReference reference = discovery.getReferenceWithConfiguration(record, conf);

// Then, gets the service object, the returned type depends on the service type:
// For http endpoint:
JDBCClient client = reference.getAs(JDBCClient.class);

// Do something with the client...

// When done with the service
reference.release();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，代码中使用的是
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html#getAs-java.lang.Class-">getAs</a></code> 方法，参数是你期望获得的对象类型。如果你使用Java语言，那么可以直接用
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html#get--">get</a></code> 方法，而其他语言中，你必须传递对象类型。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_服务类型_2">服务类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前面提到，服务发现使用了服务类型的概念，来封装各种服务的差异性。</p>
</div>
<div class="paragraph">
<p>目前服务发现组件提供了几种默认的服务类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html">HttpEndpoint</a></code> - 为REST API服务提供的类型，服务对象的类型是一个配置好了host和port的 <code><a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a></code> （其location表现为一个url）</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> - 服务代理，服务对象是一个代理，它的类型是所代理的接口（其location表现为一个Event Bus的address地址）</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> - 消息源服务，服务对象的类型是一个 <code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html">MessageConsumer</a></code> （其location表现为一个Event Bus的address地址）</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html">JDBCDataSource</a></code> - JDBC数据源服务，服务对象的类型是一个 <code><a href="../../apidocs/io/vertx/ext/jdbc/JDBCClient.html">JDBCClient</a></code> （该Client的配置参数，将从location、元数据和服务消费者传递的参数中获取）</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html">RedisDataSource</a></code> - Redis数据源服务，服务对象的类型是一个 <code><a href="../../apidocs/io/vertx/redis/RedisClient.html">RedisClient</a></code> （该client的配置参数，将从location、元数据和服务消费者传递的参数中获取）</p>
</li>
<li>
<p><code><a href="../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html">MongoDataSource</a></code> - Mongo数据源服务，服务对象的类型一个 <code><a href="../../apidocs/io/vertx/ext/mongo/MongoClient.html">MongoClient</a></code> （该client的配置参数，将从location、元数据和服务消费者传递的参数中获取）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节将详细介绍一下服务类型，以及如何使用服务发现框架已提供的几种服务类型。</p>
</div>
<div class="sect2">
<h3 id="_无类型的服务">无类型的服务</h3>
<div class="paragraph">
<p>某些服务记录也可以不带有类型( <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html#UNKNOWN">ServiceType.UNKNOWN</a></code> )。通过这种服务记录，是无法获取到服务引用的，但是你可以通过服务记录（ <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ）的`location`和`metadata`来创建连接的细节。</p>
</div>
<div class="paragraph">
<p>使用这种服务，将不会产生服务使用的事件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自定义的服务类型">自定义的服务类型</h3>
<div class="paragraph">
<p>通过实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html">ServiceType</a></code> SPI接口，可以自定义服务类型：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>（可选）创建一个继承了 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html">ServiceType</a>`的公共接口。
在这个接口中，仅需要提供一些辅助方法，来简化自定义类型的使用，比如提供 `createRecord</code> 方法
以及 <code>getX</code> 方法（这里的`X`指的是将返回的服务对象的类型）等等。可以查看 <code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html">HttpEndpoint</a></code> 和
<code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 等接口例子来了解这种设计。</p>
</li>
<li>
<p>创建一个实现了 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceType.html">ServiceType</a></code> 接口或者第一步定义的接口的类，这个类必须有一个 <code>name</code> 方法
和一个用来创建 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceReference.html">ServiceReference</a></code> 的方法，这个 <code>name</code> 方法返回的名称，
要和关联到自定义类型的 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 的 <code>type</code> 属性一致。</p>
</li>
<li>
<p>创建一个继承`io.vertx.ext.discovery.types.AbstractServiceReference`的类。你可以对类进行参数化，添加上你要返回的服务对象的类型信息，
你必须实现`AbstractServiceReference#retrieve()`这个方法，在这个方法中创建服务对象，这个方法只会被调用一次，如果你的服务对象需要释放资源，那另外还需要覆写 `AbstractServiceReference#close()`方法。</p>
</li>
<li>
<p>创建 <code>META-INF/services/io.vertx.servicediscovery.spi.ServiceType</code> 文件，并把这个文件打包到自定义类型的jar包中，在这个文件中，需要标明第二步中所创建类的全限定名。</p>
</li>
<li>
<p>将第一步的服务接口、第二步第三步的实现类以及第四步中的服务描述文件打包成一个jar包，然后将这个jar包放到你应用的 <code>classpath</code> 中。然后，这个自定义类型就可以使用了。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_http_endpoints">HTTP endpoints</h3>
<div class="paragraph">
<p>一个 HTTP 端点(endpoint)，就是一个REST API或可以通过HTTP请求访问的服务。HTTP Endpoint服务对象就是一个配置了host、port和ssl的 `<a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a>`对象。</p>
</div>
<div class="sect3">
<h4 id="_发布http_endpoint服务">发布HTTP Endpoint服务</h4>
<div class="paragraph">
<p>要发布一个HTTP Endpoint服务，你需要一个 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 对象。你可以通过调用
<code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#createRecord-java.lang.String-java.lang.String-int-java.lang.String-io.vertx.core.json.JsonObject-">HttpEndpoint.createRecord</a></code> 创建这样一个服务记录对象。</p>
</div>
<div class="paragraph">
<p>下面的代码片段，展示了如何通过 <code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html">HttpEndpoint</a></code> 接口创建一个 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record1 = HttpEndpoint.createRecord(
  "some-http-service", // The service name
  "localhost", // The host
  8433, // the port
  "/api" // the root of the service
);

discovery.publish(record1, ar -&gt; {
  // ...
});

Record record2 = HttpEndpoint.createRecord(
  "some-other-name", // the service name
  true, // whether or not the service requires HTTPs
  "localhost", // The host
  8433, // the port
  "/api", // the root of the service
  new JsonObject().put("some-metadata", "some value")
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你在容器或云上部署你的服务时，可能你不能确定公开的IP地址和端口。所以，服务的发布必须通过其他拥有这些信息的实体来进行，这通常是一个桥接对象（bridge）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_调用http_endpoint服务">调用HTTP Endpoint服务</h4>
<div class="paragraph">
<p>一旦一个HTTP Endpoint服务发布好了，服务消费者就可以获取到这个服务。对应的服务对象是一个
<code><a href="../../apidocs/io/vertx/core/http/HttpClient.html">HttpClient</a></code> 实例，并且已经配置好了host和port参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(new JsonObject().put("name", "some-http-service"), ar -&gt; {
  if (ar.succeeded() &amp;&amp; ar.result() != null) {
    // Retrieve the service reference
    ServiceReference reference = discovery.getReference(ar.result());
    // Retrieve the service object
    HttpClient client = reference.getAs(HttpClient.class);

    // You need to path the complete path
    client.getNow("/api/persons", response -&gt; {

      // ...

      // Dont' forget to release the service
      reference.release();

    });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以使用
<code><a href="../../apidocs/io/vertx/servicediscovery/types/HttpEndpoint.html#getClient-io.vertx.servicediscovery.ServiceDiscovery-io.vertx.core.json.JsonObject-io.vertx.core.Handler-">HttpEndpoint.getClient</a></code>
这个方法，一步就完成服务查找和服务获取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpEndpoint.getClient(discovery, new JsonObject().put("name", "some-http-service"), ar -&gt; {
  if (ar.succeeded()) {
    HttpClient client = ar.result();

    // You need to path the complete path
    client.getNow("/api/persons", response -&gt; {

      // ...

      // Dont' forget to release the service
      ServiceDiscovery.releaseServiceObject(discovery, client);

    });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二种写法中，服务对象的释放是通过
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#releaseServiceObject-io.vertx.servicediscovery.ServiceDiscovery-java.lang.Object-">ServiceDiscovery.releaseServiceObject</a></code>
这个方法完成的，因此在这种情况下你是不需要持有一个服务引用的。</p>
</div>
<div class="paragraph">
<p>从Vert.x 3.4.0开始，Vert.x提供了另一种更高层次封装、更方便使用的HTTP客户端 — <code><a href="../../apidocs/io/vertx/ext/web/client/WebClient.html">WebClient</a></code> 。
你可以通过如下方式来获取一个 <code><a href="../../apidocs/io/vertx/ext/web/client/WebClient.html">WebClient</a></code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(new JsonObject().put("name", "some-http-service"), ar -&gt; {
  if (ar.succeeded() &amp;&amp; ar.result() != null) {
    // Retrieve the service reference
    ServiceReference reference = discovery.getReference(ar.result());
    // Retrieve the service object
    WebClient client = reference.getAs(WebClient.class);

    // You need to path the complete path
    client.get("/api/persons").send(
      response -&gt; {

        // ...

        // Dont' forget to release the service
        reference.release();

      });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外一种写法，通过对应的服务类型接口获取的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpEndpoint.getWebClient(discovery, new JsonObject().put("name", "some-http-service"), ar -&gt; {
  if (ar.succeeded()) {
    WebClient client = ar.result();

    // You need to path the complete path
    client.get("/api/persons")
      .send(response -&gt; {

        // ...

        // Dont' forget to release the service
        ServiceDiscovery.releaseServiceObject(discovery, client);

      });
  }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_event_bus_服务">Event Bus 服务</h3>
<div class="paragraph">
<p>Event Bus 服务是一种服务代理，是基于Event Bus实现的一种异步RPC服务。当从一个Event Bus服务中获取一个服务对象时，你实际上得到的某个服务类的服务代理。你也可以使用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> 接口的辅助方法来获得服务代理。</p>
</div>
<div class="paragraph">
<p>注意服务代理（服务实现和服务接口）都需要用Java语言开发。</p>
</div>
<div class="sect3">
<h4 id="_发布event_bus_服务">发布Event Bus 服务</h4>
<div class="paragraph">
<p>要发布一个Event Bus服务，你需要创建一个 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = EventBusService.createRecord(
    "some-eventbus-service", // The service name
    "address", // the service address,
    "examples.MyService", // the service interface as string
    new JsonObject()
        .put("some-metadata", "some value")
);

discovery.publish(record, ar -&gt; {
  // ...
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以直接传递服务接口类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = EventBusService.createRecord(
"some-eventbus-service", // The service name
"address", // the service address,
MyService.class // the service interface
);

discovery.publish(record, ar -&gt; {
// ...
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_调用_event_bus_服务">调用 Event Bus 服务</h4>
<div class="paragraph">
<p>要调用（消费）Event Bus服务，你可以通过先获取到服务记录然后获取服务引用的方式，也可以直接通过
<code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> 接口，将两步合并成一次方法调用。</p>
</div>
<div class="paragraph">
<p>当使用服务引用的方式，你需要如下方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(new JsonObject().put("name", "some-eventbus-service"), ar -&gt; {
if (ar.succeeded() &amp;&amp; ar.result() != null) {
// Retrieve the service reference
ServiceReference reference = discovery.getReference(ar.result());
// Retrieve the service object
MyService service = reference.getAs(MyService.class);

// Dont' forget to release the service
reference.release();
}
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/EventBusService.html">EventBusService</a></code> 接口时，你可以通过如下方式获得代理对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EventBusService.getProxy(discovery, MyService.class, ar -&gt; {
if (ar.succeeded()) {
MyService service = ar.result();

// Dont' forget to release the service
ServiceDiscovery.releaseServiceObject(discovery, service);
}
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_消息源服务">消息源服务</h3>
<div class="paragraph">
<p>消息源服务，就是通过Event Bus发送消息到某个地址的组件。消息源服务的Client是
<code><a href="../../apidocs/io/vertx/core/eventbus/MessageConsumer.html">MessageConsumer</a></code> 。</p>
</div>
<div class="paragraph">
<p>消息源服务的 <code>location</code> 是消息所发送的Event Bus 地址。</p>
</div>
<div class="sect3">
<h4 id="_发布消息源服务">发布消息源服务</h4>
<div class="paragraph">
<p>和其他服务类型一样，发布一个消息源服务包含两个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 接口创建一条服务记录</p>
</li>
<li>
<p>发布这条服务记录</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = MessageSource.createRecord(
    "some-message-source-service", // The service name
    "some-address" // The event bus address
);

discovery.publish(record, ar -&gt; {
  // ...
});

record = MessageSource.createRecord(
    "some-other-message-source-service", // The service name
    "some-address", // The event bus address
    "examples.MyData" // The payload type
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二个 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 创建时，我们同时指明了消息体（payload）的类型，这不是必须的。</p>
</div>
<div class="paragraph">
<p>在Java中，你可以使用 <code><a href="../../apidocs/java/lang/Class.html">Class</a></code> 类型的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record1 = MessageSource.createRecord(
"some-message-source-service", // The service name
"some-address", // The event bus address
JsonObject.class // The message payload type
);

Record record2 = MessageSource.createRecord(
"some-other-message-source-service", // The service name
"some-address", // The event bus address
JsonObject.class, // The message payload type
new JsonObject().put("some-metadata", "some value")
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_消费消息源服务">消费消息源服务</h4>
<div class="paragraph">
<p>在服务消费端，你可以手动获取服务记录和服务引用，也可以使用
<code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 接口提供的辅助方法直接获取。</p>
</div>
<div class="paragraph">
<p>第一种方式对应的代码示例如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(new JsonObject().put("name", "some-message-source-service"), ar -&gt; {
  if (ar.succeeded() &amp;&amp; ar.result() != null) {
    // Retrieve the service reference
    ServiceReference reference = discovery.getReference(ar.result());
    // Retrieve the service object
    MessageConsumer&lt;JsonObject&gt; consumer = reference.getAs(MessageConsumer.class);

    // Attach a message handler on it
    consumer.handler(message -&gt; {
      // message handler
      JsonObject payload = message.body();
    });
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MessageSource.html">MessageSource</a></code> 接口，代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MessageSource.&lt;JsonObject&gt;getConsumer(discovery, new JsonObject().put("name", "some-message-source-service"), ar -&gt; {
  if (ar.succeeded()) {
    MessageConsumer&lt;JsonObject&gt; consumer = ar.result();

    // Attach a message handler on it
    consumer.handler(message -&gt; {
      // message handler
      JsonObject payload = message.body();
    });
    // ...
  }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jdbc_数据源">JDBC 数据源</h3>
<div class="paragraph">
<p>数据源指的是数据库或数据存储。JDBC数据源通过JDBC驱动访问数据库，JDBC数据源服务对象是是 <code><a href="../../apidocs/io/vertx/ext/jdbc/JDBCClient.html">JDBCClient</a></code> 实例。</p>
</div>
<div class="sect3">
<h4 id="_发布_jdbc_数据源服务">发布 JDBC 数据源服务</h4>
<div class="paragraph">
<p>和其他服务类型一样，发布 JDBC 数据源服务共两个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code><a href="../../apidocs/io/vertx/servicediscovery/types/JDBCDataSource.html">JDBCDataSource</a></code> 接口创建服务记录</p>
</li>
<li>
<p>发布服务记录</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = JDBCDataSource.createRecord(
    "some-data-source-service", // The service name
    new JsonObject().put("url", "some jdbc url"), // The location
    new JsonObject().put("some-metadata", "some-value") // Some metadata
);

discovery.publish(record, ar -&gt; {
  // ...
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>JDBC 数据源可以代表各种类型的数据库，而这些数据库的访问方式一般是不同的，服务记录很难有统一结构。在服务记录中，<code>location</code> 由一个简单的JSON对象组成，里面包含访问数据源的各种属性（JDBC URL、用户名、密码等）。这些属性既依赖于数据库，同时也依赖于所使用的连接池。</p>
</div>
</div>
<div class="sect3">
<h4 id="_消费_jdbc_数据源服务">消费 JDBC 数据源服务</h4>
<div class="paragraph">
<p>如前所述，访问数据源的方式依赖于数据源本身。要创建一个
<code><a href="../../apidocs/io/vertx/ext/jdbc/JDBCClient.html">JDBCClient</a></code> ，你需要同时提供：服务记录位置信息、元数据以及服务消费者提供的JSON对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(
    new JsonObject().put("name", "some-data-source-service"),
    ar -&gt; {
      if (ar.succeeded() &amp;&amp; ar.result() != null) {
        // Retrieve the service reference
        ServiceReference reference = discovery.getReferenceWithConfiguration(
            ar.result(), // The record
            new JsonObject().put("username", "clement").put("password", "*****")); // Some additional metadata

        // Retrieve the service object
        JDBCClient client = reference.getAs(JDBCClient.class);

        // ...

        // when done
        reference.release();
      }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以使用 <code>JDBCDataSource</code> 接口的辅助方法，来查询和获取服务对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JDBCDataSource.&lt;JsonObject&gt;getJDBCClient(discovery,
    new JsonObject().put("name", "some-data-source-service"),
    new JsonObject().put("username", "clement").put("password", "*****"), // Some additional metadata
    ar -&gt; {
      if (ar.succeeded()) {
        JDBCClient client = ar.result();

        // ...

        // Dont' forget to release the service
        ServiceDiscovery.releaseServiceObject(discovery, client);

      }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_redis_数据源">Redis 数据源</h3>
<div class="paragraph">
<p>Redis 数据源服务是专门为Redis提供的服务类型，对应服务对象是 <code><a href="../../apidocs/io/vertx/redis/RedisClient.html">RedisClient</a></code> 。</p>
</div>
<div class="sect3">
<h4 id="_发布_redis_数据源服务">发布 Redis 数据源服务</h4>
<div class="paragraph">
<p>发布一个 Redis 数据源服务共两个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code><a href="../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html">RedisDataSource</a></code> 接口创建一条服务记录</p>
</li>
<li>
<p>发布这个服务记录</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = RedisDataSource.createRecord(
  "some-redis-data-source-service", // The service name
  new JsonObject().put("url", "localhost"), // The location
  new JsonObject().put("some-metadata", "some-value") // Some metadata
);

discovery.publish(record, ar -&gt; {
  // ...
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>location</code> 是一个JSON对象，包含访问Redis数据源的属性（URL、端口等）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_消费_redis_数据源服务">消费 Redis 数据源服务</h4>
<div class="paragraph">
<p>如前所述，访问数据源的方式依赖于数据源本身。要创建一个
<code><a href="../../apidocs/io/vertx/redis/RedisClient.html">RedisClient</a></code> ，你需要同时提供：服务记录位置信息、元数据以及服务消费者提供的JSON对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(
  new JsonObject().put("name", "some-redis-data-source-service"), ar -&gt; {
    if (ar.succeeded() &amp;&amp; ar.result() != null) {
      // Retrieve the service reference
      ServiceReference reference = discovery.getReference(ar.result());

      // Retrieve the service instance
      RedisClient client = reference.getAs(RedisClient.class);

      // ...

      // when done
      reference.release();
    }
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以利用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/RedisDataSource.html">RedisDataSource</a></code> 接口的辅助方法来查询和获取服务对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisDataSource.getRedisClient(discovery,
  new JsonObject().put("name", "some-redis-data-source-service"),
  ar -&gt; {
    if (ar.succeeded()) {
      RedisClient client = ar.result();

      // ...

      // Dont' forget to release the service
      ServiceDiscovery.releaseServiceObject(discovery, client);

    }
  });</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mongo_数据源">Mongo 数据源</h3>
<div class="paragraph">
<p>Mongo 数据源服务是专门为 MongoDB 提供的一种服务类型，对应的服务对象是 <code><a href="../../apidocs/io/vertx/ext/mongo/MongoClient.html">MongoClient</a></code> 。</p>
</div>
<div class="sect3">
<h4 id="_发布_mongo_数据源服务">发布 Mongo 数据源服务</h4>
<div class="paragraph">
<p>发布一个 Mongo 数据源服务需要两步：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html">MongoDataSource</a></code> 接口创建一条服务记录</p>
</li>
<li>
<p>发布这条服务记录</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Record record = MongoDataSource.createRecord(
  "some-data-source-service", // The service name
  new JsonObject().put("connection_string", "some mongo connection"), // The location
  new JsonObject().put("some-metadata", "some-value") // Some metadata
);

discovery.publish(record, ar -&gt; {
  // ...
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中`location`是一个JSON对象，包含了访问Mongo数据源的所有属性（URL、端口等）</p>
</div>
</div>
<div class="sect3">
<h4 id="_消费_mongo_数据源服务">消费 Mongo 数据源服务</h4>
<div class="paragraph">
<p>如前所述，访问数据源的方式依赖于数据源本身。要创建一个
<code><a href="../../apidocs/io/vertx/ext/mongo/MongoClient.html">MongoClient</a></code> ，你需要同时提供：服务记录位置信息、元数据以及服务消费者提供的JSON对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">discovery.getRecord(
  new JsonObject().put("name", "some-data-source-service"),
  ar -&gt; {
    if (ar.succeeded() &amp;&amp; ar.result() != null) {
      // Retrieve the service reference
      ServiceReference reference = discovery.getReferenceWithConfiguration(
        ar.result(), // The record
        new JsonObject().put("username", "clement").put("password", "*****")); // Some additional metadata

      // Retrieve the service object
      MongoClient client = reference.get();

      // ...

      // when done
      reference.release();
    }
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以利用 <code><a href="../../apidocs/io/vertx/servicediscovery/types/MongoDataSource.html">MongoDataSource</a></code> 接口中的辅助方法来完成服务对象的查找和获取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MongoDataSource.&lt;JsonObject&gt;getMongoClient(discovery,
  new JsonObject().put("name", "some-data-source-service"),
  new JsonObject().put("username", "clement").put("password", "*****"), // Some additional metadata
  ar -&gt; {
    if (ar.succeeded()) {
      MongoClient client = ar.result();

      // ...

      // Dont' forget to release the service
      ServiceDiscovery.releaseServiceObject(discovery, client);

    }
  });</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_监听服务的上线与下线">监听服务的上线与下线</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每当服务发布或者取消发布，都会有相应的事件发送到 <code>vertx.discovery.announce</code> 这个地址。这个地址可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html">ServiceDiscoveryOptions</a></code> 配置。</p>
</div>
<div class="paragraph">
<p>收到的`Record`中有个`status`字段，用来表示服务的状态：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UP</code> : 服务已经可以使用了</p>
</li>
<li>
<p><code>DOWN</code> : 服务不再可用</p>
</li>
<li>
<p><code>OUT_OF_SERVICE</code> : 服务目前不可用，但是过段时间会继续提供服务。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_监听服务的使用">监听服务的使用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每当有一个服务引用被绑定或者被释放，都会有相应的事件发送到 <code>vertx.discovery.usage</code> 这个地址。这个地址可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html">ServiceDiscoveryOptions</a></code> 配置。</p>
</div>
<div class="paragraph">
<p>通过这个事件，可以监听服务的使用和服务的映射。</p>
</div>
<div class="paragraph">
<p>收到的消息是一个包含如下内容的 <code><a href="../../apidocs/io/vertx/core/json/JsonObject.html">JsonObject</a></code> 对象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>record</code> 属性中，包含了服务记录信息</p>
</li>
<li>
<p>在 <code>type</code> 属性中记录了事件的类型，类型分为`bind`和`release`</p>
</li>
<li>
<p>在 <code>id</code> 属性中记录了服务发现实例的ID（服务发现实例的名称或节点ID）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其中 <code>id</code> 可以通过 <code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html">ServiceDiscoveryOptions</a></code> 进行配置。默认情况下，在单节点时它的值是`localhost`，在集群模式时是节点的ID。</p>
</div>
<div class="paragraph">
<p>你也可以通过
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscoveryOptions.html#setUsageAddress-java.lang.String-">setUsageAddress</a></code> 方法，将事件发送地址设置为`null`，这样就可以禁用服务使用情况的监听功能了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_服务发现桥接器">服务发现桥接器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过桥接器（bridge），你可以从其他服务发现组件中导入和导出服务，比如Docker，Kubernetes，Consul等。每种类型的桥接器，决定了服务如何导入和导出，并且不一定都是双向的。</p>
</div>
<div class="paragraph">
<p>要想自定义桥接器，你可以通过实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html">ServiceImporter</a></code> 接口，然后再使用
<code><a href="../../apidocs/io/vertx/servicediscovery/ServiceDiscovery.html#registerServiceImporter-io.vertx.servicediscovery.spi.ServiceImporter-io.vertx.core.json.JsonObject-">registerServiceImporter</a></code>
方法注册一下。</p>
</div>
<div class="paragraph">
<p>你可以通过第二个参数传递一些可选的配置信息给桥接器。</p>
</div>
<div class="paragraph">
<p>当桥接器注册后，
<code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html">#start)</a></code>
方法将会被调用，这样你可以对桥接器进行一些配置。当桥接器配置好了，已经准备导入导出初始的服务时，必须 <code>complete</code> 所传递的 <code><a href="../../apidocs/io/vertx/core/Future.html">Future</a></code> 。如果桥接器的启动方法是阻塞型的，那么就必须使用
<code><a href="../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-">executeBlocking</a></code> 方法进行封装，并且`complete`所传递的 <code><a href="../../apidocs/io/vertx/core/Future.html">Future</a></code> 对象。</p>
</div>
<div class="paragraph">
<p>当服务发现实例被关闭的时候，对应的桥接器也一块被关闭了。执行关闭操作的时候，服务发现组件会调用
<code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceImporter.html#close-io.vertx.core.Handler-">close</a></code>
方法以进行资源的释放以及移除导入/导出的服务。这个方法必须调用所传递的
<code><a href="../../apidocs/io/vertx/core/Future.html">Future</a></code> 的`complete`方法，来通知调用者关闭操作已经完成。</p>
</div>
<div class="paragraph">
<p>需要提醒的是，在一个集群中，只需要有一个节点注册了服务桥接器，集群中所有成员就都能使用了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_其他服务发现桥接器">其他服务发现桥接器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x 服务发现组件除了支持桥接器机制以外，还提供了一些现成的桥接器。</p>
</div>
<div class="sect2">
<h3 id="_consul_桥接器">Consul 桥接器</h3>
<div class="paragraph">
<p>Consul 桥接器可以将 <a href="http://consul.io">Consul</a> 中的服务导入到Vert.x的服务发现组件中。
这个桥接器可以连接 Consul agent（服务器），并且会进行周期性的扫描，来更新服务情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新的服务被导入</p>
</li>
<li>
<p>维护模式下的服务或已经从 Consul 中移除的服务将会被移除</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个桥接器使用的是 Consul 的HTTP API接口。它不能将服务导出到Consul，并且也不支持服务的修改。</p>
</div>
<div class="paragraph">
<p>服务的类型是通过`tags`推断出来的，如果有一个`tag`和已知的服务类型一样，那么就使用这种服务类型，如果没有匹配的，那么服务导入后将标记为`unknown`类型。目前暂时只支持`http-endpoint`类型。</p>
</div>
<div class="sect3">
<h4 id="_桥接器的使用">桥接器的使用</h4>
<div class="paragraph">
<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在 <code>pox.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
 &lt;groupId&gt;io.vertx&lt;/groupId&gt;
 &lt;artifactId&gt;vertx-service-discovery-bridge-consul&lt;/artifactId&gt;
 &lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在 <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile 'io.vertx:vertx-service-discovery-bridge-consul:3.6.0'</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在创建服务发现对象的时候，像下面这样注册桥接器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx)
    .registerServiceImporter(new ConsulServiceImporter(),
        new JsonObject()
            .put("host", "localhost")
            .put("port", 8500)
            .put("scan-period", 2000));</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以做一些配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>host</code> 属性，配置 agent 的地址，默认是`localhost`</p>
</li>
<li>
<p><code>port</code> 属性，配置 agent 的端口，默认的端口是 8500</p>
</li>
<li>
<p><code>acl_token</code> 属性，配置 agent 的访问控制令牌，默认值是 null</p>
</li>
<li>
<p><code>scan-period</code> 属性，配置扫描的频率，扫描的单位是毫秒（ms），默认是 2000 ms</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_kubernetes_桥接器">Kubernetes 桥接器</h3>
<div class="paragraph">
<p>Kubernetes 桥接器可以从Kubernetes（或者 Openshift v3）中导入服务到Vert.x的服务发现组件中。
Kubernetes的所有服务，都将映射为一条 <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> 。目前桥接器只支持将服务从Kubernetes中导入到Vert.x中（反过来不行）。</p>
</div>
<div class="paragraph">
<p>Kubernetes中的服务，在导入到Vert.x后都会创建对应的服务记录（ <code><a href="../../apidocs/io/vertx/servicediscovery/Record.html">Record</a></code> ）。
服务类型是通过 <code>service.type.lable</code> 推断出来的。如果该属性没有设置，那么服务类型被设置为`unknown`。目前暂时只支持 <code>http-endpoint</code> 服务类型。</p>
</div>
<div class="sect3">
<h4 id="_桥接器的使用_2">桥接器的使用</h4>
<div class="paragraph">
<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在 <code>pox.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
 &lt;groupId&gt;io.vertx&lt;/groupId&gt;
 &lt;artifactId&gt;vertx-service-discovery-bridge-kubernetes&lt;/artifactId&gt;
 &lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在 <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile 'io.vertx:vertx-service-discovery-bridge-kubernetes:3.6.0'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_桥接器的配置">桥接器的配置</h4>
<div class="paragraph">
<p>桥接器的配置项有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OAuth token（默认是使用`/var/run/secrets/kubernetes.io/serviceaccount/token`中的内容）</p>
</li>
<li>
<p>服务搜索的命名空间（默认是`default`）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，应用程序必须能够访问 Kubernetes 并且能够读取所选择的命名空间。</p>
</div>
</div>
<div class="sect3">
<h4 id="_服务记录的映射">服务记录的映射</h4>
<div class="paragraph">
<p>服务记录按照如下的步骤进行创建：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从 <code>service.type</code> 中推断出服务类型；如果没有设置，那么服务类型被设置为`unknown`</p>
</li>
<li>
<p>服务记录的名称就是服务的名称</p>
</li>
<li>
<p>服务的标签（label）都被映射为服务记录的元数据</p>
</li>
<li>
<p>此外还会加上：<code>kubernetes.uuid, kubernetes.namespace, kubernetes.name</code></p>
</li>
<li>
<p>`location`信息将从服务的第一个端口推断出来</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于 HTTP 端点，如果服务带有`ssl`标签的话，那么服务记录的`ssl`(<code>https</code>)属性将被设置为`true`。</p>
</div>
</div>
<div class="sect3">
<h4 id="_动态性">动态性</h4>
<div class="paragraph">
<p>Kubernetes 桥接器将会在启动(<code>start</code>)的时候导入所有的服务，在停止(<code>stop</code>)的时候移除所有的服务。在运行期间，它将监听 Kubernetes 的服务，并且动态地导入新加入的服务，移除被删除的服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_supported_types">Supported types</h4>
<div class="paragraph">
<p>The bridge uses the <code>service-type</code> label to induce the type. In addition it checks the port of the service. Are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ports 80, 443 and from 8080 to 9000: HTTP endpoint</p>
</li>
<li>
<p>ports 5432 and 5433: JDBC data source (PostGreSQL)</p>
</li>
<li>
<p>ports 3306 and 13306: JDBC data source (MySQL)</p>
</li>
<li>
<p>port 6379: Redis data source</p>
</li>
<li>
<p>ports 27017, 27018 and 27019: MongoDB data source</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If present, the <code>service-type</code> overrides the port-based deduction.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in index.adoc - include::zookeeper-bridge.adoc[]</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_docker_links_桥接器">Docker Links 桥接器</h3>
<div class="paragraph">
<p>Docker Links 桥接器可以从 Docker Links 中导入服务到 Vert.x 的服务发现组件中。当你将一个Docker容器与另外一个Docker容器链接在一起(link)的时候，Docker将会注入一组环境变量。该桥接器将分析这些环境变量，并且针对每个链接(link)，生成一个服务记录。服务记录的类型从`service.type.lable`属性中推断；如果没有设置，那么服务类型将被设置为`unknown`。目前暂时只支持 <code>http-endpoint</code> 服务类型。</p>
</div>
<div class="paragraph">
<p>由于Docker容器只在启动的时候创建链接，所以这个桥接器只会在启动的时候导入服务记录，然后此后就都不改变了。</p>
</div>
<div class="sect3">
<h4 id="_桥接器的使用_3">桥接器的使用</h4>
<div class="paragraph">
<p>要使用该服务发现桥接器，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在 <code>pox.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
 &lt;groupId&gt;io.vertx&lt;/groupId&gt;
 &lt;artifactId&gt;vertx-service-discovery-bridge-docker&lt;/artifactId&gt;
 &lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在 <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile 'io.vertx:vertx-service-discovery-bridge-docker:3.6.0'</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在创建服务发现对象的时候，像下面这样注册桥接器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx)
    .registerServiceImporter(new DockerLinksServiceImporter(), new JsonObject());</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种桥接器不需要任何进一步的配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_其他存储后端">其他存储后端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x服务发现框架还提供了一些现成的后端存储机制支持。</p>
</div>
<div class="sect2">
<h3 id="_redis_存储后端">Redis 存储后端</h3>
<div class="paragraph">
<p>服务发现组件通过实现 <code><a href="../../apidocs/io/vertx/servicediscovery/spi/ServiceDiscoveryBackend.html">ServiceDiscoveryBackend</a></code> SPI提供了一种可插拔的存储后端扩展机制。
Vert.x Service Discovery Redis Backend组件是基于Redis的后端存储实现。</p>
</div>
<div class="sect3">
<h4 id="_使用_redis_存储后端">使用 Redis 存储后端</h4>
<div class="paragraph">
<p>要使用 Redis 存储后端，需要将如下的依赖包加入到依赖配置文件中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在 <code>pom.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
 &lt;groupId&gt;io.vertx&lt;/groupId&gt;
 &lt;artifactId&gt;vertx-service-discovery-backend-redis&lt;/artifactId&gt;
 &lt;version&gt;3.6.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在 <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile 'io.vertx:vertx-service-discovery-backend-redis:3.6.0'</code></pre>
</div>
</div>
<div class="paragraph">
<p>需要注意的是，你只能在 <code>classpath</code> 中指定一个SPI的实现；如果没有指定，那么将使用默认的存储后端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置">配置</h4>
<div class="paragraph">
<p>Redis存储后端是基于 <a href="http://vertx.io/docs/vertx-redis-client/java">vertx-redis-client</a> 实现的，所以配置内容和 <code>RedisClient</code> 的配置内容一致。</p>
</div>
<div class="paragraph">
<p>下面是一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx, new ServiceDiscoveryOptions()
    .setBackendConfiguration(
        new JsonObject()
            .put("host", "127.0.0.1")
            .put("key", "records")
    ));</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的一点是，配置是在 <code>setBackendConfiguration</code> 方法中传入的（如果使用JSON，则传递给backendConfiguration 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServiceDiscovery.create(vertx,
  new ServiceDiscoveryOptions(new JsonObject()
    .put("backendConfiguration",
      new JsonObject().put("host", "localhost").put("port", 1234).put("key", "my-records")
)));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
        

        
          <div id="footer">
            <div id="footer-text">
              
                上次更新时间 2018-11-30 10:24:05 CST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/">主页</a></li>
          <li><a href="https://vertx.tk/download/">下载</a></li>
          <li><a href="https://vertx.tk/docs/">文档</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
          <li><a href="https://vertx.tk/blog/">博客</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/community/">帮助 &amp; 贡献者</a></li>
          <li><a href="https://vertx.tk/materials/">学习资料</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
          <li><a href="//shang.qq.com/wpa/qunwpa?idkey=587f58cacb9557e3291b46098e0fe09427b98a1c0f866da23c04c2762bc7e2ad">QQ群</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual-licensed under the <a href="http://www.eclipse.org/legal/epl-v20.html">Eclipse Public License 2.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="https://vertx.tk/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="https://vertx.tk/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="https://vertx.tk/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://vertx.tk/javascripts/bootstrap.min.js"></script>
<script src="https://vertx.tk/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="https://vertx.tk/javascripts/sidebar.js"></script>


<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});
</script>
</body>
</html>

