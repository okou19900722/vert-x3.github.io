<!DOCTYPE html>
<html lang="en">
<head>
  <title>Vert.x Kafka client - Vert.x</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name="description">
  <link href="https://vertx.tk/stylesheets/docs.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/stylesheets/font-awesome.min.css" media="screen" rel="stylesheet">
  <link href="https://vertx.tk/javascripts/styles/rainbow.min.css" media="screen" rel="stylesheet">
  <!-- IE 6-8 support of HTML 5 elements -->
  <!--[if lt IE 9]>
  <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script>
  <![endif]-->

  <link rel="apple-touch-icon" sizes="57x57" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://vertx.tk/assets/favicons/vertx-favicon-7/manifest.json">
  <link rel="mask-icon" href="https://vertx.tk/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#7d3194">
  <meta name="msapplication-TileImage" content="https://vertx.tk/assets/favicons/vertx-favicon-7/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel="stylesheet" type="text/css">
  <link rel="alternate" type="application/rss+xml" title="RSS"
     href="https://vertx.tk/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');
  </script>
  <style>
    .page-link-to-github {
      position: relative;
      z-index: 1;
      display: inline-block;
      border: 1px solid #782B90;
      border-radius: 5px;
      color: #782B90;
      font-size: 12px;
      padding: 4px 10px;
      text-decoration: none;
      background-color: #ffffff;
    }
    .page-link-to-github:hover {
      color: #ffffff;
      border-color: #ffffff;
      background-color: #782B90;
    }

    .page-link-to-github .github-icon {
      position: absolute;
      display: inline-block;
      width: 20px;
      height: 20px;
      background-image: url('https://www.kotlincn.net/0_assets/static/css/com/layout/images/main-sprite.png');
      background-repeat: no-repeat;
      /*background-position: -50px 0*/
      background-position: 0 0
    }

    @media (-webkit-min-device-pixel-ratio: 2),(min-resolution:192dpi) {
      .page-link-to-github .github-icon {
        background-image:url('https://www.kotlincn.net/0_assets/static/css/com/layout/images/main-sprite@2x.png');
        background-size: 150px auto
      }
    }

    .page-link-to-github:hover .github-icon {
      /*background-position: 0 0*/
      background-position: -50px 0
    }
    .text {
      text-decoration: underline
    }
    .page-link-to-github .text {
      padding-left: 27px
    }
    .text {
      padding-right: 8px
    }
    .page-link-to-github {
      float: right;
      top: 4px
    }

  </style>
</head>
<body>

<a href="http://www.reactivemanifesto.org/" id="reactive-manifesto-banner">
  <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000"
    src="https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png">
</a>

<a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

<header class="navbar navbar-default navbar-static-top" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#vertx-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="https://vertx.tk/" class="navbar-brand"><img alt="Brand" src="https://vertx.tk/assets/logo-sm.png"></a>
    </div>
    <nav class="collapse navbar-collapse" id="vertx-navbar-collapse">
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://start.vertx.io">Starter</a></li>
        <li><a href="https://vertx.tk/download/">下载</a></li>
        <li><a href="https://vertx.tk/docs/">文档</a></li>
        <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
        <li><a href="https://vertx.tk/community/">社区</a></li>
        <li><a href="https://vertx.tk/materials/">资料</a></li>
        <li><a href="https://vertx.tk/blog/">博客</a></li>
      </ul>
    </nav>
  </div>
</header>



  <div class="page-header" id="content">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1>Vert.x Kafka client</h1>
          
        </div>
      </div>
    </div>
  </div>



<div id="content">
  <div class="container docs-content">
    <div class="row">
      <div class="col-sm-12 col-md-push-9 col-md-3 hidden-xs hidden-sm">
        <div id="sidebar" data-spy="affix">
          <ul class="sectlevel1">
<li><a href="#_使用_vert_x_kafka_client">使用 Vert.x Kafka Client</a></li>
<li><a href="#_创建_kafka_client">创建 Kafka Client</a></li>
<li><a href="#_消费感兴趣_topic_的消息并加入消费组">消费感兴趣 Topic 的消息并加入消费组</a></li>
<li><a href="#_从_topic_的特定分区里接收消息">从 Topic 的特定分区里接收消息</a></li>
<li><a href="#_receiving_messages_with_explicit_polling">Receiving messages with explicit polling</a></li>
<li><a href="#_changing_the_subscription_or_assignment">Changing the subscription or assignment</a></li>
<li><a href="#_获取_topic_以及分区信息">获取 Topic 以及分区信息</a></li>
<li><a href="#_手动提交偏移量">手动提交偏移量</a></li>
<li><a href="#_分区偏移量定位">分区偏移量定位</a></li>
<li><a href="#_偏移量查询">偏移量查询</a></li>
<li><a href="#_流量控制">流量控制</a></li>
<li><a href="#_关闭_consumer">关闭 Consumer</a></li>
<li><a href="#_发送消息到某个_topic">发送消息到某个 Topic</a></li>
<li><a href="#_共享_producer">共享 Producer</a></li>
<li><a href="#_关闭_producer">关闭 Producer</a></li>
<li><a href="#_获取_topic_partition_的相关信息">获取 Topic Partition 的相关信息</a></li>
<li><a href="#_错误处理">错误处理</a></li>
<li><a href="#_随_verticle_自动关闭">随 Verticle 自动关闭</a></li>
<li><a href="#_使用_vert_x_自带的序列化与反序列化机制">使用 Vert.x 自带的序列化与反序列化机制</a></li>
<li><a href="#_rxjava_api">RxJava API</a></li>
<li><a href="#_vert_x_kafka_adminutils">Vert.x Kafka AdminUtils</a>
<ul class="sectlevel1">
<li><a href="#_using_the_adminutils">Using the AdminUtils</a>
<ul class="sectlevel2">
<li><a href="#_create_a_topic">Create a topic</a></li>
<li><a href="#_delete_a_topic">Delete a topic</a></li>
<li><a href="#_change_a_topic_s_configuration">Change a topic&#8217;s configuration</a></li>
<li><a href="#_check_if_a_topic_exists">Check if a topic exists</a></li>
</ul>
</li>
</ul>
</li>
</ul>
        </div>
      </div>
      <div class="col-sm-12 col-md-pull-3 col-md-9">
        <div class="toc hidden-md hidden-lg">
          <h2>Table of Contents</h2>
          <ul class="sectlevel1">
<li><a href="#_使用_vert_x_kafka_client">使用 Vert.x Kafka Client</a></li>
<li><a href="#_创建_kafka_client">创建 Kafka Client</a></li>
<li><a href="#_消费感兴趣_topic_的消息并加入消费组">消费感兴趣 Topic 的消息并加入消费组</a></li>
<li><a href="#_从_topic_的特定分区里接收消息">从 Topic 的特定分区里接收消息</a></li>
<li><a href="#_receiving_messages_with_explicit_polling">Receiving messages with explicit polling</a></li>
<li><a href="#_changing_the_subscription_or_assignment">Changing the subscription or assignment</a></li>
<li><a href="#_获取_topic_以及分区信息">获取 Topic 以及分区信息</a></li>
<li><a href="#_手动提交偏移量">手动提交偏移量</a></li>
<li><a href="#_分区偏移量定位">分区偏移量定位</a></li>
<li><a href="#_偏移量查询">偏移量查询</a></li>
<li><a href="#_流量控制">流量控制</a></li>
<li><a href="#_关闭_consumer">关闭 Consumer</a></li>
<li><a href="#_发送消息到某个_topic">发送消息到某个 Topic</a></li>
<li><a href="#_共享_producer">共享 Producer</a></li>
<li><a href="#_关闭_producer">关闭 Producer</a></li>
<li><a href="#_获取_topic_partition_的相关信息">获取 Topic Partition 的相关信息</a></li>
<li><a href="#_错误处理">错误处理</a></li>
<li><a href="#_随_verticle_自动关闭">随 Verticle 自动关闭</a></li>
<li><a href="#_使用_vert_x_自带的序列化与反序列化机制">使用 Vert.x 自带的序列化与反序列化机制</a></li>
<li><a href="#_rxjava_api">RxJava API</a></li>
<li><a href="#_vert_x_kafka_adminutils">Vert.x Kafka AdminUtils</a>
<ul class="sectlevel1">
<li><a href="#_using_the_adminutils">Using the AdminUtils</a>
<ul class="sectlevel2">
<li><a href="#_create_a_topic">Create a topic</a></li>
<li><a href="#_delete_a_topic">Delete a topic</a></li>
<li><a href="#_change_a_topic_s_configuration">Change a topic&#8217;s configuration</a></li>
<li><a href="#_check_if_a_topic_exists">Check if a topic exists</a></li>
</ul>
</li>
</ul>
</li>
</ul>
        </div>

  <a href="https://github.com/okou19900722/vertx-web-site-translation-chinese/tree/stack-refactor/vertx-translation-stack/vertx-kafka-client-translation"
     class="page-link-to-github"
     target="_blank"
     title="Edit this page on GitHub">
    <i class="github-icon"></i>
    <span class="text">编辑本页</span>
  </a>

        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>此组件提供了 Kafka Client 的集成，可以以 Vert.x 的方式从 <a href="https://kafka.apache.org/">Apache Kafka</a> 集群上消费或者发送消息。</p>
</div>
<div class="paragraph">
<p>对于消费者(consumer)，API以异步的方式订阅消费指定的 topic 以及相关的分区(partition)，
或者将消息以 Vert.x Stream 的方式读取（甚至可以支持暂停(pause)和恢复(resume)操作）。</p>
</div>
<div class="paragraph">
<p>对于生产者(producer)，API提供发送信息到指定 topic 以及相关的分区(partition)的方法，类似于向 Vert.x Stream 中写入数据。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
此组件处于技术预览阶段，因此在之后版本中API可能还会发生一些变更。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用_vert_x_kafka_client">使用 Vert.x Kafka Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要使用 Vert.x Kafka Client 组件，需要添加以下依赖：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven (在 <code>pom.xml</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
 &lt;groupId&gt;io.vertx&lt;/groupId&gt;
 &lt;artifactId&gt;vertx-kafka-client&lt;/artifactId&gt;
 &lt;version&gt;3.6.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle (在 <code>build.gradle</code> 文件中):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile io.vertx:vertx-kafka-client:3.6.0-SNAPSHOT</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_创建_kafka_client">创建 Kafka Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>创建 Consumer 和 Producer 以及使用它们的方法其实与原生的 Kafka Client 库非常相似，Vert.x 只是做了一层异步封装。</p>
</div>
<div class="paragraph">
<p>我们需要对 Consumer 与 Producer 进行一些相关的配置，具体可以参考 Apache Kafka 的官方文档：
<a href="https://kafka.apache.org/documentation/#newconsumerconfigs">consumer</a> 和
<a href="https://kafka.apache.org/documentation/#producerconfigs">producer</a>.</p>
</div>
<div class="paragraph">
<p>我们可以通过一个 Map 来包装这些配置，然后将其传入到
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html">KafkaConsumer</a></code> 接口或
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html">KafkaProducer</a></code> 接口中的 <code>create</code> 静态方法里来创建 <code>KafkaConsumer</code> 或 <code>KafkaProducer</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// creating the consumer using map config
var config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.deserializer" -&gt; "org.apache.kafka.common.serialization.StringDeserializer")
config + ("value.deserializer" -&gt; "org.apache.kafka.common.serialization.StringDeserializer")
config + ("group.id" -&gt; "my_group")
config + ("auto.offset.reset" -&gt; "earliest")
config + ("enable.auto.commit" -&gt; "false")

// use consumer for interacting with Apache Kafka
var consumer = KafkaConsumer.create(vertx, config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，我们在创建 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html">KafkaConsumer</a></code> 实例时传入了一个 Map 实例，用于指定要连接的 Kafka 节点列表（只有一个）以及如何对接收到的消息进行解析以得到 key 与 value。</p>
</div>
<div class="paragraph">
<p>我们可以用类似的方法来创建 Producer：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// creating the producer using map and class types for key and value serializers/deserializers
var config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.serializer" -&gt; "org.apache.kafka.common.serialization.StringSerializer")
config + ("value.serializer" -&gt; "org.apache.kafka.common.serialization.StringSerializer")
config + ("acks" -&gt; "1")

// use producer for interacting with Apache Kafka
var producer = KafkaProducer.create(vertx, config)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_消费感兴趣_topic_的消息并加入消费组">消费感兴趣 Topic 的消息并加入消费组</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们可以通过 <code>KafkaConsumer</code> 的
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribe(java.util.Set)">subscribe</a></code> 方法来订阅一个或多个 topic 进行消费，同时加入到某个消费组（consumer group）中（在创建消费者实例时通过配置指定）。</p>
</div>
<div class="paragraph">
<p>当然你需要通过
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#handler(io.vertx.core.Handler)">handler</a></code> 方法注册一个 <code>Handler</code> 来处理接收的消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s"Processing key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}")
})

// subscribe to several topics
var topics = new java.util.HashSet()
topics.add("topic1")
topics.add("topic2")
topics.add("topic3")
consumer.subscribe(topics)

// or just subscribe to a single topic
consumer.subscribe("a-single-topic")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The handler can be registered before or after the call to <code>subscribe()</code>; messages won&#8217;t be consumed until both
methods have been called. This allows you to call <code>subscribe()</code>, then <code>seek()</code> and finally <code>handler()</code> in
order to only consume messages starting from a particular offset, for example.</p>
</div>
<div class="paragraph">
<p>另外如果想知道消息是否成功被消费掉，可以在调用 <code>subscribe</code> 方法时绑定一个 <code>Handler</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s"Processing key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}")
})

// subscribe to several topics
var topics = new java.util.HashSet()
topics.add("topic1")
topics.add("topic2")
topics.add("topic3")
consumer.subscribeFuture(topics).onComplete{
  case Success(result) =&gt; {
    println("subscribed")
  }
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}

// or just subscribe to a single topic
consumer.subscribeFuture("a-single-topic").onComplete{
  case Success(result) =&gt; {
    println("subscribed")
  }
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于Kafka的消费者会组成一个消费组(consumer group)，同一个组只有一个消费者可以消费特定的 partition，
同时此消费组也可以接纳其他的消费者，这样可以实现 partition 分配给组内其它消费者继续去消费。</p>
</div>
<div class="paragraph">
<p>如果组内的一个消费者挂了，kafka 集群会自动把 partition 重新分配给组内其他消费者，或者新加入一个消费者去消费对应的 partition。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsRevokedHandler(io.vertx.core.Handler)">partitionsRevokedHandler</a></code> 和
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsAssignedHandler(io.vertx.core.Handler)">partitionsAssignedHandler</a></code> 方法在
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html">KafkaConsumer</a></code> 里注册一个 <code>Handler</code> 用于监听对应的 partition 是否被删除或者分配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s"Processing key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}")
})

// registering handlers for assigned and revoked partitions
consumer.partitionsAssignedHandler((topicPartitions: java.util.Set&lt;io.vertx.scala.kafka.client.common.TopicPartition&gt;) =&gt; {

  println("Partitions assigned")
  topicPartitions.foreach(topicPartition =&gt; {
    println(s"${todo-renderDataObjectMemberSelect} ${todo-renderDataObjectMemberSelect}")
  })

})

consumer.partitionsRevokedHandler((topicPartitions: java.util.Set&lt;io.vertx.scala.kafka.client.common.TopicPartition&gt;) =&gt; {

  println("Partitions revoked")
  topicPartitions.foreach(topicPartition =&gt; {
    println(s"${todo-renderDataObjectMemberSelect} ${todo-renderDataObjectMemberSelect}")
  })

})

// subscribes to the topic
consumer.subscribeFuture("test").onComplete{
  case Success(result) =&gt; {
    println("Consumer subscribed")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>加入某个 consumer group 的消费者，可以通过
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#unsubscribe()">unsubscribe</a></code>
方法退出该消费组，从而不再接受到相关消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// consumer is already member of a consumer group

// unsubscribing request
consumer.unsubscribe()</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然你也可以在 <code>unsubscribe</code> 方法中传入一个 <code>Handler</code> 用于监听执行结果状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// consumer is already member of a consumer group

// unsubscribing request
consumer.unsubscribeFuture().onComplete{
  case Success(result) =&gt; {
    println("Consumer unsubscribed")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_从_topic_的特定分区里接收消息">从 Topic 的特定分区里接收消息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>消费组内的消费者可以消费某个 topic 指定的 partition。如果某个消费者并不属于任何消费组，那么整个程序就不能依赖 Kafka 的 re-balancing 机制去消费消息。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assign(java.util.Set,%20io.vertx.core.Handler)">assign</a></code>
方法请求分配指定的分区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// register the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s"key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}")
})

//
var topicPartitions = new java.util.HashSet()
topicPartitions.add(TopicPartition()
  .setTopic("test")
  .setPartition(0)
)

// requesting to be assigned the specific partition
consumer.assignFuture(topicPartitions).onComplete{
  case Success(result) =&gt; {
    println("Partition assigned")

    // requesting the assigned partitions
    consumer.assignmentFuture().onComplete{
      case Success(result) =&gt; {

        result.foreach(topicPartition =&gt; {
          println(s"${todo-renderDataObjectMemberSelect} ${todo-renderDataObjectMemberSelect}")
        })

      }
      case Failure(cause) =&gt; println("Failure")
    }
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>subscribe()</code>, the handler can be registered before or after the call to <code>assign()</code>;
messages won&#8217;t be consumed until both methods have been called. This allows you to call
<code>assign()</code>, then <code>seek()</code> and finally <code>handler()</code> in
order to only consume messages starting from a particular offset, for example.</p>
</div>
<div class="paragraph">
<p>上面的 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assignment(io.vertx.core.Handler)">assignment</a></code> 方法可以列出当前分配的 topic partition。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_receiving_messages_with_explicit_polling">Receiving messages with explicit polling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Other than using the internal polling mechanism in order to receive messages from Kafka, the client can subscribe to a
topic, avoiding to register the handler for getting the messages and then using the <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#poll(long,%20io.vertx.core.Handler)">poll</a></code> method.</p>
</div>
<div class="paragraph">
<p>In this way, the user application is in charge to execute the poll for getting messages when it needs, for example after processing
the previous ones.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// subscribes to the topic
consumer.subscribeFuture("test").onComplete{
  case Success(result) =&gt; {
    println("Consumer subscribed")

    vertx.setPeriodic(1000, (timerId: java.lang.Long) =&gt; {

      consumer.pollFuture(100).onComplete{
        case Success(result) =&gt; {

          var records = result
          for ( i &lt;- 0 until records.size()) {
            var record = records.recordAt(i)
            println(s"key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}")
          }

        }
        case Failure(cause) =&gt; println("Failure")
      }

    })
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After subscribing successfully, the application start a periodic timer in order to execute the poll and getting messages
from Kafka periodically.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_changing_the_subscription_or_assignment">Changing the subscription or assignment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can change the subscribed topics, or assigned partitions after you have started to consume messages, simply
by calling <code>subscribe()</code> or <code>assign()</code> again.</p>
</div>
<div class="paragraph">
<p>Note that due to internal buffering of messages it is possible that the record handler will continue to
observe messages from the old subscription or assignment <em>after</em> the <code>subscribe()</code> or <code>assign()</code>
method&#8217;s completion handler has been called. This is not the case for messages observed by the batch handler:
Once the completion handler has been called it will only observe messages read from the subscription or assignment.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_获取_topic_以及分区信息">获取 Topic 以及分区信息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsFor(java.lang.String,%20io.vertx.core.Handler)">partitionsFor</a></code> 方法获取指定 topic 的 partition 信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// asking partitions information about specific topic
consumer.partitionsForFuture("test").onComplete{
  case Success(result) =&gt; {

    result.foreach(partitionInfo =&gt; {
      println(partitionInfo)
    })

  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外， <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#listTopics(io.vertx.core.Handler)">listTopics</a></code> 方法可以列出消费者下的所有 topic 以及对应的 partition 信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// asking information about available topics and related partitions
consumer.listTopicsFuture().onComplete{
  case Success(result) =&gt; {

    var map = result
    map.foreach{
      case (topic: java.lang.String, partitions: java.util.List&lt;io.vertx.scala.kafka.client.common.PartitionInfo&gt;) =&gt; {
      println(s"topic = ${topic}")
      println(s"partitions = ${map(topic)}")
    }}
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_手动提交偏移量">手动提交偏移量</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Apache Kafka 中，消费者负责处理最新读取消息的偏移量（offset）。</p>
</div>
<div class="paragraph">
<p>Consumer 会在每次从某个 topic partition 中读取一批消息的时候自动执行提交偏移量的操作。需要在创建 <code>KafkaConsumer</code> 时将 <code>enable.auto.commit</code> 配置项设为 <code>true</code> 来开启自动提交。</p>
</div>
<div class="paragraph">
<p>我们可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#commit(io.vertx.core.Handler)">commit</a></code>
方法进行手动提交。手动提交偏移量通常用于确保消息分发的 <strong>at least once</strong> 语义，以确保消息没有被消费前不会执行提交。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// consumer is processing read messages

// committing offset of the last read message
consumer.commitFuture().onComplete{
  case Success(result) =&gt; {
    println("Last read message offset committed")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分区偏移量定位">分区偏移量定位</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Apache Kafka 中的消息是按顺序持久化在磁盘上的，所以消费者可以在某个 partition 内部进行偏移量定位(seek)操作，
并从任意指定的 topic 以及 partition 位置开始消费消息。</p>
</div>
<div class="paragraph">
<p>我们可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seek(io.vertx.kafka.client.common.TopicPartition,%20long)">seek</a></code> 方法来更改读取位置对应的偏移量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var topicPartition = TopicPartition()
  .setTopic("test")
  .setPartition(0)


// seek to a specific offset
consumer.seekFuture(topicPartition, 10).onComplete{
  case Success(result) =&gt; {
    println("Seeking done")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当消费者需要从 Stream 的起始位置读取消息时，可以使用 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(io.vertx.kafka.client.common.TopicPartition)">seekToBeginning</a></code> 方法将 <code>offset</code> 位置设置到 partition 的起始端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var topicPartition = TopicPartition()
  .setTopic("test")
  .setPartition(0)


// seek to the beginning of the partition
consumer.seekToBeginningFuture(java.util.Collections.singleton(topicPartition)).onComplete{
  case Success(result) =&gt; {
    println("Seeking done")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后我们也可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(io.vertx.kafka.client.common.TopicPartition)">seekToEnd</a></code> 方法将 <code>offset</code> 位置设置到 partition 的末端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var topicPartition = TopicPartition()
  .setTopic("test")
  .setPartition(0)


// seek to the end of the partition
consumer.seekToEndFuture(java.util.Collections.singleton(topicPartition)).onComplete{
  case Success(result) =&gt; {
    println("Seeking done")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that due to internal buffering of messages it is possible that the record handler will continue to
observe messages read from the original offset for a time <em>after</em> the <code>seek*()</code> method&#8217;s completion
handler has been called. This is not the case for messages observed by the batch handler: Once the
<code>seek*()</code> completion handler has been called it will only observe messages read from the new offset.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_偏移量查询">偏移量查询</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你可以利用 Kafka 0.10.1.1 引入的新的API <code>beginningOffsets</code> 来获取给定分区的起始偏移量。这个跟上面的
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(io.vertx.kafka.client.common.TopicPartition)">seekToBeginning</a></code> 方法有一个地方不同：
beginningOffsets
方法不会更改 offset 的值，仅仅是读取（只读模式）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var topicPartitions = new java.util.HashSet()
var topicPartition = TopicPartition()
  .setTopic("test")
  .setPartition(0)

topicPartitions.add(topicPartition)

consumer.beginningOffsetsFuture(topicPartitions).onComplete{
  case Success(result) =&gt; {
    var results = result
    results.foreach{
      case (topic: io.vertx.scala.kafka.client.common.TopicPartition, beginningOffset: java.lang.Long) =&gt; {
      println(s"Beginning offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, beginningOffset=${beginningOffset}")
    }}
  }
  case Failure(cause) =&gt; println("Failure")
}

// Convenience method for single-partition lookup
consumer.beginningOffsetsFuture(topicPartition).onComplete{
  case Success(result) =&gt; {
    var beginningOffset = result
    println(s"Beginning offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, beginningOffset=${beginningOffset}")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与此对应的API还有 <code>endOffsets</code> 方法，用于获取给定分区末端的偏移量值。与 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(io.vertx.kafka.client.common.TopicPartition)">seekToEnd</a></code> 方法相比，
<code>endOffsets</code> 方法不会更改 offset 的值，仅仅是读取（只读模式）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var topicPartitions = new java.util.HashSet()
var topicPartition = TopicPartition()
  .setTopic("test")
  .setPartition(0)

topicPartitions.add(topicPartition)

consumer.endOffsetsFuture(topicPartitions).onComplete{
  case Success(result) =&gt; {
    var results = result
    results.foreach{
      case (topic: io.vertx.scala.kafka.client.common.TopicPartition, endOffset: java.lang.Long) =&gt; {
      println(s"End offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, endOffset=${endOffset}")
    }}
  }
  case Failure(cause) =&gt; println("Failure")
}

// Convenience method for single-partition lookup
consumer.endOffsetsFuture(topicPartition).onComplete{
  case Success(result) =&gt; {
    var endOffset = result
    println(s"End offset for topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, endOffset=${endOffset}")
  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kafka 0.10.1.1 还提供了一个根据时间戳(timestamp)来定位 offset 的API方法 <code>offsetsForTimes</code>，调用此API可以返回大于等于给定时间戳的 offset。因为 Kafka 的 offset 低位就是时间戳，所以 Kafka 很容易定位此类offset。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">Code not translatable</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_流量控制">流量控制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Consumer 可以对消息流进行流量控制。如果我们读到一批消息，需要花点时间进行处理则可以暂时暂停（<code>pause</code>）消息的流入（这里实际上是把消息全部缓存到内存里了）；
等我们处理了差不多了，可以再继续消费缓存起来的消息（<code>resume</code>）。</p>
</div>
<div class="paragraph">
<p>我们可以利用 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pause()">pause</a></code> 方法和
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resume()">resume</a></code> 方法来进行流量控制：</p>
</div>
<div class="paragraph">
<p>In the case of the partition-specific pause and resume it is possible that the record handler will continue to
observe messages from a paused partition for a time <em>after</em> the <code>pause()</code> method&#8217;s completion
handler has been called. This is not the case for messages observed by the batch handler: Once the
<code>pause()</code> completion handler has been called it will only observe messages from those partitions which
rare not paused.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var topicPartition = TopicPartition()
  .setTopic("test")
  .setPartition(0)


// registering the handler for incoming messages
consumer.handler((record: io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord&lt;java.lang.String,java.lang.String&gt;) =&gt; {
  println(s"key=${record.key()},value=${record.value()},partition=${record.partition()},offset=${record.offset()}")

  // i.e. pause/resume on partition 0, after reading message up to offset 5
  if ((record.partition() == 0) &amp;&amp; (record.offset() == 5)) {

    // pause the read operations
    consumer.pauseFuture(topicPartition).onComplete{
      case Success(result) =&gt; {

        println("Paused")

        // resume read operation after a specific time
        vertx.setTimer(5000, (timeId: java.lang.Long) =&gt; {

          // resume read operations
          consumer.resume(topicPartition)
        })
      }
      case Failure(cause) =&gt; println("Failure")
    }
  }
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_关闭_consumer">关闭 Consumer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>关闭 Consumer 只需要调用 <code>close</code> 方法就可以了，它会自动的关闭与 Kafka 的连接，同时释放相关资源。</p>
</div>
<div class="paragraph">
<p>由于 <code>close</code> 方法是异步的，你并不知道关闭操作什么时候完成或失败，这时你需要注册一个处理器(<code>Handler</code>)来监听关闭完成的消息。</p>
</div>
<div class="paragraph">
<p>当关闭操作彻底完成以后，注册的 <code>Handler</code> 将会被调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">consumer.closeFuture().onComplete{
  case Success(result) =&gt; {
    println("Consumer is now closed")
  }
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_发送消息到某个_topic">发送消息到某个 Topic</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可以利用 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#write(io.vertx.kafka.client.producer.KafkaProducerRecord)">write</a></code> 方法来向某个 topic 发送消息(records)。</p>
</div>
<div class="paragraph">
<p>最简单的发送消息的方式是仅仅指定目的 topic 以及相应的值而省略消息的 key 以及分区。在这种情况下，
消息会以轮询(round robin)的方式发送到对应 topic 的所有分区上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">for ( i &lt;- 0 until 5) {

  // only topic and message value are specified, round robin on destination partitions
  var record = KafkaProducerRecord.create("test", s"message_${i}")

  producer.write(record)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过绑定 <code>Handler</code> 来接受发送的结果。这个结果其实就是一些元数据(metadata)，
包含消息的 topic、目的分区 (destination partition) 以及分配的偏移量 (assigned offset)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">for ( i &lt;- 0 until 5) {

  // only topic and message value are specified, round robin on destination partitions
  var record = KafkaProducerRecord.create("test", s"message_${i}")

  producer.writeFuture(record).onComplete{
    case Success(result) =&gt; {

      var recordMetadata = result
      println(s"Message ${record.value()} written on topic=${todo-renderDataObjectMemberSelect}, partition=${todo-renderDataObjectMemberSelect}, offset=${todo-renderDataObjectMemberSelect}")
    }
    case Failure(cause) =&gt; println("Failure")
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果希望将消息发送到指定的分区，你可以指定分区的标识(identifier)或者设定消息的 key：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">for ( i &lt;- 0 until 10) {

  // a destination partition is specified
  var record = KafkaProducerRecord.create("test", null, s"message_${i}", 0)

  producer.write(record)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 Producer 可以使用消息的 key 作为 hash 值来确定 partition，所以我们可以保证所有的消息被发送到同样的 partition 中，并且是有序的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">for ( i &lt;- 0 until 10) {

  // i.e. defining different keys for odd and even messages
  var key = i % 2

  // a key is specified, all messages with same key will be sent to the same partition
  var record = KafkaProducerRecord.create("test", java.lang.String.valueOf(key), s"message_${i}")

  producer.write(record)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
可共享的 Producer 通过 <code>createShared</code> 方法创建。它可以在多个 Verticle 实例之间共享，所以相关的配置必须在创建 Producer 的时候定义。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_共享_producer">共享 Producer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有时候您希望在多个 Verticle 或者 Vert.x Context 下共用一个 Producer。</p>
</div>
<div class="paragraph">
<p>您可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#createShared(io.vertx.core.Vertx,%20java.lang.String,%20java.util.Map)">KafkaProducer.createShared</a></code>
方法来创建可以在 Verticle 之间安全共享的 <code>KafkaProducer</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// Create a shared producer identified by 'the-producer'
var producer1 = KafkaProducer.createShared(vertx, "the-producer", config)

// Sometimes later you can close it
producer1.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的 <code>KafkaProducer</code> 实例将复用相关的资源（如线程、连接等）。</p>
</div>
<div class="paragraph">
<p>使用完 <code>KafkaProducer</code> 后，直接调用 <code>close</code> 方法关闭即可，相关的资源会自动释放。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_关闭_producer">关闭 Producer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与关闭 Consumer 类似，关闭 Producer 只需要调用 <code>close</code> 方法就可以了，它会自动的关闭与 Kafka 的连接，同时释放所有相关资源。</p>
</div>
<div class="paragraph">
<p>由于 <code>close</code> 方法是异步的，你并不知道关闭操作什么时候完成或失败，这时你需要注册一个处理器(<code>Handler</code>)来监听关闭完成的消息。</p>
</div>
<div class="paragraph">
<p>当关闭操作彻底完成以后，注册的 <code>Handler</code> 将会被调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">producer.closeFuture().onComplete{
  case Success(result) =&gt; {
    println("Producer is now closed")
  }
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_获取_topic_partition_的相关信息">获取 Topic Partition 的相关信息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可以通过 <code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#partitionsFor(java.lang.String,%20io.vertx.core.Handler)">partitionsFor</a></code> 方法获取指定 topic 的分区信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// asking partitions information about specific topic
producer.partitionsForFuture("test").onComplete{
  case Success(result) =&gt; {

    result.foreach(partitionInfo =&gt; {
      println(partitionInfo)
    })

  }
  case Failure(cause) =&gt; println("Failure")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_错误处理">错误处理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可以利用
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code> 方法和
<code><a href="../../scaladocs/io/vertx/scala/kafka/client/producer/KafkaProducer.html#exceptionHandler(io.vertx.core.Handler)">exceptionHandler</a></code> 方法来处理 Kafka 客户端（生产者和消费者）和 Kafka 集群之间的错误（如超时）。
比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// setting handler for errors
consumer.exceptionHandler((e: java.lang.Throwable) =&gt; {
  println(s"Error = ${e.getMessage()}")
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_随_verticle_自动关闭">随 Verticle 自动关闭</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您是在 Verticle 内部创建的 Consumer 和 Producer，那么当对应 Verticle 被卸载(undeploy)的时候，相关的 Consumer 和 Producer 会自动关闭。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用_vert_x_自带的序列化与反序列化机制">使用 Vert.x 自带的序列化与反序列化机制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Kafka Client 自带现成的序列化与反序列化机制，可以处理 <code>Buffer</code>、<code>JsonObject</code> 和 <code>JsonArray</code> 等类型。</p>
</div>
<div class="paragraph">
<p>在 <code>KafkaConsumer</code> 里您可以使用 <code>Buffer</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// Creating a consumer able to deserialize to buffers
var config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.deserializer" -&gt; "io.vertx.kafka.client.serialization.BufferDeserializer")
config + ("value.deserializer" -&gt; "io.vertx.kafka.client.serialization.BufferDeserializer")
config + ("group.id" -&gt; "my_group")
config + ("auto.offset.reset" -&gt; "earliest")
config + ("enable.auto.commit" -&gt; "false")

// Creating a consumer able to deserialize to json object
config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.deserializer" -&gt; "io.vertx.kafka.client.serialization.JsonObjectDeserializer")
config + ("value.deserializer" -&gt; "io.vertx.kafka.client.serialization.JsonObjectDeserializer")
config + ("group.id" -&gt; "my_group")
config + ("auto.offset.reset" -&gt; "earliest")
config + ("enable.auto.commit" -&gt; "false")

// Creating a consumer able to deserialize to json array
config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.deserializer" -&gt; "io.vertx.kafka.client.serialization.JsonArrayDeserializer")
config + ("value.deserializer" -&gt; "io.vertx.kafka.client.serialization.JsonArrayDeserializer")
config + ("group.id" -&gt; "my_group")
config + ("auto.offset.reset" -&gt; "earliest")
config + ("enable.auto.commit" -&gt; "false")</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样在 <code>KafkaProducer</code> 中也可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">// Creating a producer able to serialize to buffers
var config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.serializer" -&gt; "io.vertx.kafka.client.serialization.BufferSerializer")
config + ("value.serializer" -&gt; "io.vertx.kafka.client.serialization.BufferSerializer")
config + ("acks" -&gt; "1")

// Creating a producer able to serialize to json object
config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.serializer" -&gt; "io.vertx.kafka.client.serialization.JsonObjectSerializer")
config + ("value.serializer" -&gt; "io.vertx.kafka.client.serialization.JsonObjectSerializer")
config + ("acks" -&gt; "1")

// Creating a producer able to serialize to json array
config = Map()
config + ("bootstrap.servers" -&gt; "localhost:9092")
config + ("key.serializer" -&gt; "io.vertx.kafka.client.serialization.JsonArraySerializer")
config + ("value.serializer" -&gt; "io.vertx.kafka.client.serialization.JsonArraySerializer")
config + ("acks" -&gt; "1")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rxjava_api">RxJava API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vert.x Kafka Client 组件也提供Rx风格的API。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">Code not translatable</code></pre>
</div>
</div>
</div>
</div>
<h1 id="_vert_x_kafka_adminutils" class="sect0">Vert.x Kafka AdminUtils</h1>
<div class="openblock partintro">
<div class="content">
This component provides a vert.x wrapper around the most important functions of Kafka&#8217;s AdminUtils.
AdminUtils are used to create, modify, and delete topics. Other functionality covered by AdminUtils,
but not this wrapper, includes Partition Management, Broker Configuration management, etc.
</div>
</div>
<div class="sect1">
<h2 id="_using_the_adminutils">Using the AdminUtils</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_create_a_topic">Create a topic</h3>
<div class="paragraph">
<p>You can call <code><a href="../../scaladocs/io/vertx/scala/kafka/admin/AdminUtils.html#createTopic(java.lang.String,%20int,%20int,%20io.vertx.core.Handler)">createTopic</a></code> to create a topic.
Parameters are: topic name, number of partitions, number of replicas, and the usual callback to handle the result.
It might return an error, e.g. if the number of requested replicas is greater than the number of brokers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var adminUtils = AdminUtils.create(Vertx.vertx(), "localhost:2181", true)
// Create topic 'myNewTopic' with 2 partition and 1 replicas
adminUtils.createTopicFuture("myNewTopic", 2, 1).onComplete{
  case Success(result) =&gt; {
    println("Creation of topic myNewTopic successful!")}
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delete_a_topic">Delete a topic</h3>
<div class="paragraph">
<p>You can call <code><a href="../../scaladocs/io/vertx/scala/kafka/admin/AdminUtils.html#deleteTopic(java.lang.String,%20io.vertx.core.Handler)">deleteTopic</a></code> to delete a topic.
Parameters are: topic name, and the usual callback to handle the result.
It might return an error, e.g. if the topic does not exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var adminUtils = AdminUtils.create(Vertx.vertx(), "localhost:2181", true)
// Delete topic 'myNewTopic'
adminUtils.deleteTopicFuture("myNewTopic").onComplete{
  case Success(result) =&gt; {
    println("Deletion of topic myNewTopic successful!")}
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_change_a_topic_s_configuration">Change a topic&#8217;s configuration</h3>
<div class="paragraph">
<p>If you need to update the configuration of a topic, e.g., you want to update the retention policy,
you can call <code><a href="../../scaladocs/io/vertx/scala/kafka/admin/AdminUtils.html#changeTopicConfig(java.lang.String,%20java.util.Map,%20io.vertx.core.Handler)">changeTopicConfig</a></code> to update a topic.
Parameters are: topic name, a Map (String &#8594; String) with parameters to be changed,
and the usual callback to handle the result.
It might return an error, e.g. if the topic does not exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var adminUtils = AdminUtils.create(Vertx.vertx(), "localhost:2181", true)
// Set retention to 1000 ms and max size of the topic partition to 1 kiByte
var properties = Map()
properties + ("delete.retention.ms" -&gt; "1000")
properties + ("retention.bytes" -&gt; "1024")
adminUtils.changeTopicConfigFuture("myNewTopic", properties).onComplete{
  case Success(result) =&gt; {
    println("Configuration change of topic myNewTopic successful!")}
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_check_if_a_topic_exists">Check if a topic exists</h3>
<div class="paragraph">
<p>If you want to check if a topic exists, you can call <code><a href="../../scaladocs/io/vertx/scala/kafka/admin/AdminUtils.html#topicExists(java.lang.String,%20io.vertx.core.Handler)">topicExists</a></code>.
Parameters are: topic name, and the usual callback to handle the result.
It might return an error, e.g. if the topic does not exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">var adminUtils = AdminUtils.create(Vertx.vertx(), "localhost:2181", true)
adminUtils.topicExistsFuture("myNewTopic").onComplete{
  case Success(result) =&gt; {
    println(s"Topic myNewTopic exists: ${result}")
  }
  case Failure(cause) =&gt; {
    println(s"$cause")
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
        

        
          <div id="footer">
            <div id="footer-text">
              
                上次更新时间 2018-09-07 11:02:54 CST
              
              
            </div>
          </div>
        
      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse Vert.x</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/">主页</a></li>
          <li><a href="https://vertx.tk/download/">下载</a></li>
          <li><a href="https://vertx.tk/docs/">文档</a></li>
          <li><a href="https://github.com/vert-x3/wiki/wiki">维基</a></li>
          <li><a href="https://vertx.tk/blog/">博客</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Community</h2>
        <ul class="list-unstyled">
          <li><a href="https://vertx.tk/community/">Help &amp; Contributors</a></li>
          <li><a href="https://vertx.tk/materials/">Learning materials</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx">User Group</a></li>
          <li><a href="https://groups.google.com/forum/?fromgroups#!forum/vertx-dev">Developer Group</a></li>
        </ul>
      </div>
      <div class="col-xs-4 col-sm-4 col-md-2 col-lg-2">
        <h2>Eclipse</h2>
        <ul class="list-unstyled">
          <li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li>
          <li><a href="https://eclipse.org/legal/privacy.php">Privacy Policy</a></li>
          <li><a href="https://eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
          <li><a href="https://eclipse.org/legal/copyright.php">Copyright Agent</a></li>
          <li><a href="http://www.eclipse.org/legal">Legal Resources</a></li>
        </ul>
      </div>

      <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright">
        <p>Eclipse Vert.x is open source and dual-licensed under the <a href="http://www.eclipse.org/legal/epl-v20.html">Eclipse Public License 2.0</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.</p>
        <p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>
        Design by <a href="https://www.michel-kraemer.com">Michel Kr&auml;mer</a>.</p>
        <div class="row">
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2">
            <a href="http://eclipse.org">
            <img class="logo eclipse-logo" src="https://vertx.tk/assets/eclipse_logo_grey_small.png" width="204" height="48">
            </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0">
            <a href="http://cloudbees.com">
            <img class="logo cloudbees-logo" src="https://vertx.tk/assets/Button-Built-on-CB-1-grey.png" width="180" height="48">
           </a>
          </div>
          <div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler">
            <a href="http://www.ej-technologies.com/products/jprofiler/overview.html"
            style="text-decoration:none">
            <img class="logo jprofiler-logo" src="https://vertx.tk/assets/jprofiler-logo.png" width="48" height="48"><span class="jprofiler-logo">&nbsp; JPROFILER</span>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://vertx.tk/javascripts/bootstrap.min.js"></script>
<script src="https://vertx.tk/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script src="https://vertx.tk/javascripts/sidebar.js"></script>


<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});
</script>
</body>
</html>

